<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>从尾到头打印链表</title>
      <link href="/2019/03/03/%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/03/03/%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</p><h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">1-&gt;2-&gt;3-&gt;4-&gt;5</span><br><span class="line">返回:</span><br><span class="line">List:5-&gt;4-&gt;3-&gt;2-&gt;1</span><br></pre></td></tr></table></figure><h1 id="思路一"><a href="#思路一" class="headerlink" title="思路一:"></a>思路一:</h1><p>利用方法调用是进栈出栈的特性,利用递归,先走到栈底,等最后的方法出栈时,就能获取到最后的节点的值<br>代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//创建一个结果list,传入递归方法以保证整个递归过程都能往list中加数据</span><br><span class="line">public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    getNext(listNode,list);</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br><span class="line">//递归方法,先递归调用自身,调用完再把当前节点的值添加到list中</span><br><span class="line">private void getNext(ListNode listNode, List&lt;Integer&gt; list) &#123;</span><br><span class="line">    if(listNode==null) return;</span><br><span class="line">    getNext(listNode.next,list);</span><br><span class="line">    list.add(listNode.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="思路二"><a href="#思路二" class="headerlink" title="思路二:"></a>思路二:</h1><p>先反转链表,再从头到尾把链表节点的值加入到list中.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList&lt;Integer&gt; printListFromTailToHead2(ListNode listNode) &#123;</span><br><span class="line">//定义一个临时节点</span><br><span class="line">    ListNode head = listNode;</span><br><span class="line">    ListNode newHead = null;</span><br><span class="line">    while(head!=null) &#123;</span><br><span class="line">        //获取head的下一个节点保存起来</span><br><span class="line">        ListNode temp = head.next;</span><br><span class="line">        //令head节点的next指针指向newHead,也就是null</span><br><span class="line">        head.next = newHead;</span><br><span class="line">        //往后移动,把newHead指向原来head节点的位置,把head指向刚才保存的temp节点,也就是原先的head的next节点</span><br><span class="line">        newHead = head;</span><br><span class="line">        head = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    //循环结束后,newHead节点就是反转后的链表的链表头</span><br><span class="line">    ArrayList&lt;Integer&gt; res = new ArrayList();</span><br><span class="line">    while(newHead!=null)&#123;</span><br><span class="line">        res.add(newHead.val);</span><br><span class="line">        newHead = newHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>替换空格</title>
      <link href="/2019/03/03/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
      <url>/2019/03/03/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: We Are Happy</span><br><span class="line">返回: We%20Are%20Happy</span><br></pre></td></tr></table></figure><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">    String str = &quot; We Are Happy &quot;;</span><br><span class="line">    String res = new 替换空格().replaceSpace(new StringBuffer(str));</span><br><span class="line">    System.out.println(res);</span><br><span class="line">&#125;</span><br><span class="line">public String replaceSpace(StringBuffer str) &#123;</span><br><span class="line">    StringBuilder sb = new StringBuilder();</span><br><span class="line">    for (int i = 0; i &lt; str.length(); i++) &#123;</span><br><span class="line">        char c = str.charAt(i);</span><br><span class="line">        if(c == &apos; &apos;)&#123;</span><br><span class="line">            sb.append(&quot;%20&quot;);</span><br><span class="line">        &#125;else</span><br><span class="line">            sb.append(c);</span><br><span class="line">    &#125;</span><br><span class="line">    return sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二维数组中的查找</title>
      <link href="/2019/03/03/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
      <url>/2019/03/03/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在一个二维数组中（每个一维数组的长度相同），<strong>每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序</strong>。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;1,3,5,6,9&#125;,</span><br><span class="line">&#123;2,5,7,8,12&#125;,</span><br><span class="line">&#123;3,7,9,12,14&#125;</span><br></pre></td></tr></table></figure><p>输入:11<br>返回false<br>输入:12<br>返回:true</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>每次都取二维数组的右上角的数字,与目标数字相比较,若大于目标数字,则可以剔除最后一列;若小于目标数组,则可以剔除最上面的一行.</p><h1 id="代码记录"><a href="#代码记录" class="headerlink" title="代码记录:"></a>代码记录:</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">        int[][] array = &#123;</span><br><span class="line">                &#123;1,3,5,6,9&#125;,</span><br><span class="line">                &#123;2,5,7,8,12&#125;,</span><br><span class="line">                &#123;3,7,9,12,14&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        boolean res = new 二维数组中的查找().Find(12, array);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean Find(int target, int [][] array) &#123;</span><br><span class="line">        int row=0,line = array[row].length-1;</span><br><span class="line">//每次循环判断是否越界,若越界说明已经检查完毕,找不到目标,否则就取出右上角的值与目标值相比较</span><br><span class="line">        while(check(row,line,array))&#123;</span><br><span class="line">            int num = array[row][line];</span><br><span class="line">            if(num==target)</span><br><span class="line">                return true;</span><br><span class="line">            else if(num&gt;target)</span><br><span class="line">                line--;</span><br><span class="line">            else if(num&lt;target)</span><br><span class="line">                row++;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    //检查是否超出二维数组范围的函数,传入行和列的值判断是否越界</span><br><span class="line">    private boolean check(int row, int line, int[][] array) &#123;</span><br><span class="line">        if(row&lt;=array.length-1&amp;&amp;line&gt;=0) return true;</span><br><span class="line">        else</span><br><span class="line">            return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 堆内存设置原理</title>
      <link href="/2019/02/21/JVM-%E5%A0%86%E5%86%85%E5%AD%98%E8%AE%BE%E7%BD%AE%E5%8E%9F%E7%90%86/"/>
      <url>/2019/02/21/JVM-%E5%A0%86%E5%86%85%E5%AD%98%E8%AE%BE%E7%BD%AE%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>JVM堆内存分为2块：Permanent Space 和 Heap Space。</p><blockquote><p>Permanent 即 持久代（Permanent Generation），主要存放的是<strong>Java类定义信息</strong>，与垃圾收集器要收集的Java对象关系不大。<br>Heap = { Old + NEW = {Eden, from, to} }，Old 即 年老代（Old Generation），New 即 年轻代（Young Generation）。年老代和年轻代的划分对垃圾收集影响比较大。</p></blockquote><h2 id="年轻代"><a href="#年轻代" class="headerlink" title="年轻代"></a>年轻代</h2><p>所有新生成的对象首先都是放在年轻代。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。年轻代一般分3个区，1个Eden区，2个Survivor区（from 和 to）。</p><p>大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当一个Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当另一个Survivor区也满了的时候，从前一个Survivor区复制过来的并且此时还存活的对象，将可能被复制到年老代。</p><p>2个Survivor区是对称的，没有先后关系，所以同一个Survivor区中可能同时存在从Eden区复制过来对象，和从另一个Survivor区复制过来的对象；而复制到年老区的只有从另一个Survivor区过来的对象。而且，因为需要交换的原因，Survivor区至少有一个是空的。特殊的情况下，根据程序需要，Survivor区是可以配置为多个的（多于2个），这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。</p><p>针对年轻代的垃圾回收即 Young GC。</p><h2 id="年老代"><a href="#年老代" class="headerlink" title="年老代"></a>年老代</h2><p>在年轻代中经历了N次（可配置）垃圾回收后仍然存活的对象，就会被复制到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。<br><strong>针对年老代的垃圾回收即 Full GC。</strong></p><h2 id="持久代"><a href="#持久代" class="headerlink" title="持久代"></a>持久代</h2><p>用于存放静态类型数据，如 Java Class, Method 等。持久代对垃圾回收没有显著影响。但是有些应用可能动态生成或调用一些Class，例如 Hibernate CGLib 等，在这种时候往往需要设置一个比较大的持久代空间来存放这些运行过程中动态增加的类型。</p><hr><p>所以，当一组对象生成时，内存申请过程如下：</p><ol><li>JVM会试图为相关Java对象在年轻代的Eden区中初始化一块内存区域。</li><li>当Eden区空间足够时，内存申请结束。否则执行下一步。</li><li>JVM试图释放在Eden区中所有不活跃的对象（YoungGC）,释放后若Eden空间仍然不足以放入新对象，JVM则试图将部分Eden区中活跃对象放入Survivor区。</li><li>Survivor区被用来作为Eden区及年老代的中间交换区域。当年老代空间足够时，Survivor区中存活了一定次数的对象会被移到年老代。</li><li>当年老代空间不够时，JVM会在年老代进行完全的垃圾回收（Full GC）。</li><li>Full GC后，若Survivor区及年老代仍然无法存放从Eden区复制过来的对象，则会导致JVM无法在Eden区为新生成的对象申请内存，即出现“Out of Memory”。</li></ol><h2 id="OOM（“Out-of-Memory”）异常"><a href="#OOM（“Out-of-Memory”）异常" class="headerlink" title="OOM（“Out of Memory”）异常"></a>OOM（“Out of Memory”）异常</h2><p>一般主要有如下2种原因：</p><ol><li><p>年老代溢出，表现为：java.lang.OutOfMemoryError:Javaheapspace<br>这是最常见的情况，产生的原因可能是：设置的内存参数Xmx过小或程序的内存泄露及使用不当问题。<br>例如循环上万次的字符串处理、创建上千万个对象、在一段代码内申请上百M甚至上G的内存。还有的时候虽然不会报内存溢出，却会使系统不间断的垃圾回收，也无法处理其它请求。这种情况下除了检查程序、打印堆内存等方法排查，还可以借助一些内存分析工具，比如MAT就很不错。</p></li><li><p>持久代溢出，表现为：java.lang.OutOfMemoryError:PermGenspace<br>通常由于持久代设置过小，动态加载了大量Java类而导致溢出，解决办法唯有将参数 -XX:MaxPermSize 调大（一般256m能满足绝大多数应用程序需求）。将部分Java类放到容器共享区（例如Tomcat share lib）去加载的办法也是一个思路，但前提是容器里部署了多个应用，且这些应用有大量的共享类库。</p></li></ol><h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><p>-Xmx3550m：设置JVM最大堆内存为3550M。<br>-Xms3550m：设置JVM初始堆内存为3550M。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。<br>-Xss128k：设置每个线程的栈大小。JDK5.0以后每个线程栈大小为1M，之前每个线程栈大小为256K。应当根据应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。需要注意的是：当这个值被设置的较大（例如&gt;2MB）时将会在很大程度上降低系统的性能。<br><strong>-Xmn2g：设置年轻代大小为2G。在整个堆内存大小确定的情况下，增大年轻代将会减小年老代，反之亦然。此值关系到JVM垃圾回收，对系统性能影响较大，官方推荐配置为整个堆大小的3/8。</strong><br>-XX:NewSize=1024m：设置年轻代初始值为1024M。<br>-XX:MaxNewSize=1024m：设置年轻代最大值为1024M。<br>-XX:PermSize=256m：设置持久代初始值为256M。<br>-XX:MaxPermSize=256m：设置持久代最大值为256M。<br>-XX:NewRatio=4：表示年轻代比年老代为1:4。<br>-XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的比值。表示2个Survivor区（JVM堆内存年轻代中默认有2个大小相等的Survivor区）与1个Eden区的比值为2:4，即1个Survivor区占整个年轻代大小的1/6。<br>-XX:MaxTenuringThreshold=7：表示一个对象如果在Survivor区（救助空间）移动了7次还没有被垃圾回收就进入年老代。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代，对于需要大量常驻内存的应用，这样做可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象在年轻代存活时间，增加对象在年轻代被垃圾回收的概率，减少Full GC的频率，这样做可以在某种程度上提高服务稳定性。</p><h2 id="疑问解答"><a href="#疑问解答" class="headerlink" title="疑问解答"></a>疑问解答</h2><p>-Xmn，-XX:NewSize/-XX:MaxNewSize，-XX:NewRatio 3组参数都可以影响年轻代的大小，混合使用的情况下，优先级是什么？<br>如下：<br>高优先级：-XX:NewSize/-XX:MaxNewSize<br>中优先级：-Xmn（默认等效  -Xmn=-XX:NewSize=-XX:MaxNewSize=?）<br>低优先级：-XX:NewRatio<br>推荐使用-Xmn参数，原因是这个参数简洁，相当于一次设定 NewSize/MaxNewSIze，而且两者相等，适用于生产环境。-Xmn 配合 -Xms/-Xmx，即可将堆内存布局完成。<br>-Xmn参数是在JDK 1.4 开始支持。</p><h2 id="垃圾回收器选择"><a href="#垃圾回收器选择" class="headerlink" title="垃圾回收器选择"></a>垃圾回收器选择</h2><p>JVM给出了3种选择：串行收集器、并行收集器、并发收集器<strong>。串行收集器只适用于小数据量的情况，所以生产环境的选择主要是并行收集器和并发收集器</strong>。</p><p>默认情况下<strong>JDK5.0以前都是使用串行收集器</strong>，如果想使用其他收集器需要在启动时加入相应参数。JDK5.0以后，JVM会根据当前系统配置进行智能判断。</p><h3 id="串行收集器"><a href="#串行收集器" class="headerlink" title="串行收集器"></a>串行收集器</h3><p>-XX:+UseSerialGC：设置串行收集器。</p><h3 id="并行收集器（吞吐量优先）"><a href="#并行收集器（吞吐量优先）" class="headerlink" title="并行收集器（吞吐量优先）"></a>并行收集器（吞吐量优先）</h3><p><strong>-XX:+UseParallelGC：设置为并行收集器。此配置仅对年轻代有效。即年轻代使用并行收集，而年老代仍使用串行收集。</strong><br>-XX:ParallelGCThreads=20：配置并行收集器的线程数，即：同时有多少个线程一起进行垃圾回收。此值建议配置与CPU数目相等。<br>-XX:+UseParallelOldGC：配置年老代垃圾收集方式为并行收集。JDK6.0开始支持对年老代并行收集。<br>-XX:MaxGCPauseMillis=100：设置每次年轻代垃圾回收的最长时间（单位毫秒）。如果无法满足此时间，JVM会自动调整年轻代大小，以满足此时间。<br>-XX:+UseAdaptiveSizePolicy：设置此选项后，并行收集器会自动调整年轻代Eden区大小和Survivor区大小的比例，以达成目标系统规定的最低响应时间或者收集频率等指标。此参数建议在使用并行收集器时，一直打开。</p><h3 id="并发收集器（响应时间优先）"><a href="#并发收集器（响应时间优先）" class="headerlink" title="并发收集器（响应时间优先）"></a>并发收集器（响应时间优先）</h3><p><strong>-XX:+UseConcMarkSweepGC：即CMS收集，设置年老代为并发收集。CMS收集是JDK1.4后期版本开始引入的新GC算法。它的主要适合场景是对响应时间的重要性需求大于对吞吐量的需求，能够承受垃圾回收线程和应用线程共享CPU资源，并且应用中存在比较多的长生命周期对象。CMS收集的目标是尽量减少应用的暂停时间，减少Full GC发生的几率，利用和应用程序线程并发的垃圾回收线程来标记清除年老代内存。</strong><br>-XX:+UseParNewGC：设置年轻代为并发收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此参数。<br>-XX:CMSFullGCsBeforeCompaction=0：由于并发收集器不对内存空间进行压缩和整理，所以运行一段时间并行收集以后会产生内存碎片，内存使用效率降低。此参数设置运行0次Full GC后对内存空间进行压缩和整理，即每次Full GC后立刻开始压缩和整理内存。<br>-XX:+UseCMSCompactAtFullCollection：打开内存空间的压缩和整理，在Full GC后执行。可能会影响性能，但可以消除内存碎片。<br>-XX:+CMSIncrementalMode：设置为增量收集模式。一般适用于单CPU情况。<br>-XX:CMSInitiatingOccupancyFraction=70：表示年老代内存空间使用到70%时就开始执行CMS收集，以确保年老代有足够的空间接纳来自年轻代的对象，避免Full GC的发生。<br>其它垃圾回收参数<br>-XX:+ScavengeBeforeFullGC：年轻代GC优于Full GC执行。<br>-XX:-DisableExplicitGC：不响应 System.gc() 代码。<br>-XX:+UseThreadPriorities：启用本地线程优先级API。即使 java.lang.Thread.setPriority() 生效，不启用则无效。<br>-XX:SoftRefLRUPolicyMSPerMB=0：软引用对象在最后一次被访问后能存活0毫秒（JVM默认为1000毫秒）。<br>-XX:TargetSurvivorRatio=90：允许90%的Survivor区被占用（JVM默认为50%）。提高对于Survivor区的使用率。<br>辅助信息参数设置<br>-XX:-CITime：打印消耗在JIT编译的时间。<br>-XX:ErrorFile=./hs_err_pid.log：保存错误日志或数据到指定文件中。<br>-XX:HeapDumpPath=./java_pid.hprof：指定Dump堆内存时的路径。<br>-XX:-HeapDumpOnOutOfMemoryError：当首次遭遇内存溢出时Dump出此时的堆内存。<br>-XX:OnError=”;”：出现致命ERROR后运行自定义命令。<br>-XX:OnOutOfMemoryError=”;”：当首次遭遇内存溢出时执行自定义命令。<br>-XX:-PrintClassHistogram：按下 Ctrl+Break 后打印堆内存中类实例的柱状信息，同JDK的 jmap -histo 命令。<br>-XX:-PrintConcurrentLocks：按下 Ctrl+Break 后打印线程栈中并发锁的相关信息，同JDK的 jstack -l 命令。<br>-XX:-PrintCompilation：当一个方法被编译时打印相关信息。<br>-XX:-PrintGC：每次GC时打印相关信息。<br>-XX:-PrintGCDetails：每次GC时打印详细信息。<br>-XX:-PrintGCTimeStamps：打印每次GC的时间戳。<br>-XX:-TraceClassLoading：跟踪类的加载信息。<br>-XX:-TraceClassLoadingPreorder：跟踪被引用到的所有类的加载信息。<br>-XX:-TraceClassResolution：跟踪常量池。<br>-XX:-TraceClassUnloading：跟踪类的卸载信息。</p><h2 id="粗体文本关于参数名称等"><a href="#粗体文本关于参数名称等" class="headerlink" title="粗体文本关于参数名称等"></a><strong>粗体文本</strong>关于参数名称等</h2><p>标准参数（-），所有JVM都必须支持这些参数的功能，而且向后兼容；例如：<br>-client——设置JVM使用Client模式，特点是启动速度比较快，但运行时性能和内存管理效率不高，通常用于客户端应用程序或开发调试；在32位环境下直接运行Java程序默认启用该模式。<br>-server——设置JVM使Server模式，特点是启动速度比较慢，但运行时性能和内存管理效率很高，适用于生产环境。在具有64位能力的JDK环境下默认启用该模式。<br>非标准参数（-X），默认JVM实现这些参数的功能，但是并不保证所有JVM实现都满足，且不保证向后兼容；<br>非稳定参数（-XX），此类参数各个JVM实现会有所不同，将来可能会不被支持，需要慎重使用；</p>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS中的Promise对象</title>
      <link href="/2019/02/20/JS%E4%B8%AD%E7%9A%84Promise%E5%AF%B9%E8%B1%A1/"/>
      <url>/2019/02/20/JS%E4%B8%AD%E7%9A%84Promise%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="Promise-的含义"><a href="#Promise-的含义" class="headerlink" title="Promise 的含义"></a>Promise 的含义</h2><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。</p><p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p><p>Promise对象有以下两个特点。</p><blockquote><p>（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p></blockquote><blockquote><p>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p></blockquote><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。<br>下面代码创造了一个Promise实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line">  // ... some code</span><br><span class="line"></span><br><span class="line">  if (/* 异步操作成功 */)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.then(function(value) &#123;</span><br><span class="line">  // success</span><br><span class="line">&#125;, function(error) &#123;</span><br><span class="line">  // failure</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。</p><p>Promise对象的简单例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function timeout(ms) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  //setTimeout的第三个参数将作为第一个参数(也就是要执行的方法)的参数)</span><br><span class="line">    setTimeout(resolve, ms, &apos;done&apos;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timeout(100).then((value) =&gt; &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>上面代码中，timeout方法返回一个Promise实例，表示一段时间以后才会发生的结果。过了指定的时间（ms参数）以后，Promise实例的状态变为resolved，就会触发then方法绑定的回调函数。</p><p>Promise 新建后就会立即执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line">  console.log(&apos;Promise&apos;);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(function() &#123;</span><br><span class="line">  console.log(&apos;resolved.&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&apos;Hi!&apos;);</span><br></pre></td></tr></table></figure></p><p>resolve函数的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const p1 = new Promise(function (resolve, reject) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const p2 = new Promise(function (resolve, reject) &#123;</span><br><span class="line">  // ...</span><br><span class="line">  resolve(p1);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>上面代码中，p1和p2都是 Promise 的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。</p><p>注意，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const p1 = new Promise(function (resolve, reject) &#123;</span><br><span class="line">  setTimeout(() =&gt; reject(new Error(&apos;fail&apos;)), 3000)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const p2 = new Promise(function (resolve, reject) &#123;</span><br><span class="line">  setTimeout(() =&gt; resolve(p1), 1000)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p2</span><br><span class="line">  .then(result =&gt; console.log(result))</span><br><span class="line">  .catch(error =&gt; console.log(error))</span><br></pre></td></tr></table></figure></p><p>上面代码中，p1是一个 Promise，3 秒之后变为rejected。p2的状态在 1 秒之后改变，resolve方法返回的是p1。由于p2返回的是另一个 Promise，导致p2自己的状态无效了，由p1的状态决定p2的状态。所以，后面的then语句都变成针对后者（p1）。又过了 2 秒，p1变为rejected，导致触发catch方法指定的回调函数。</p><p><strong>调用resolve或reject并不会终结 Promise 的参数函数的执行。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve(1);</span><br><span class="line">  console.log(2);</span><br><span class="line">&#125;).then(r =&gt; &#123;</span><br><span class="line">  console.log(r);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>上面代码中，调用resolve(1)以后，后面的console.log(2)还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。</p><p>一般来说，调用resolve或reject以后，Promise 的使命就完成了，后继操作应该放到then方法里面，而不应该直接写在resolve或reject的后面。所以，最好在它们前面加上return语句，这样就不会有意外。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  return resolve(1);</span><br><span class="line">  // 后面的语句不会执行</span><br><span class="line">  console.log(2);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h2><p>Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。</p><p><strong>then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getJSON(&quot;/posts.json&quot;).then(function(json) &#123;</span><br><span class="line">  return json.post;</span><br><span class="line">&#125;).then(function(post) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p><p>采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getJSON(&quot;/post/1.json&quot;).then(function(post) &#123;</span><br><span class="line">  return getJSON(post.commentURL);</span><br><span class="line">&#125;).then(function funcA(comments) &#123;</span><br><span class="line">  console.log(&quot;resolved: &quot;, comments);</span><br><span class="line">&#125;, function funcB(err)&#123;</span><br><span class="line">  console.log(&quot;rejected: &quot;, err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>上面代码中，第一个then方法指定的回调函数，返回的是另一个Promise对象。这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。如果变为resolved，就调用funcA，如果状态变为rejected，就调用funcB。</p><p>采用箭头函数的写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getJSON(&quot;/post/1.json&quot;).then(</span><br><span class="line">  post =&gt; getJSON(post.commentURL)</span><br><span class="line">).then(</span><br><span class="line">  comments =&gt; console.log(&quot;resolved: &quot;, comments),</span><br><span class="line">  err =&gt; console.log(&quot;rejected: &quot;, err)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><h2 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h2><p>Promise.prototype.catch方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getJSON(&apos;/posts.json&apos;).then(function(posts) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;).catch(function(error) &#123;</span><br><span class="line">  // 处理 getJSON 和 前一个回调函数运行时发生的错误</span><br><span class="line">  console.log(&apos;发生错误！&apos;, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>上面代码中，getJSON方法返回一个 Promise 对象，如果该对象状态变为resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p.then((val) =&gt; console.log(&apos;fulfilled:&apos;, val))</span><br><span class="line">  .catch((err) =&gt; console.log(&apos;rejected&apos;, err));</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">p.then((val) =&gt; console.log(&apos;fulfilled:&apos;, val))</span><br><span class="line">  .then(null, (err) =&gt; console.log(&quot;rejected:&quot;, err));</span><br></pre></td></tr></table></figure></p><p>例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line">  throw new Error(&apos;test&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">promise.catch(function(error) &#123;</span><br><span class="line">  console.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>promise抛出一个错误，就被catch方法指定的回调函数捕获。注意，上面的写法与下面两种写法等价。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 写法一</span><br><span class="line">const promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    throw new Error(&apos;test&apos;);</span><br><span class="line">  &#125; catch(e) &#123;</span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">promise.catch(function(error) &#123;</span><br><span class="line">  console.log(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 写法二</span><br><span class="line">const promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line">  reject(new Error(&apos;test&apos;));</span><br><span class="line">&#125;);</span><br><span class="line">promise.catch(function(error) &#123;</span><br><span class="line">  console.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>reject方法的作用，等同于抛出错误。<br><strong>如果 Promise 状态已经变成resolved，再抛出错误是无效的。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line">  resolve(&apos;ok&apos;);</span><br><span class="line">  throw new Error(&apos;test&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">promise</span><br><span class="line">  .then(function(value) &#123; console.log(value) &#125;)</span><br><span class="line">  .catch(function(error) &#123; console.log(error) &#125;);</span><br></pre></td></tr></table></figure></p><p>上面代码中，Promise 在resolve语句后面，再抛出错误，不会被捕获，等于没有抛出。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了。</p><p>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getJSON(&apos;/post/1.json&apos;).then(function(post) &#123;</span><br><span class="line">  return getJSON(post.commentURL);</span><br><span class="line">&#125;).then(function(comments) &#123;</span><br><span class="line">  // some code</span><br><span class="line">&#125;).catch(function(error) &#123;</span><br><span class="line">  // 处理前面三个Promise产生的错误</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>三个 Promise 对象：一个由getJSON产生，两个由then产生。它们之中任何一个抛出的错误，都会被最后一个catch捕获。<br>一般来说，不要在then方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">  .then(function(data) &#123;</span><br><span class="line">    // success</span><br><span class="line">  &#125;, function(err) &#123;</span><br><span class="line">    // error</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">promise</span><br><span class="line">  .then(function(data) &#123; //cb</span><br><span class="line">    // success</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(function(err) &#123;</span><br><span class="line">    // error</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></p><p>第二种写法要好于第一种写法，理由是第二种写法可以捕获前面then方法执行中的错误，也更接近同步的写法（try/catch）。建议使用catch方法，而不使用then方法的第二个参数。<br>跟传统的try/catch代码块不同的是，如果没有使用catch方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const someAsyncThing = function() &#123;</span><br><span class="line">  return new Promise(function(resolve, reject) &#123;</span><br><span class="line">    // 下面一行会报错，因为x没有声明</span><br><span class="line">    resolve(x + 2);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">someAsyncThing().then(function() &#123;</span><br><span class="line">  console.log(&apos;everything is great&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123; console.log(123) &#125;, 2000);</span><br></pre></td></tr></table></figure></p><p>Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。</p><p>这个脚本放在服务器执行，退出码就是0（即表示执行成功）。不过，Node 有一个unhandledRejection事件，专门监听未捕获的reject错误，上面的脚本会触发这个事件的监听函数，可以在监听函数里面抛出错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process.on(&apos;unhandledRejection&apos;, function (err, p) &#123;</span><br><span class="line">  throw err;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>一般总是建议，Promise 对象后面要跟catch方法，这样可以处理 Promise 内部发生的错误。catch方法返回的还是一个 Promise 对象，因此后面还可以接着调用then方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const someAsyncThing = function() &#123;</span><br><span class="line">  return new Promise(function(resolve, reject) &#123;</span><br><span class="line">    // 下面一行会报错，因为x没有声明</span><br><span class="line">    resolve(x + 2);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">someAsyncThing()</span><br><span class="line">.catch(function(error) &#123;</span><br><span class="line">  console.log(&apos;oh no&apos;, error);</span><br><span class="line">&#125;)</span><br><span class="line">.then(function() &#123;</span><br><span class="line">  console.log(&apos;carry on&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">// oh no [ReferenceError: x is not defined]</span><br><span class="line">// carry on</span><br></pre></td></tr></table></figure></p><p>上面代码运行完catch方法指定的回调函数，会接着运行后面那个then方法指定的回调函数。如果没有报错，则会跳过catch方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve()</span><br><span class="line">.catch(function(error) &#123;</span><br><span class="line">  console.log(&apos;oh no&apos;, error);</span><br><span class="line">&#125;)</span><br><span class="line">.then(function() &#123;</span><br><span class="line">  console.log(&apos;carry on&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>上面的代码因为没有报错，跳过了catch方法，直接执行后面的then方法。此时，要是then方法里面报错，就与前面的catch无关了。</p><p>catch方法之中，还能再抛出错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const someAsyncThing = function() &#123;</span><br><span class="line">  return new Promise(function(resolve, reject) &#123;</span><br><span class="line">    // 下面一行会报错，因为x没有声明</span><br><span class="line">    resolve(x + 2);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">someAsyncThing().then(function() &#123;</span><br><span class="line">  return someOtherAsyncThing();</span><br><span class="line">&#125;).catch(function(error) &#123;</span><br><span class="line">  console.log(&apos;oh no&apos;, error);</span><br><span class="line">  // 下面一行会报错，因为 y 没有声明</span><br><span class="line">  y + 2;</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">  console.log(&apos;carry on&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">// oh no [ReferenceError: x is not defined]</span><br></pre></td></tr></table></figure></p><p>上面代码中，catch方法抛出一个错误，因为后面没有别的catch方法了，导致这个错误不会被捕获，也不会传递到外层。继续改写一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">someAsyncThing().then(function() &#123;</span><br><span class="line">  return someOtherAsyncThing();</span><br><span class="line">&#125;).catch(function(error) &#123;</span><br><span class="line">  console.log(&apos;oh no&apos;, error);</span><br><span class="line">  // 下面一行会报错，因为y没有声明</span><br><span class="line">  y + 2;</span><br><span class="line">&#125;).catch(function(error) &#123;</span><br><span class="line">  console.log(&apos;carry on&apos;, error);</span><br><span class="line">&#125;);</span><br><span class="line">// oh no [ReferenceError: x is not defined]</span><br><span class="line">// carry on [ReferenceError: y is not defined]</span><br></pre></td></tr></table></figure></p><p>第二个catch方法用来捕获前一个catch方法抛出的错误。</p><h2 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h2><p>finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">.then(result =&gt; &#123;···&#125;)</span><br><span class="line">.catch(error =&gt; &#123;···&#125;)</span><br><span class="line">.finally(() =&gt; &#123;···&#125;);</span><br></pre></td></tr></table></figure></p><p>上面代码中，不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。</p><p>下面是一个例子，服务器使用 Promise 处理请求，然后使用finally方法关掉服务器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server.listen(port)</span><br><span class="line">  .then(function () &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;)</span><br><span class="line">  .finally(server.stop);</span><br></pre></td></tr></table></figure></p><p>finally方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是fulfilled还是rejected。这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</p><p>finally本质上是then方法的特例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">.finally(() =&gt; &#123;</span><br><span class="line">  // 语句</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">promise</span><br><span class="line">.then(</span><br><span class="line">  result =&gt; &#123;</span><br><span class="line">    // 语句</span><br><span class="line">    return result;</span><br><span class="line">  &#125;,</span><br><span class="line">  error =&gt; &#123;</span><br><span class="line">    // 语句</span><br><span class="line">    throw error;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>上面代码中，如果不使用finally方法，同样的语句需要为成功和失败两种情况各写一次。有了finally方法，则只需要写一次。</p><p>它的实现也很简单。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Promise.prototype.finally = function (callback) &#123;</span><br><span class="line">  let P = this.constructor;</span><br><span class="line">  return this.then(</span><br><span class="line">    value  =&gt; P.resolve(callback()).then(() =&gt; value),</span><br><span class="line">    reason =&gt; P.resolve(callback()).then(() =&gt; &#123; throw reason &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>上面代码中，不管前面的 Promise 是fulfilled还是rejected，都会执行回调函数callback。</p><p>从上面的实现还可以看到，finally方法总是会返回原来的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// resolve 的值是 undefined</span><br><span class="line">Promise.resolve(2).then(() =&gt; &#123;&#125;, () =&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line">// resolve 的值是 2</span><br><span class="line">Promise.resolve(2).finally(() =&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line">// reject 的值是 undefined</span><br><span class="line">Promise.reject(3).then(() =&gt; &#123;&#125;, () =&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line">// reject 的值是 3</span><br><span class="line">Promise.reject(3).finally(() =&gt; &#123;&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h2><p>Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const p = Promise.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure></p><p>上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。）</p><p>p的状态由p1、p2、p3决定，分成两种情况。<br>（1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。<br>（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。<br>下面是一个具体的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 生成一个Promise对象的数组</span><br><span class="line">const promises = [2, 3, 5, 7, 11, 13].map(function (id) &#123;</span><br><span class="line">  return getJSON(&apos;/post/&apos; + id + &quot;.json&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Promise.all(promises).then(function (posts) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;).catch(function(reason)&#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>上面代码中，promises是包含 6 个 Promise 实例的数组，只有这 6 个实例的状态都变成fulfilled，或者其中有一个变为rejected，才会调用Promise.all方法后面的回调函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const databasePromise = connectDatabase();</span><br><span class="line"></span><br><span class="line">const booksPromise = databasePromise</span><br><span class="line">  .then(findAllBooks);</span><br><span class="line"></span><br><span class="line">const userPromise = databasePromise</span><br><span class="line">  .then(getCurrentUser);</span><br><span class="line"></span><br><span class="line">Promise.all([</span><br><span class="line">  booksPromise,</span><br><span class="line">  userPromise</span><br><span class="line">])</span><br><span class="line">.then(([books, user]) =&gt; pickTopRecommendations(books, user));</span><br></pre></td></tr></table></figure></p><p>上面代码中，booksPromise和userPromise是两个异步操作，只有等到它们的结果都返回了，才会触发pickTopRecommendations这个回调函数。</p><p>注意，如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const p1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve(&apos;hello&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">.then(result =&gt; result)</span><br><span class="line">.catch(e =&gt; e);</span><br><span class="line"></span><br><span class="line">const p2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  throw new Error(&apos;报错了&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">.then(result =&gt; result)</span><br><span class="line">.catch(e =&gt; e);</span><br><span class="line"></span><br><span class="line">Promise.all([p1, p2])</span><br><span class="line">.then(result =&gt; console.log(result))</span><br><span class="line">.catch(e =&gt; console.log(e));</span><br><span class="line">// [&quot;hello&quot;, Error: 报错了]</span><br></pre></td></tr></table></figure></p><p>上面代码中，p1会resolved，p2首先会rejected，但是p2有自己的catch方法，该方法返回的是一个新的 Promise 实例，p2指向的实际上是这个实例。该实例执行完catch方法后，也会变成resolved，导致Promise.all()方法参数里面的两个实例都会resolved，因此会调用then方法指定的回调函数，而不会调用catch方法指定的回调函数。</p><p>如果p2没有自己的catch方法，就会调用Promise.all()的catch方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const p1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve(&apos;hello&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">.then(result =&gt; result);</span><br><span class="line"></span><br><span class="line">const p2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  throw new Error(&apos;报错了&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">.then(result =&gt; result);</span><br><span class="line"></span><br><span class="line">Promise.all([p1, p2])</span><br><span class="line">.then(result =&gt; console.log(result))</span><br><span class="line">.catch(e =&gt; console.log(e));</span><br><span class="line">// Error: 报错了</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS中const,var,let的区别</title>
      <link href="/2019/02/19/JS%E4%B8%ADconst-var-let%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/02/19/JS%E4%B8%ADconst-var-let%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="1-块作用域"><a href="#1-块作用域" class="headerlink" title="1. 块作用域{ }"></a>1. 块作用域{ }</h2><p>JS中作用域有：全局作用域、函数作用域。没有块作用域的概念。ECMAScript 6(简称ES6)中新增了块级作用域。<br>块作用域由 { } 包括，if语句和for语句里面的{ }也属于块作用域。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">&#123;</span><br><span class="line">var a = 1;</span><br><span class="line">console.log(a); // 1</span><br><span class="line">&#125;</span><br><span class="line">console.log(a); // 1</span><br><span class="line">// 可见，通过var定义的变量可以跨块作用域访问到。</span><br><span class="line"></span><br><span class="line">(function A() &#123;</span><br><span class="line">var b = 2;</span><br><span class="line">console.log(b); // 2</span><br><span class="line">&#125;)();</span><br><span class="line">// console.log(b); // 报错，</span><br><span class="line">// 可见，通过var定义的变量不能跨函数作用域访问到</span><br><span class="line"></span><br><span class="line">if(true) &#123;</span><br><span class="line">var c = 3;</span><br><span class="line">&#125;</span><br><span class="line">console.log(c); // 3</span><br><span class="line">for(var i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">var d = 5;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(i);// 4   (循环结束i已经是4，所以此处i为4)</span><br><span class="line">console.log(d); // 5</span><br><span class="line">// if语句和for语句中用var定义的变量可以在外面访问到，</span><br><span class="line">// 可见，if语句和for语句属于块作用域，不属于函数作用域。</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h2 id="2-var、let、const的区别"><a href="#2-var、let、const的区别" class="headerlink" title="2. var、let、const的区别"></a>2. var、let、const的区别</h2><p>var定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问。<br>let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。<br>const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">// 块作用域</span><br><span class="line">&#123;</span><br><span class="line">var a = 1;</span><br><span class="line">let b = 2;</span><br><span class="line">const c = 3;</span><br><span class="line">// c = 4; // 报错</span><br><span class="line">var aa;</span><br><span class="line">let bb;</span><br><span class="line">// const cc; // 报错</span><br><span class="line">console.log(a); // 1</span><br><span class="line">console.log(b); // 2</span><br><span class="line">console.log(c); // 3</span><br><span class="line">console.log(aa); // undefined</span><br><span class="line">console.log(bb); // undefined</span><br><span class="line">&#125;</span><br><span class="line">console.log(a); // 1</span><br><span class="line">// console.log(b); // 报错</span><br><span class="line">// console.log(c); // 报错</span><br><span class="line"></span><br><span class="line">// 函数作用域</span><br><span class="line">(function A() &#123;</span><br><span class="line">var d = 5;</span><br><span class="line">let e = 6;</span><br><span class="line">const f = 7;</span><br><span class="line">console.log(d); // 5</span><br><span class="line">console.log(e); // 6  (在同一个&#123; &#125;中,也属于同一个块，可以正常访问到)</span><br><span class="line">console.log(f); // 7  (在同一个&#123; &#125;中,也属于同一个块，可以正常访问到)</span><br><span class="line"></span><br><span class="line">&#125;)();</span><br><span class="line">// console.log(d); // 报错</span><br><span class="line">// console.log(e); // 报错</span><br><span class="line">// console.log(f); // 报错</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot整合SpringSecurity</title>
      <link href="/2019/02/16/SpringBoot%E6%95%B4%E5%90%88SpringSecurity/"/>
      <url>/2019/02/16/SpringBoot%E6%95%B4%E5%90%88SpringSecurity/</url>
      
        <content type="html"><![CDATA[<h2 id="引入maven依赖"><a href="#引入maven依赖" class="headerlink" title="引入maven依赖"></a>引入maven依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="在config包下创建配置文件WebSecurityConfig-自定义用户认证逻辑"><a href="#在config包下创建配置文件WebSecurityConfig-自定义用户认证逻辑" class="headerlink" title="在config包下创建配置文件WebSecurityConfig,自定义用户认证逻辑"></a>在config包下创建配置文件WebSecurityConfig,自定义用户认证逻辑</h2><p>每个系统肯定是有自己的一套用户体系的，所以我们需要自定义自己的认证逻辑以及登录界面。<br>这里我们需要先对SpringSecurity进行相应的配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    //登陆成功的handler</span><br><span class="line">    MyAuthenctiationSuccessHandler successHandler;</span><br><span class="line">    @Autowired</span><br><span class="line">    MyAuthenctiationFailureHandler failureHandler;</span><br><span class="line">    @Bean</span><br><span class="line">    public PasswordEncoder passwordEncoder()&#123;</span><br><span class="line">        return new BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">        http.formLogin()                    //  定义当需要用户登录时候，转到的登录页面。</span><br><span class="line">                .loginPage(&quot;/login&quot;)</span><br><span class="line">                .loginProcessingUrl(&quot;/user/login&quot;)  // 自定义的登录接口</span><br><span class="line">                .successHandler(successHandler)</span><br><span class="line">//                .failureHandler(failureHandler)</span><br><span class="line">                .and()</span><br><span class="line">                .authorizeRequests()        // 定义哪些URL需要被保护、哪些不需要被保护</span><br><span class="line">                .antMatchers(&quot;/login&quot;).permitAll()</span><br><span class="line">                .anyRequest()               // 任何请求,登录后可以访问</span><br><span class="line">                .authenticated().and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(WebSecurity web) throws Exception &#123;</span><br><span class="line">    //css,js等资源放行</span><br><span class="line">        web.ignoring().antMatchers(&quot;/assets/**&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="UserDetail"><a href="#UserDetail" class="headerlink" title="UserDetail"></a>UserDetail</h2><p>UserDetails 就是封装了用户信息的对象，里面包含了七个方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public interface UserDetails extends Serializable &#123;</span><br><span class="line">    // 封装了权限信息</span><br><span class="line">    Collection&lt;? extends GrantedAuthority&gt; getAuthorities();</span><br><span class="line">    // 密码信息</span><br><span class="line">    String getPassword();</span><br><span class="line">    // 登录用户名</span><br><span class="line">    String getUsername();</span><br><span class="line">    // 帐户是否过期</span><br><span class="line">    boolean isAccountNonExpired();</span><br><span class="line">    // 帐户是否被冻结</span><br><span class="line">    boolean isAccountNonLocked();</span><br><span class="line">    // 帐户密码是否过期，一般有的密码要求性高的系统会使用到，比较每隔一段时间就要求用户重置密码</span><br><span class="line">    boolean isCredentialsNonExpired();</span><br><span class="line">    // 帐号是否可用</span><br><span class="line">    boolean isEnabled();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在返回UserDetails的实现类User的时候，可以通过User的构造方法，设置对应的参数</p><h2 id="密码加密解密"><a href="#密码加密解密" class="headerlink" title="密码加密解密"></a>密码加密解密</h2><p>SpringSecurity中有一个PasswordEncoder接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface PasswordEncoder &#123;</span><br><span class="line">    // 对密码进行加密</span><br><span class="line">    String encode(CharSequence var1);</span><br><span class="line">    // 对密码进行判断匹配</span><br><span class="line">    boolean matches(CharSequence var1, String var2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要自己实现这个接口，并在配置文件中配置一下就可以了。<br>这里我暂时以默认提供的一个实现类进行测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// BrowerSecurityConfig </span><br><span class="line">@Bean</span><br><span class="line">public PasswordEncoder passwordEncoder() &#123;</span><br><span class="line">     return new BCryptPasswordEncoder();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h2 id="新建一个类实现UserDetailsService-并配置密码加密解密"><a href="#新建一个类实现UserDetailsService-并配置密码加密解密" class="headerlink" title="新建一个类实现UserDetailsService,并配置密码加密解密"></a>新建一个类实现UserDetailsService,并配置密码加密解密</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class CustomUserService implements UserDetailsService &#123; //自定义UserDetailsService 接口</span><br><span class="line">    @Autowired</span><br><span class="line">    private PasswordEncoder passwordEncoder;</span><br><span class="line">    @Autowired</span><br><span class="line">    UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public UserDetails loadUserByUsername(String username) &#123; //重写loadUserByUsername 方法获得 userdetails 类型用户</span><br><span class="line">    //直接调用JPA的接口即可获取用户信息</span><br><span class="line">        User user = userRepository.findByName(username);</span><br><span class="line">        if(user == null)&#123;</span><br><span class="line">            throw new UsernameNotFoundException(&quot;用户名不存在&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;SimpleGrantedAuthority&gt; authorities = new ArrayList&lt;&gt;();</span><br><span class="line">        //用于添加用户的权限。只要把用户权限添加到authorities 就万事大吉。</span><br><span class="line">        for(Authority role:user.getAuthorityList())&#123;</span><br><span class="line">            authorities.add(new SimpleGrantedAuthority(role.getAuthorityname()));</span><br><span class="line">        &#125;</span><br><span class="line">        return new org.springframework.security.core.userdetails.User(user.getName(),</span><br><span class="line">                passwordEncoder.encode(user.getPassword()), authorities);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义控制器"><a href="#定义控制器" class="headerlink" title="定义控制器"></a>定义控制器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/login&quot;)</span><br><span class="line">public String login()&#123;</span><br><span class="line">    return &quot;login&quot;;</span><br><span class="line">&#125;</span><br><span class="line">@RequestMapping(&quot;/&quot;)</span><br><span class="line">public String getIndex(HttpServletRequest request)&#123;</span><br><span class="line">    return &quot;success&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="User类"><a href="#User类" class="headerlink" title="User类"></a>User类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">@Entity</span><br><span class="line">@Proxy(lazy = false)</span><br><span class="line">//若没有声明table 则表名和类名一致</span><br><span class="line">public class User &#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy = GenerationType.IDENTITY)</span><br><span class="line">    private Integer id;</span><br><span class="line">    @Column</span><br><span class="line">    private String name;</span><br><span class="line">    @Column</span><br><span class="line">    private String password;</span><br><span class="line">    @ManyToMany</span><br><span class="line">    @JoinTable(name = &quot;user_authority&quot;,joinColumns = @JoinColumn(name = &quot;user_id&quot;),</span><br><span class="line">            inverseJoinColumns = @JoinColumn(name = &quot;authority_id&quot;))</span><br><span class="line">    //1、关系维护端，负责多对多关系的绑定和解除</span><br><span class="line">    //2、@JoinTable注解的name属性指定关联表的名字，joinColumns指定外键的名字，关联到关系维护端(User)</span><br><span class="line">    //3、inverseJoinColumns指定外键的名字，要关联的关系被维护端(Authority)</span><br><span class="line">    //4、其实可以不使用@JoinTable注解，默认生成的关联表名称为主表表名+下划线+从表表名，</span><br><span class="line">    //即表名为user_authority</span><br><span class="line">    //关联到主表的外键名：主表名+下划线+主表中的主键列名,即user_id</span><br><span class="line">    //关联到从表的外键名：主表中用于关联的属性名+下划线+从表的主键列名,即authority_id</span><br><span class="line">    //主表就是关系维护端对应的表，从表就是关系被维护端对应的表</span><br><span class="line">    private List&lt;Authority&gt; authorityList;</span><br><span class="line"></span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getPassword() &#123;</span><br><span class="line">        return password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPassword(String password) &#123;</span><br><span class="line">        this.password = password;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public List&lt;Authority&gt; getAuthorityList() &#123;</span><br><span class="line">        return authorityList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAuthorityList(List&lt;Authority&gt; authorityList)     &#123;</span><br><span class="line">        this.authorityList = authorityList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="个性化用户认证逻辑"><a href="#个性化用户认证逻辑" class="headerlink" title="个性化用户认证逻辑"></a>个性化用户认证逻辑</h2><p>自定义登录页面<br>先写一个简单的登录页面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;登录页面&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h2&gt;自定义登录页面&lt;/h2&gt;</span><br><span class="line">    &lt;form action=&quot;/user/login&quot;  method=&quot;post&quot;&gt;</span><br><span class="line">        &lt;table&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td&gt;用户名：&lt;/td&gt;</span><br><span class="line">                &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td&gt;密码：&lt;/td&gt;</span><br><span class="line">                &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td colspan=&quot;2&quot;&gt;&lt;button type=&quot;submit&quot;&gt;登录&lt;/button&gt;&lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">        &lt;/table&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>这样，每当访问被保护的接口的时候，就会调转到login.html页面</p><h2 id="自定义处理登录成功-失败"><a href="#自定义处理登录成功-失败" class="headerlink" title="自定义处理登录成功/失败"></a>自定义处理登录成功/失败</h2><p>Spring Security中的两个接口AuthenticationSuccessHandler和AuthenticationFailureHandler。可用于认证结果的处理。可以实现这个接口，并进行相应的配置就可以了。 当然框架是有默认的实现类的，可以继承这个实现类再来自定义自己的业务</p><p>可以通过response返回一个JSON字符串回去。<br>这个方法中的第三个参数Authentication，它里面包含了登录后的用户信息（UserDetails），Session的信息，登录信息等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Component(&quot;myAuthenctiationFailureHandler&quot;)</span><br><span class="line">public class MyAuthenctiationFailureHandler extends SimpleUrlAuthenticationFailureHandler &#123;</span><br><span class="line"></span><br><span class="line">    private Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response,</span><br><span class="line">                                        AuthenticationException exception) throws IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">        logger.info(&quot;登录失败&quot;);</span><br><span class="line"></span><br><span class="line">        response.setStatus(HttpStatus.INTERNAL_SERVER_ERROR.value());</span><br><span class="line">        response.setContentType(&quot;application/json;charset=UTF-8&quot;);</span><br><span class="line">        response.getWriter().write(objectMapper.writeValueAsString(new BaseResponse(exception.getMessage())));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同样的方式,可以配置失败处理器,通过successHandler和failureHandler方法注入处理器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.successHandler(myAuthenticationSuccessHandler) // 自定义登录成功处理 </span><br><span class="line">.failureHandler(myAuthenticationFailureHandler) // 自定义登录失败处理</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> SpringSecurity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Yii操作Mysql</title>
      <link href="/2019/01/29/Yii%E6%93%8D%E4%BD%9CMysql/"/>
      <url>/2019/01/29/Yii%E6%93%8D%E4%BD%9CMysql/</url>
      
        <content type="html"><![CDATA[<h2 id="创建Model对象"><a href="#创建Model对象" class="headerlink" title="创建Model对象"></a>创建Model对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Myguest extends CActiveRecord &#123;</span><br><span class="line">    //返回当前模型对象的静态方法</span><br><span class="line">    public static function mmodel($className = __CLASS__)&#123;</span><br><span class="line">        return parent::model($className);</span><br><span class="line">    &#125;</span><br><span class="line">    //返回当前模型的名字的方法</span><br><span class="line">    public function tableName()&#123;</span><br><span class="line">        return &quot;test_myguest&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编辑数据库配置"><a href="#编辑数据库配置" class="headerlink" title="编辑数据库配置"></a>编辑数据库配置</h2><p>编辑main.php文件中的’db’数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&apos;db&apos;=&gt;array(</span><br><span class="line">    &apos;connectionString&apos;=&gt;&apos;mysql:host=localhost;dbname=phpdb&apos;,</span><br><span class="line">    &apos;emulatePrepare&apos;=&gt;true,</span><br><span class="line">    &apos;username&apos;=&gt;&apos;root&apos;,</span><br><span class="line">    &apos;password&apos;=&gt;&apos;123&apos;,</span><br><span class="line">    &apos;charset&apos;=&gt;&apos;utf8&apos;,</span><br><span class="line">    //把数据表的前缀设置好</span><br><span class="line">    //&apos;tablePrefix&apos;=&gt;&apos;test_&apos;,</span><br><span class="line">),</span><br></pre></td></tr></table></figure></p><h2 id="创建controller"><a href="#创建controller" class="headerlink" title="创建controller"></a>创建controller</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class UserController extends Controller &#123;</span><br><span class="line">    function actionLogin()&#123;</span><br><span class="line">        $this-&gt;renderPartial(&quot;login&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>renderPartial方法会跳转到views/user/login.php</p><h2 id="Yii操作数据库"><a href="#Yii操作数据库" class="headerlink" title="Yii操作数据库"></a>Yii操作数据库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  //执行增加更新或者删除操作,</span><br><span class="line">$sql = &quot;update test_myguest set firstname = &apos;林&apos; where id =23&quot;;</span><br><span class="line"> $res = Yii::app()-&gt;db-&gt;createCommand($sql)-&gt;execute();</span><br></pre></td></tr></table></figure><h3 id="更新"><a href="#更新" class="headerlink" title="更新:"></a>更新:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$res = Yii::app()-&gt;db-&gt;createCommand()-&gt;update(</span><br><span class="line">//表名</span><br><span class="line">&apos;test_myguest&apos;,</span><br><span class="line">//操作</span><br><span class="line">array(&apos;firstname&apos;=&gt;&quot;改名字辣&quot;),</span><br><span class="line">//条件</span><br><span class="line">&apos;id=:id&apos;,array(&apos;:id&apos;=&gt;15)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除:"></a>删除:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$res = Yii::app()-&gt;db-&gt;createCommand()-&gt;delete(</span><br><span class="line">&apos;test_myguest&apos;,</span><br><span class="line">&apos;id=:id&apos;,array(&apos;:id&apos;=&gt;12)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$res = Yii::app()-&gt;getDb()-&gt;createCommand()-&gt;insert(</span><br><span class="line">&apos;test_myguest&apos;,</span><br><span class="line">array(&apos;firstname&apos;=&gt;&apos;陈&apos;,</span><br><span class="line">&apos;lastname&apos;=&gt;&apos;大伟&apos;)</span><br><span class="line">);</span><br><span class="line">var_dump($res);</span><br></pre></td></tr></table></figure><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">method1:</span><br><span class="line"></span><br><span class="line">        //这是一个list</span><br><span class="line">        $res = Yii::app()-&gt;getDb()-&gt;createCommand()</span><br><span class="line">        -&gt;select(&apos;id,firstname,lastname&apos;)</span><br><span class="line">        -&gt;from(&apos;test_myguest&apos;)</span><br><span class="line">        -&gt;where(&apos;id&gt;1&apos;)</span><br><span class="line">        -&gt;queryAll();</span><br><span class="line">        echo $res[3][&apos;lastname&apos;];</span><br></pre></td></tr></table></figure><p>返回一个数组,第一个参数是第几列,第二个参数是属性,<strong>不是对象</strong>,不能使用-&gt;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">method2:</span><br><span class="line"></span><br><span class="line">$obj = CustomGame::model()-&gt;find(&quot;game_id=:gi&quot;,array(&apos;gi&apos;=&gt;163804000));</span><br><span class="line">//上面的语句返回一个对象</span><br><span class="line"></span><br><span class="line">$user_id = $obj-&gt;user_id;</span><br><span class="line">//取属性</span><br></pre></td></tr></table></figure></p><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询:"></a>分页查询:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$res = Yii::app()-&gt;getDb()-&gt;createCommand()</span><br><span class="line">        -&gt;select(&apos;id,firstname,lastname&apos;)</span><br><span class="line">        -&gt;from(&apos;test_myguest&apos;)</span><br><span class="line">        //            -&gt;where(&apos;id=:id&apos;,array(&quot;:id&quot;=&gt;1))</span><br><span class="line">        -&gt;offset(10)</span><br><span class="line">        -&gt;limit(10)</span><br><span class="line">        -&gt;queryAll();</span><br><span class="line">//        var_dump($res[2]);    $res[2]是第二条数据</span><br><span class="line">//         echo $res[2][&apos;lastname&apos;];  第二条数据的lastname属性</span><br><span class="line">        var_dump($res);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Yii </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJs domain的作用</title>
      <link href="/2019/01/29/NodeJs-domain%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
      <url>/2019/01/29/NodeJs-domain%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>Domain 可以简化异步代码的异常处理，可以捕捉处理try catch无法捕捉的异常。</p><p>引入 Domain 模块 语法格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var domain = require(&quot;domain&quot;)</span><br></pre></td></tr></table></figure></p><p>把处理多个不同的IO的操作作为一个组。注册事件和回调到domain，当发生一个错误事件或抛出一个错误时，domain对象会被通知，不会丢失上下文环境，也<strong>不导致程序错误立即退出，与process.on(‘uncaughtException’)不同。</strong></p><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">domain.run(function)</span><br><span class="line">//在域的上下文运行提供的函数，隐式的绑定了所有的事件分发器，计时器和底层请求。</span><br><span class="line"></span><br><span class="line">domain.add(emitter)</span><br><span class="line">//显式的增加事件</span><br><span class="line">domain.remove(emitter)</span><br><span class="line">//删除事件</span><br><span class="line"></span><br><span class="line">domain.create()</span><br><span class="line">//返回一个domain对象。</span><br><span class="line"></span><br><span class="line">domain.exit()</span><br><span class="line">//退出当前的domain，切换到不同的链的异步调用的上下文中。对应domain.enter()。</span><br><span class="line"></span><br><span class="line">domain.dispose()</span><br><span class="line">//释放一个domain对象，让node进程回收这部分资源。</span><br></pre></td></tr></table></figure><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">var EventEmitter = require(&quot;events&quot;).EventEmitter;</span><br><span class="line">var domain = require(&quot;domain&quot;);</span><br><span class="line"></span><br><span class="line">var emitter1 = new EventEmitter();</span><br><span class="line"></span><br><span class="line">// 创建域</span><br><span class="line">var domain1 = domain.create();</span><br><span class="line"></span><br><span class="line">domain1.on(&apos;error&apos;, function(err)&#123;</span><br><span class="line">   console.log(&quot;domain1 处理这个错误 (&quot;+err.message+&quot;)&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 显式绑定</span><br><span class="line">domain1.add(emitter1);</span><br><span class="line"></span><br><span class="line">emitter1.on(&apos;error&apos;,function(err)&#123;</span><br><span class="line">   console.log(&quot;监听器处理此错误 (&quot;+err.message+&quot;)&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">emitter1.emit(&apos;error&apos;,new Error(&apos;通过监听器来处理&apos;));</span><br><span class="line"></span><br><span class="line">emitter1.removeAllListeners(&apos;error&apos;);</span><br><span class="line"></span><br><span class="line">emitter1.emit(&apos;error&apos;,new Error(&apos;通过 domain1 处理&apos;));</span><br><span class="line"></span><br><span class="line">var domain2 = domain.create();</span><br><span class="line"></span><br><span class="line">domain2.on(&apos;error&apos;, function(err)&#123;</span><br><span class="line">   console.log(&quot;domain2 处理这个错误 (&quot;+err.message+&quot;)&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 隐式绑定</span><br><span class="line">domain2.run(function()&#123;</span><br><span class="line">   var emitter2 = new EventEmitter();</span><br><span class="line">   emitter2.emit(&apos;error&apos;,new Error(&apos;通过 domain2 处理&apos;));   </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">domain1.remove(emitter1);</span><br><span class="line">emitter1.emit(&apos;error&apos;, new Error(&apos;转换为异常，系统将崩溃!&apos;));</span><br></pre></td></tr></table></figure><p><strong>Domain的关键就在于错误会传到domain而不会引发系统崩溃</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> NodeJs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJs path的join和resolve的区别</title>
      <link href="/2019/01/29/NodeJs-path%E7%9A%84join%E5%92%8Cresolve%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/01/29/NodeJs-path%E7%9A%84join%E5%92%8Cresolve%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="连接路径：path-join-path1-path2-…"><a href="#连接路径：path-join-path1-path2-…" class="headerlink" title="连接路径：path.join([path1][, path2][, …])"></a>连接路径：path.join([path1][, path2][, …])</h2><a id="more"></a><p>path.join()方法可以连接任意多个路径字符串。要连接的多个路径可做为参数传入。<br>path.join()方法在接边路径的同时也会对路径进行规范化。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var path = require(&apos;path&apos;); </span><br><span class="line">//合法的字符串连接 </span><br><span class="line">path.join(&apos;/foo&apos;, &apos;bar&apos;, &apos;baz/asdf&apos;, &apos;quux&apos;, &apos;..&apos;) </span><br><span class="line">// 连接后 </span><br><span class="line">&apos;/foo/bar/baz/asdf&apos; </span><br><span class="line"></span><br><span class="line">//不合法的字符串将抛出异常 </span><br><span class="line">path.join(&apos;foo&apos;, &#123;&#125;, &apos;bar&apos;) </span><br><span class="line">// 抛出的异常 TypeError: Arguments to path.join must be strings&apos;</span><br></pre></td></tr></table></figure></p><h2 id="路径解析：path-resolve-from-…-to"><a href="#路径解析：path-resolve-from-…-to" class="headerlink" title="路径解析：path.resolve([from …], to)"></a>路径解析：path.resolve([from …], to)</h2><p>path.resolve()方法可以将多个路径解析为一个规范化的绝对路径。其处理方式类似于对这些路径逐一进行cd操作，与cd操作不同的是，这引起路径可以是文件，并且可不必实际存在（resolve()方法不会利用底层的文件系统判断路径是否存在，而只是进行路径字符串操作）。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path.resolve(&apos;foo/bar&apos;, &apos;/tmp/file/&apos;, &apos;..&apos;, &apos;a/../subfile&apos;)</span><br></pre></td></tr></table></figure></p><p>相当于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd foo/bar</span><br><span class="line">cd /tmp/file/</span><br><span class="line">cd ..</span><br><span class="line">cd a/../subfile</span><br><span class="line">pwd</span><br></pre></td></tr></table></figure></p><p>例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">path.resolve(&apos;/foo/bar&apos;, &apos;./baz&apos;) </span><br><span class="line">// 输出结果为 </span><br><span class="line">&apos;/foo/bar/baz&apos; </span><br><span class="line">path.resolve(&apos;/foo/bar&apos;, &apos;/tmp/file/&apos;) </span><br><span class="line">// 输出结果为 </span><br><span class="line">&apos;/tmp/file&apos; </span><br><span class="line"></span><br><span class="line">path.resolve(&apos;wwwroot&apos;, &apos;static_files/png/&apos;, &apos;../gif/image.gif&apos;) </span><br><span class="line">// 当前的工作路径是 /home/itbilu/node，则输出结果为 </span><br><span class="line">&apos;/home/itbilu/node/wwwroot/static_files/gif/image.gif&apos;</span><br></pre></td></tr></table></figure></p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;); </span><br><span class="line">let myPath = path.join(__dirname,&apos;/img/so&apos;); </span><br><span class="line">let myPath2 = path.join(__dirname,&apos;./img/so&apos;); </span><br><span class="line">let myPath3 = path.resolve(__dirname,&apos;/img/so&apos;); </span><br><span class="line">let myPath4 = path.resolve(__dirname,&apos;./img/so&apos;); </span><br><span class="line">console.log(__dirname); //D:\myProgram\test </span><br><span class="line">console.log(myPath); //D:\myProgram\test\img\so </span><br><span class="line">console.log(myPath2); //D:\myProgram\test\img\so </span><br><span class="line">console.log(myPath3); //D:\img\so&lt;br&gt; </span><br><span class="line">console.log(myPath4); //D:\myProgram\test\img\so</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> NodeJs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装ElasticSearch_head插件</title>
      <link href="/2019/01/28/%E5%AE%89%E8%A3%85ElasticSearch_head%E6%8F%92%E4%BB%B6/"/>
      <url>/2019/01/28/%E5%AE%89%E8%A3%85ElasticSearch_head%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>ElasticSearch安装Head插件</p><h2 id="安装ElasticSearch"><a href="#安装ElasticSearch" class="headerlink" title="安装ElasticSearch"></a>安装ElasticSearch</h2><h2 id="安装node"><a href="#安装node" class="headerlink" title="安装node"></a>安装node</h2><h2 id="安装grunt"><a href="#安装grunt" class="headerlink" title="安装grunt"></a>安装grunt</h2><p>grunt是一个很方便的构建工具，可以进行打包压缩、测试、执行等等的工作，5.0里的head插件就是通过grunt启动的。因此需要安装grunt：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g grunt-cli</span><br></pre></td></tr></table></figure></p><p>-g代表全局安装。安装路径为C:\Users\yourname\AppData\Roaming\npm，并且自动加入PATH变量。安装完成后检查一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grunt -version</span><br></pre></td></tr></table></figure></p><h2 id="下载elastichsearch-head插件"><a href="#下载elastichsearch-head插件" class="headerlink" title="下载elastichsearch-head插件"></a>下载elastichsearch-head插件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git://github.com/mobz/elasticsearch-head.git</span><br></pre></td></tr></table></figure><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><h3 id="head源码"><a href="#head源码" class="headerlink" title="head源码"></a>head源码</h3><p>由于head的代码还是2.6版本的，直接执行有很多限制，比如无法跨机器访问。因此需要用户修改两个地方：<br>目录：head/Gruntfile.js：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">connect: &#123;</span><br><span class="line">    server: &#123;</span><br><span class="line">        options: &#123;</span><br><span class="line">            port: 9100,</span><br><span class="line">            hostname: &apos;*&apos;,</span><br><span class="line">            base: &apos;.&apos;,</span><br><span class="line">            keepalive: true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>增加hostname属性，设置为*</p><h3 id="修改链接地址"><a href="#修改链接地址" class="headerlink" title="修改链接地址"></a>修改链接地址</h3><p>目录：head/_site/app.js<br>修改head的连接地址:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.base_uri = this.config.base_uri || this.prefs.get(&quot;app-base_uri&quot;) || &quot;http://localhost:9200&quot;;</span><br></pre></td></tr></table></figure></p><p>把localhost修改成你es的服务器地址，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.base_uri = this.config.base_uri || this.prefs.get(&quot;app-base_uri&quot;) || &quot;http://10.10.10.10:9200&quot;;</span><br></pre></td></tr></table></figure></p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><h3 id="修改elasticsearch的参数"><a href="#修改elasticsearch的参数" class="headerlink" title="修改elasticsearch的参数"></a>修改elasticsearch的参数</h3><p>修改一下es使用的参数。编辑config/elasticsearch.yml：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 换个集群的名字，免得跟别人的集群混在一起</span><br><span class="line">cluster.name: es-5.0-test</span><br><span class="line"></span><br><span class="line"># 换个节点名字</span><br><span class="line">node.name: node-101</span><br><span class="line"></span><br><span class="line"># 修改一下ES的监听地址，这样别的机器也可以访问</span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line"></span><br><span class="line"># 默认的就好</span><br><span class="line">http.port: 9200</span><br><span class="line"></span><br><span class="line"># 增加新的参数，这样head插件可以访问es</span><br><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br></pre></td></tr></table></figure></p><p>设置参数的时候:后面要有空格！</p><h3 id="开启ES-5-6-0："><a href="#开启ES-5-6-0：" class="headerlink" title="开启ES-5.6.0："></a>开启ES-5.6.0：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G:\background\elasticsearch-5.6.0\bin\elasticsearch.bat</span><br></pre></td></tr></table></figure><h3 id="在head源码目录中，执行npm-install-下载的包："><a href="#在head源码目录中，执行npm-install-下载的包：" class="headerlink" title="在head源码目录中，执行npm install 下载的包："></a>在head源码目录中，执行npm install 下载的包：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><h3 id="在head源代码目录下启动nodejs："><a href="#在head源代码目录下启动nodejs：" class="headerlink" title="在head源代码目录下启动nodejs："></a>在head源代码目录下启动nodejs：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grunt server</span><br></pre></td></tr></table></figure><h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:9100</span><br></pre></td></tr></table></figure><img src="/2019/01/28/安装ElasticSearch_head插件/访问成功.jpg">]]></content>
      
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot整合ElasticSearch</title>
      <link href="/2019/01/27/SpringBoot%E6%95%B4%E5%90%88ElasticSearch/"/>
      <url>/2019/01/27/SpringBoot%E6%95%B4%E5%90%88ElasticSearch/</url>
      
        <content type="html"><![CDATA[<p>SpringBoot整合ElasticSearch</p><h2 id="引入Maven依赖"><a href="#引入Maven依赖" class="headerlink" title="引入Maven依赖"></a>引入Maven依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.0.2.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;net.java.dev.jna&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;jna&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;4.3.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="配置文件增加ElasticSearch相关信息"><a href="#配置文件增加ElasticSearch相关信息" class="headerlink" title="配置文件增加ElasticSearch相关信息"></a>配置文件增加ElasticSearch相关信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">##Elastic服务地址</span><br><span class="line">spring.data.elasticsearch.cluster-nodes=localhost:9300</span><br><span class="line">#设置连接超时时间</span><br><span class="line">spring.data.elasticsearch.properties.transport.tcp.connect_timeout=120s</span><br></pre></td></tr></table></figure><h2 id="新建Domain类"><a href="#新建Domain类" class="headerlink" title="新建Domain类"></a>新建Domain类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">import java.io.Serializable;</span><br><span class="line">@Document(indexName = &quot;blog&quot;, type=&quot;blog&quot;)</span><br><span class="line">public class EsBlog implements Serializable &#123;</span><br><span class="line">    private static final long seriaVersionUID = 1L;</span><br><span class="line">    @Id</span><br><span class="line">    private String id;</span><br><span class="line">    private String title;</span><br><span class="line">    private String summary;</span><br><span class="line">    private String content;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return String.format(</span><br><span class="line">                &quot;EsBlog[id=&apos;%s&apos;,title=&apos;%s&apos;,summary=&apos;%s&apos;,content=&apos;%s&apos;]&quot;</span><br><span class="line">                ,id,title,summary,content</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected EsBlog() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public EsBlog(String title,String summary,String content)&#123;</span><br><span class="line">       this.title = title;</span><br><span class="line">       this.summary = summary;</span><br><span class="line">       this.content = content;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public String getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(String id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getTitle() &#123;</span><br><span class="line">        return title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTitle(String title) &#123;</span><br><span class="line">        this.title = title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getSummary() &#123;</span><br><span class="line">        return summary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSummary(String summary) &#123;</span><br><span class="line">        this.summary = summary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getContent() &#123;</span><br><span class="line">        return content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setContent(String content) &#123;</span><br><span class="line">        this.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置Jpa的ElasticSeach查询接口"><a href="#配置Jpa的ElasticSeach查询接口" class="headerlink" title="配置Jpa的ElasticSeach查询接口"></a>配置Jpa的ElasticSeach查询接口</h2><p>新建EsBlogRepository接口,继承<strong>ElasticsearchRepository&lt;EsBlog,String&gt;</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//分页查询博客,去重功能</span><br><span class="line">Page&lt;EsBlog&gt; findDistinctEsBlogByTitleContainingOrSummaryContainingOrContentContaining(String title, String summary, String content, Pageable pageable);</span><br></pre></td></tr></table></figure></p><p>Distinct:去重<br>containing:包含内容即可返回</p><h2 id="编写测试类"><a href="#编写测试类" class="headerlink" title="编写测试类"></a>编写测试类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest(classes= Application.class)</span><br><span class="line">public class EsBlogRepositoryTest&#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private EsBlogRepository esBlogRepository;</span><br><span class="line">    //Before注解下的方法会在测试方法前执行</span><br><span class="line">    @Before</span><br><span class="line">    public void initRRepositoryData()&#123;</span><br><span class="line">        //清除所有数据</span><br><span class="line">        esBlogRepository.deleteAll();</span><br><span class="line">        esBlogRepository.save(new EsBlog(&quot;登鹳雀楼&quot;,&quot;王之涣的登鹳雀楼&quot;,&quot;白日依山尽，黄河入海流。欲穷千里目，更上一层楼。&quot;));</span><br><span class="line">        esBlogRepository.save(new EsBlog(&quot;相思&quot;,&quot;王维的相思&quot;,&quot;红豆生南国，春来发几枝。愿君多采撷，此物最相思。&quot;));</span><br><span class="line">        esBlogRepository.save(new EsBlog(&quot;静夜思&quot;,&quot;李白的静夜思&quot;,&quot;床前明月光，疑似地上霜，举头望明月，低头思故乡。&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">    @Test</span><br><span class="line">    public void FindDistinctEsBlogByTitleContainingOrSummaryContainingOrContentContaining()&#123;</span><br><span class="line">        Pageable pageable = new PageRequest(0,20);</span><br><span class="line">        String title = &quot;思&quot;;</span><br><span class="line">        String summary = &quot;相思&quot;;</span><br><span class="line">        String content = &quot;相思&quot;;</span><br><span class="line">        Page&lt;EsBlog&gt; page = esBlogRepository.findDistinctEsBlogByTitleContainingOrSummaryContainingOrContentContaining(title,summary,content,pageable);</span><br><span class="line">        System.out.println(&quot;------------------------------------------------------&quot;);</span><br><span class="line">        for (EsBlog blog : page.getContent())&#123;</span><br><span class="line">            System.out.println(blog.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;end................................................................&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果:"></a>运行结果:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">------------------------------------------------------</span><br><span class="line">EsBlog[id=&apos;AWiOBGQ6G1YcO1hyfAG2&apos;,title=&apos;静夜思&apos;,summary=&apos;李白的静夜思&apos;,content=&apos;床前明月光，疑似地上霜，举头望明月，低头思故乡。&apos;]</span><br><span class="line">EsBlog[id=&apos;AWiOBGPcG1YcO1hyfAG1&apos;,title=&apos;相思&apos;,summary=&apos;王维的相思&apos;,content=&apos;红豆生南国，春来发几枝。愿君多采撷，此物最相思。&apos;]</span><br><span class="line">end................................................................</span><br></pre></td></tr></table></figure><h2 id="浏览器查看Elastic"><a href="#浏览器查看Elastic" class="headerlink" title="浏览器查看Elastic"></a>浏览器查看Elastic</h2><p>插入后可以通过<a href="http://localhost:9200/blog/blog/_search?pretty=true" target="_blank" rel="noopener">http://localhost:9200/blog/blog/_search?pretty=true</a> 在浏览器中查看数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;took&quot; : 1,</span><br><span class="line">  &quot;timed_out&quot; : false,</span><br><span class="line">  &quot;_shards&quot; : &#123;</span><br><span class="line">    &quot;total&quot; : 5,</span><br><span class="line">    &quot;successful&quot; : 5,</span><br><span class="line">    &quot;skipped&quot; : 0,</span><br><span class="line">    &quot;failed&quot; : 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;hits&quot; : &#123;</span><br><span class="line">    &quot;total&quot; : 3,</span><br><span class="line">    &quot;max_score&quot; : 1.0,</span><br><span class="line">    &quot;hits&quot; : [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;_index&quot; : &quot;blog&quot;,</span><br><span class="line">        &quot;_type&quot; : &quot;blog&quot;,</span><br><span class="line">        &quot;_id&quot; : &quot;AWiOBGQ6G1YcO1hyfAG2&quot;,</span><br><span class="line">        &quot;_score&quot; : 1.0,</span><br><span class="line">        &quot;_source&quot; : &#123;</span><br><span class="line">          &quot;id&quot; : null,</span><br><span class="line">          &quot;title&quot; : &quot;静夜思&quot;,</span><br><span class="line">          &quot;summary&quot; : &quot;李白的静夜思&quot;,</span><br><span class="line">          &quot;content&quot; : &quot;床前明月光，疑似地上霜，举头望明月，低头思故乡&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;_index&quot; : &quot;blog&quot;,</span><br><span class="line">        &quot;_type&quot; : &quot;blog&quot;,</span><br><span class="line">        &quot;_id&quot; : &quot;AWiOBGL_G1YcO1hyfAG0&quot;,</span><br><span class="line">        &quot;_score&quot; : 1.0,</span><br><span class="line">        &quot;_source&quot; : &#123;</span><br><span class="line">          &quot;id&quot; : null,</span><br><span class="line">          &quot;title&quot; : &quot;登鹳雀楼&quot;,</span><br><span class="line">          &quot;summary&quot; : &quot;王之涣的登鹳雀楼&quot;,</span><br><span class="line">          &quot;content&quot; : &quot;白日依山尽，黄河入海流。欲穷千里目，更上一层楼。&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;_index&quot; : &quot;blog&quot;,</span><br><span class="line">        &quot;_type&quot; : &quot;blog&quot;,</span><br><span class="line">        &quot;_id&quot; : &quot;AWiOBGPcG1YcO1hyfAG1&quot;,</span><br><span class="line">        &quot;_score&quot; : 1.0,</span><br><span class="line">        &quot;_source&quot; : &#123;</span><br><span class="line">          &quot;id&quot; : null,</span><br><span class="line">          &quot;title&quot; : &quot;相思&quot;,</span><br><span class="line">          &quot;summary&quot; : &quot;王维的相思&quot;,</span><br><span class="line">          &quot;content&quot; : &quot;红豆生南国，春来发几枝。愿君多采撷，此物最相思。&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="完成Controller"><a href="#完成Controller" class="headerlink" title="完成Controller"></a>完成Controller</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/blogs&quot;)</span><br><span class="line">public class BlogController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private EsBlogRepository esBlogRepository;</span><br><span class="line">    @GetMapping</span><br><span class="line">    public List&lt;EsBlog&gt; list(@RequestParam(value=&quot;title&quot;) String title,</span><br><span class="line">                             @RequestParam(value=&quot;summary&quot;) String summary,</span><br><span class="line">                            @RequestParam(value=&quot;content&quot;) String content,</span><br><span class="line">                            @RequestParam(value=&quot;pageIndex&quot;,defaultValue = &quot;0&quot;) int pageIndex,</span><br><span class="line">                             @RequestParam(value=&quot;pageSize&quot;,defaultValue = &quot;10&quot;) int pageSize</span><br><span class="line">                            )&#123;</span><br><span class="line">        Pageable pageable = new PageRequest(pageIndex,pageSize);</span><br><span class="line">        Page&lt;EsBlog&gt; page = esBlogRepository.findDistinctEsBlogByTitleContainingOrSummaryContainingOrContentContaining(title,summary,content,pageable);</span><br><span class="line">        return page.getContent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="浏览器访问"><a href="#浏览器访问" class="headerlink" title="浏览器访问"></a>浏览器访问</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/blogs?title=思summary=相思&amp;content=相思</span><br></pre></td></tr></table></figure><img src="/2019/01/27/SpringBoot整合ElasticSearch/浏览器访问.jpg">]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP_字符串</title>
      <link href="/2019/01/26/PHP-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2019/01/26/PHP-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="双引号和单引号的区别"><a href="#双引号和单引号的区别" class="headerlink" title="双引号和单引号的区别:"></a>双引号和单引号的区别:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * 双引号可以解析变量</span><br><span class="line"> * 单引号不解析变量</span><br><span class="line"> * 双引号解析所有的转义符号</span><br><span class="line"> * 单引号只解析两个转义符  : \\  \&apos;</span><br><span class="line"> */</span><br><span class="line">$username = &apos;linjiayan&apos;;</span><br><span class="line">echo &quot;$username&quot;;</span><br><span class="line">echo &quot;&lt;br&gt;&quot;;</span><br><span class="line">echo &apos;$username&apos;;</span><br><span class="line">echo &quot;&lt;br&gt;&quot;;</span><br></pre></td></tr></table></figure><h2 id="花括号的作用"><a href="#花括号的作用" class="headerlink" title="花括号的作用"></a>花括号的作用</h2><h3 id="作用一"><a href="#作用一" class="headerlink" title="作用一"></a>作用一</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$username = &apos;king&apos;;</span><br><span class="line">echo $username.&apos;&lt;br&gt;&apos;;</span><br><span class="line">echo &apos;&lt;br&gt;&apos;;</span><br><span class="line">echo &quot;我的名字为$username&quot;;</span><br><span class="line">echo &quot;&lt;br&gt;&quot;;</span><br><span class="line">echo &quot;我的名字为$username&quot;.&quot;s&quot;;</span><br><span class="line">echo &quot;&lt;br&gt;&quot;;</span><br><span class="line">echo &quot;我的名字为&#123;$username&#125;s&quot;;</span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我的名字为king</span><br><span class="line">我的名字为kings</span><br><span class="line">我的名字为kings</span><br></pre></td></tr></table></figure></p><h3 id="作用二"><a href="#作用二" class="headerlink" title="作用二"></a>作用二</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//通过&#123;&#125;可以对字符串中的字符做增删改查操作</span><br><span class="line">$str=&apos;abcdef&apos;;</span><br><span class="line">//获取</span><br><span class="line">echo $str&#123;0&#125;;</span><br><span class="line">echo &quot;&lt;br&gt;&quot;;</span><br><span class="line"></span><br><span class="line">//替换,只能用一个字符替换一个字符</span><br><span class="line">$str&#123;1&#125; = &apos;m&apos;;</span><br><span class="line">echo $str;</span><br><span class="line">echo &quot;&lt;br&gt;&quot;;</span><br><span class="line">//即使是一个字符串,也只取一个</span><br><span class="line">$str&#123;4&#125; = &apos;hello&apos;;</span><br><span class="line">echo $str;</span><br><span class="line">echo &quot;&lt;br&gt;&quot;;</span><br><span class="line">//用空字符替换</span><br><span class="line">$str = &apos;imooc&apos;;</span><br><span class="line">$str&#123;1&#125; = &apos;&apos;;</span><br><span class="line">echo $str;</span><br><span class="line">echo &quot;&lt;br&gt;&quot;;</span><br><span class="line">//长度还是原来的,只是用空字符串代替</span><br><span class="line">var_dump($str);</span><br><span class="line">echo &quot;&lt;br&gt;&quot;;</span><br><span class="line"></span><br><span class="line">$str = &apos;abc&apos;;</span><br><span class="line">$str&#123;30&#125;=&apos;d&apos;;</span><br><span class="line">echo $str;</span><br><span class="line"></span><br><span class="line">//获取字符串中随机的一个字符</span><br><span class="line">$string = &apos;qwertyuipasdfghj&apos;;</span><br><span class="line">echo $string&#123;mt_rand(0,strlen($string)-1)&#125;;</span><br></pre></td></tr></table></figure><h2 id="heredoc和nowdoc"><a href="#heredoc和nowdoc" class="headerlink" title="heredoc和nowdoc"></a>heredoc和nowdoc</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">//heredoc 相当于双引号的作用</span><br><span class="line">$str = &apos;king&apos;;</span><br><span class="line">$table = &quot;&lt;table border = &apos;1&apos; width = \&quot;80%\&quot;&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">    &lt;td&gt;编号&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;用户名&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;描述&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;   </span><br><span class="line">&lt;tr&gt;</span><br><span class="line">    &lt;td&gt;1&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;king&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;He Said \&quot; I&apos;m Fine \&quot; Thank You&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;   </span><br><span class="line"></span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">echo $table;</span><br><span class="line"></span><br><span class="line">$table =&lt;&lt;&lt;EOF</span><br><span class="line">    &lt;table border = &apos;1&apos; width = &quot;80%&quot;&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">          &lt;td&gt;编号&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;用户名&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;描述&lt;/td&gt;  </span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;1&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;king&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;He Said &quot;I&apos;m Fine &quot; Thank You&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;   </span><br><span class="line">    &lt;/table&gt;</span><br><span class="line">EOF;</span><br><span class="line">echo $table;</span><br><span class="line">echo &quot;&lt;br&gt;&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$username = &quot;linjiayan&quot;;</span><br><span class="line">//nowdoc语法结构,相当于单引号的作用</span><br><span class="line">$str =&lt;&lt;&lt;&apos;EOD&apos;</span><br><span class="line">    hello kong &lt;br/&gt;</span><br><span class="line">    &#123;$username&#125;</span><br><span class="line">    &lt;br/&gt;</span><br><span class="line">    a/nb/rcdef</span><br><span class="line">EOD;</span><br><span class="line"></span><br><span class="line">echo $str;</span><br></pre></td></tr></table></figure><h2 id="字符串转换的规律"><a href="#字符串转换的规律" class="headerlink" title="字符串转换的规律"></a>字符串转换的规律</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by PhpStorm.</span><br><span class="line"> * User: LinJiayan</span><br><span class="line"> * Date: 2019/1/26</span><br><span class="line"> * Time: 14:01</span><br><span class="line"> */</span><br><span class="line">//字符串转换成其他类型</span><br><span class="line"></span><br><span class="line">//取合法数字,如果不是合法数字开始则转换成0</span><br><span class="line">echo 1+&apos;3king&apos;;</span><br><span class="line">echo &quot;&lt;br&gt;&quot;;</span><br><span class="line">echo 1.2+&apos;4abc&apos;;</span><br><span class="line">echo &quot;&lt;br&gt;&quot;;</span><br><span class="line">echo 3+&apos;2e2&apos;;</span><br><span class="line">echo &quot;&lt;br&gt;&quot;;</span><br><span class="line">echo 2+&apos;true&apos;;</span><br><span class="line">echo &quot;&lt;br&gt;&quot;;</span><br><span class="line">//字符串转换为布尔型的规律,空字符串或者是字符串&apos;0&apos;,&quot;0&quot;----&gt;false</span><br><span class="line">$res = &apos;&apos;;</span><br><span class="line">$res = &quot; &quot;;//有内容则是true</span><br><span class="line">$res = &apos;0&apos;;</span><br><span class="line">$res = &apos;0.0&apos;;</span><br><span class="line">$res = &apos;false&apos;;</span><br><span class="line">$res = 0 ;</span><br><span class="line">$res = 0.0;</span><br><span class="line">$res = null;</span><br><span class="line">$res = array();</span><br><span class="line">if($res)&#123;</span><br><span class="line">    echo &quot;我是真的&lt;br&gt;&quot;;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    echo &quot;我是假的&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch笔记</title>
      <link href="/2019/01/25/ElasticSearch%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/01/25/ElasticSearch%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>全文搜索属于最常见的需求，开源的 Elasticsearch是目前全文搜索引擎的首选。<br>Elastic 的底层是开源库Lucene。但是，无法直接用Lucene，必须写代码去调用它的接口。<strong>Elastic 是 Lucene 的封装，提供了 REST API 的操作接口，开箱即用。</strong></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Elastic 需要 Java 8 环境。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.5.1.zip</span><br><span class="line">$ unzip elasticsearch-5.5.1.zip</span><br><span class="line">$ mv elasticsearch-5.5.1 destination(目标文件夹)</span><br><span class="line">$ cd elasticsearch-5.5.1/</span><br></pre></td></tr></table></figure></p><p>不要把es目录放在 ~目录下,这是root用户的用户目录,后面要切换到自定义用户</p><p>下载后在 elasticsearch  根目录下启动。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elasticsearch-2.2.0]# ./bin/elasticsearch</span><br></pre></td></tr></table></figure></p><p>启动时报java内存不足的解决方法</p><blockquote><p>解决办法：<br>1、进入/home/elasticsearch-5.3.1/config<br>2、修改jvm.options 的配置 vim jvm.options<br>3、修改为-Xms512M<br>-Xmx512M </p></blockquote><p>解决之后,继续报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.RuntimeException: don&apos;t run elasticsearch as root.</span><br><span class="line">        at org.elasticsearch.bootstrap.Bootstrap.initializeNatives(Bootstrap.java:93)</span><br><span class="line">        at org.elasticsearch.bootstrap.Bootstrap.setup(Bootstrap.java:144)</span><br><span class="line">        at org.elasticsearch.bootstrap.Bootstrap.init(Bootstrap.java:285)</span><br><span class="line">        at org.elasticsearch.bootstrap.Elasticsearch.main(Elasticsearch.java:35)</span><br><span class="line">Refer to the log for complete error details.</span><br></pre></td></tr></table></figure></p><p>这是版本的问题，最新的版本安全级别提高了，不允许采用root帐号启动，所以我们要添加一个用户。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#添加一个用户：elasticsearch</span><br><span class="line">$useradd elasticsearch</span><br><span class="line">#给用户elasticsearch设置密码，连续输入2次</span><br><span class="line">$passwd elasticsearch</span><br><span class="line">#创建一个用户组 es</span><br><span class="line">groupadd es</span><br><span class="line">#分配 elasticsearch 到 es 组</span><br><span class="line">usermod -G elasticsearch es</span><br><span class="line">#这里注意下，如果提示用户“es”不存在，那么是因为服务器版本问题，你可以换成 usermod -G es elasticsearch ,也就是用户和用户组对调一下使用。</span><br><span class="line">#在elasticsearch 根目录下，给定用户权限。-R表示逐级（N层目录） ， * 表示 任何文件</span><br><span class="line">chown -R elasticsearch.es *</span><br><span class="line">#切换到elasticsearch用户</span><br><span class="line">su elasticsearch</span><br></pre></td></tr></table></figure></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="Node-与-Cluster"><a href="#Node-与-Cluster" class="headerlink" title="Node 与 Cluster"></a>Node 与 Cluster</h3><p>Elastic 本质上是一个分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个 Elastic 实例。<br>单个 Elastic 实例称为一个节点（node）。一组节点构成一个集群（cluster）。</p><h3 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h3><p>Elastic 会索引所有字段，经过处理后写入一个反向索引（Inverted Index）。查找数据的时候，直接查找该索引。<br>所以，Elastic 数据管理的顶层单位就叫做 Index（索引）。它是单个数据库的同义词。每个 Index （即数据库）的名字必须是小写。<br>下面的命令可以查看当前节点的所有 Index。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X GET &apos;http://localhost:9200/_cat/indices?v&apos;</span><br></pre></td></tr></table></figure></p><h3 id="Document"><a href="#Document" class="headerlink" title="Document"></a>Document</h3><p>Index 里面单条的记录称为 Document（文档）。许多条 Document 构成了一个 Index。<br>Document 使用 JSON 格式表示，下面是一个例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;user&quot;: &quot;张三&quot;,</span><br><span class="line">  &quot;title&quot;: &quot;工程师&quot;,</span><br><span class="line">  &quot;desc&quot;: &quot;数据库管理&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同一个 Index 里面的 Document，不要求有相同的结构（scheme），但是最好保持相同，这样有利于提高搜索效率。</p><h3 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h3><p>Document 可以分组，比如weather这个Index里面，可以按城市分组（北京和上海），也可以按气候分组（晴天和雨天）。这种分组就叫做Type，它是虚拟的逻辑分组，用来过滤 Document。<br>不同的 Type 应该有相似的结构（schema），举例来说，id字段不能在这个组是字符串，在另一个组是数值。这是与关系型数据库的表的一个区别。性质完全不同的数据（比如products和logs）应该存成两个 Index，而不是一个 Index 里面的两个 Type（虽然可以做到）。<br>下面的命令可以列出每个 Index 所包含的 Type。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;localhost:9200/_mapping?pretty=true&apos;</span><br></pre></td></tr></table></figure></p><blockquote><p>pretty=true 表示让返回结果的显示格式更美观</p></blockquote><h2 id="新建和删除-Index"><a href="#新建和删除-Index" class="headerlink" title="新建和删除 Index"></a>新建和删除 Index</h2><p>新建 Index<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X PUT &apos;localhost:9200/weather&apos;</span><br></pre></td></tr></table></figure></p><p>服务器返回一个 JSON 对象，里面的acknowledged字段表示操作成功。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;acknowledged&quot;:true,</span><br><span class="line">  &quot;shards_acknowledged&quot;:true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后，我们发出 DELETE 请求，删除这个 Index。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X DELETE &apos;localhost:9200/weather&apos;</span><br></pre></td></tr></table></figure></p><h2 id="中文分词设置"><a href="#中文分词设置" class="headerlink" title="中文分词设置"></a>中文分词设置</h2><p>安装中文分词插件。使用 ik<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v5.5.1/elasticsearch-analysis-ik-5.5.1.zip</span><br></pre></td></tr></table></figure></p><p>重新启动 Elastic，会自动加载这个新安装的插件</p><h4 id="新建一个-Index，指定需要分词的字段。这一步根据数据结构而异，基本上，凡是需要搜索的中文字段，都要单独设置一下。"><a href="#新建一个-Index，指定需要分词的字段。这一步根据数据结构而异，基本上，凡是需要搜索的中文字段，都要单独设置一下。" class="headerlink" title="新建一个 Index，指定需要分词的字段。这一步根据数据结构而异，基本上，凡是需要搜索的中文字段，都要单独设置一下。"></a>新建一个 Index，指定需要分词的字段。这一步根据数据结构而异，基本上，凡是需要搜索的中文字段，都要单独设置一下。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X PUT &apos;localhost:9200/accounts&apos; -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;person&quot;: &#123;</span><br><span class="line">      &quot;properties&quot;: &#123;</span><br><span class="line">        &quot;user&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">          &quot;analyzer&quot;: &quot;ik_max_word&quot;,</span><br><span class="line">          &quot;search_analyzer&quot;: &quot;ik_max_word&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;title&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">          &quot;analyzer&quot;: &quot;ik_max_word&quot;,</span><br><span class="line">          &quot;search_analyzer&quot;: &quot;ik_max_word&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;desc&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">          &quot;analyzer&quot;: &quot;ik_max_word&quot;,</span><br><span class="line">          &quot;search_analyzer&quot;: &quot;ik_max_word&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure><p>以上是新建一个名称为accounts的 Index，里面有一个名称为person的 Type。person有三个字段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">user</span><br><span class="line">title</span><br><span class="line">desc</span><br></pre></td></tr></table></figure></p><p>而且类型都是文本（text），所以需要指定中文分词器，不能使用默认的英文分词器。<br>lastic 的分词器称为 analyzer。对每个字段指定分词器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;user&quot;: &#123;</span><br><span class="line">  &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">  &quot;analyzer&quot;: &quot;ik_max_word&quot;,</span><br><span class="line">  &quot;search_analyzer&quot;: &quot;ik_max_word&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码中，<strong>analyzer</strong>是字段文本的分词器，<strong>search_analyzer</strong>是搜索词的分词器。<strong>ik_max_word</strong>分词器是插件ik提供的，可以对文本进行最大数量的分词。</p><h2 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h2><h3 id="新增记录"><a href="#新增记录" class="headerlink" title="新增记录"></a>新增记录</h3><p>向指定的 /Index/Type 发送 PUT 请求，就可以在 Index 里面新增一条记录。比如，向<strong>/accounts/person</strong>发送请求，就可以新增一条人员记录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X PUT &apos;localhost:9200/accounts/person/1&apos; -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;user&quot;: &quot;张三&quot;,</span><br><span class="line">  &quot;title&quot;: &quot;工程师&quot;,</span><br><span class="line">  &quot;desc&quot;: &quot;数据库管理&quot;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure></p><p>服务器返回的 JSON 对象，会给出 Index、Type、Id、Version 等信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot;:&quot;accounts&quot;,</span><br><span class="line">  &quot;_type&quot;:&quot;person&quot;,</span><br><span class="line">  &quot;_id&quot;:&quot;1&quot;,</span><br><span class="line">  &quot;_version&quot;:1,</span><br><span class="line">  &quot;result&quot;:&quot;created&quot;,</span><br><span class="line">  &quot;_shards&quot;:&#123;&quot;total&quot;:2,&quot;successful&quot;:1,&quot;failed&quot;:0&#125;,</span><br><span class="line">  &quot;created&quot;:true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>请求路径是/accounts/person/1，最后的1是该条记录的Id。它不一定是数字，任意字符串（比如abc）都可以。<br>新增记录的时候，也可以不指定 Id，这时要改成 POST 请求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X POST &apos;localhost:9200/accounts/person&apos; -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;user&quot;: &quot;李四&quot;,</span><br><span class="line">  &quot;title&quot;: &quot;工程师&quot;,</span><br><span class="line">  &quot;desc&quot;: &quot;系统管理&quot;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure></p><p>向<strong>/accounts/person</strong>发出一个 POST 请求，添加一个记录。这时，服务器返回的 JSON 对象里面，_id字段就是一个随机字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot;:&quot;accounts&quot;,</span><br><span class="line">  &quot;_type&quot;:&quot;person&quot;,</span><br><span class="line">  &quot;_id&quot;:&quot;AV3qGfrC6jMbsbXb6k1p&quot;,</span><br><span class="line">  &quot;_version&quot;:1,</span><br><span class="line">  &quot;result&quot;:&quot;created&quot;,</span><br><span class="line">  &quot;_shards&quot;:&#123;&quot;total&quot;:2,&quot;successful&quot;:1,&quot;failed&quot;:0&#125;,</span><br><span class="line">  &quot;created&quot;:true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意，如果没有先创建 Index（这个例子是accounts），直接执行上面的命令，Elastic 也不会报错，而是直接生成指定的 Index。</p><h3 id="查看记录"><a href="#查看记录" class="headerlink" title="查看记录"></a>查看记录</h3><p>向/Index/Type/Id发出 GET 请求，就可以查看这条记录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;localhost:9200/accounts/person/1?pretty=true&apos;</span><br></pre></td></tr></table></figure></p><p>上面代码请求查看/accounts/person/1这条记录，URL 的参数<strong>pretty=true</strong>表示以易读的格式返回。<br>返回的数据中，<strong>found</strong>字段表示查询成功，<strong>_source</strong>字段返回原始记录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot; : &quot;accounts&quot;,</span><br><span class="line">  &quot;_type&quot; : &quot;person&quot;,</span><br><span class="line">  &quot;_id&quot; : &quot;1&quot;,</span><br><span class="line">  &quot;_version&quot; : 1,</span><br><span class="line">  &quot;found&quot; : true,</span><br><span class="line">  &quot;_source&quot; : &#123;</span><br><span class="line">    &quot;user&quot; : &quot;张三&quot;,</span><br><span class="line">    &quot;title&quot; : &quot;工程师&quot;,</span><br><span class="line">    &quot;desc&quot; : &quot;数据库管理&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果 Id 不正确，就查不到数据，found字段就是false。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;localhost:9200/weather/beijing/abc?pretty=true&apos;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot; : &quot;accounts&quot;,</span><br><span class="line">  &quot;_type&quot; : &quot;person&quot;,</span><br><span class="line">  &quot;_id&quot; : &quot;abc&quot;,</span><br><span class="line">  &quot;found&quot; : false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="删除记录"><a href="#删除记录" class="headerlink" title="删除记录"></a>删除记录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X DELETE &apos;localhost:9200/accounts/person/1&apos;</span><br></pre></td></tr></table></figure><h3 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h3><p>更新记录就是使用 PUT 请求，重新发送一次数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X PUT &apos;localhost:9200/accounts/person/1&apos; -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;user&quot; : &quot;张三&quot;,</span><br><span class="line">    &quot;title&quot; : &quot;工程师&quot;,</span><br><span class="line">    &quot;desc&quot; : &quot;数据库管理，软件开发&quot;</span><br><span class="line">&#125;&apos; </span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot;:&quot;accounts&quot;,</span><br><span class="line">  &quot;_type&quot;:&quot;person&quot;,</span><br><span class="line">  &quot;_id&quot;:&quot;1&quot;,</span><br><span class="line">  &quot;_version&quot;:2,</span><br><span class="line">  &quot;result&quot;:&quot;updated&quot;,</span><br><span class="line">  &quot;_shards&quot;:&#123;&quot;total&quot;:2,&quot;successful&quot;:1,&quot;failed&quot;:0&#125;,</span><br><span class="line">  &quot;created&quot;:false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码中，我们将原始数据从”数据库管理”改成”数据库管理，软件开发”。 返回结果里面，几个字段发生了变化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;_version&quot; : 2,</span><br><span class="line">&quot;result&quot; : &quot;updated&quot;,</span><br><span class="line">&quot;created&quot; : false</span><br></pre></td></tr></table></figure></p><p><strong>记录的 Id 没变，但是版本（version）从1变成2，操作类型（result）从created变成updated，created字段变成false，因为这次不是新建记录。</strong></p><h2 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h2><h3 id="返回所有记录"><a href="#返回所有记录" class="headerlink" title="返回所有记录"></a>返回所有记录</h3><p>使用 GET 方法，直接请求/Index/Type/_search，就会返回所有记录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;localhost:9200/accounts/person/_search&apos;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;took&quot;:2,</span><br><span class="line">  &quot;timed_out&quot;:false,</span><br><span class="line">  &quot;_shards&quot;:&#123;&quot;total&quot;:5,&quot;successful&quot;:5,&quot;failed&quot;:0&#125;,</span><br><span class="line">  &quot;hits&quot;:&#123;</span><br><span class="line">    &quot;total&quot;:2,</span><br><span class="line">    &quot;max_score&quot;:1.0,</span><br><span class="line">    &quot;hits&quot;:[</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;_index&quot;:&quot;accounts&quot;,</span><br><span class="line">        &quot;_type&quot;:&quot;person&quot;,</span><br><span class="line">        &quot;_id&quot;:&quot;AV3qGfrC6jMbsbXb6k1p&quot;,</span><br><span class="line">        &quot;_score&quot;:1.0,</span><br><span class="line">        &quot;_source&quot;: &#123;</span><br><span class="line">          &quot;user&quot;: &quot;李四&quot;,</span><br><span class="line">          &quot;title&quot;: &quot;工程师&quot;,</span><br><span class="line">          &quot;desc&quot;: &quot;系统管理&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;_index&quot;:&quot;accounts&quot;,</span><br><span class="line">        &quot;_type&quot;:&quot;person&quot;,</span><br><span class="line">        &quot;_id&quot;:&quot;1&quot;,</span><br><span class="line">        &quot;_score&quot;:1.0,</span><br><span class="line">        &quot;_source&quot;: &#123;</span><br><span class="line">          &quot;user&quot; : &quot;张三&quot;,</span><br><span class="line">          &quot;title&quot; : &quot;工程师&quot;,</span><br><span class="line">          &quot;desc&quot; : &quot;数据库管理，软件开发&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>took</strong>字段表示该操作的耗时（单位为毫秒），<strong>timed_out</strong>字段表示是否超时，<strong>hits</strong>字段表示命中的记录，里面子字段的含义如下。</p><blockquote><p>total：返回记录数，本例是2条。<br>max_score：最高的匹配程度，本例是1.0。<br>hits：返回的记录组成的数组。<br>返回的记录中，每条记录都有一个<strong>_score字段</strong>，表示匹配的程序，默认是按照这个字段降序排列。</p></blockquote><h3 id="全文搜索"><a href="#全文搜索" class="headerlink" title="全文搜索"></a>全文搜索</h3><p> 使用GET 请求并带有数据体。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;localhost:9200/accounts/person/_search&apos;  -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;desc&quot; : &quot;软件&quot; &#125;&#125;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure></p><p> 上面代码使用 <strong>Match</strong>查询，指定的匹配条件是<strong>desc</strong>字段里面包含”<strong>软件</strong>“这个词。返回结果如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;took&quot;:3,</span><br><span class="line">  &quot;timed_out&quot;:false,</span><br><span class="line">  &quot;_shards&quot;:&#123;&quot;total&quot;:5,&quot;successful&quot;:5,&quot;failed&quot;:0&#125;,</span><br><span class="line">  &quot;hits&quot;:&#123;</span><br><span class="line">    &quot;total&quot;:1,</span><br><span class="line">    &quot;max_score&quot;:0.28582606,</span><br><span class="line">    &quot;hits&quot;:[</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;_index&quot;:&quot;accounts&quot;,</span><br><span class="line">        &quot;_type&quot;:&quot;person&quot;,</span><br><span class="line">        &quot;_id&quot;:&quot;1&quot;,</span><br><span class="line">        &quot;_score&quot;:0.28582606,</span><br><span class="line">        &quot;_source&quot;: &#123;</span><br><span class="line">          &quot;user&quot; : &quot;张三&quot;,</span><br><span class="line">          &quot;title&quot; : &quot;工程师&quot;,</span><br><span class="line">          &quot;desc&quot; : &quot;数据库管理，软件开发&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>可以通过size字段改变这个返回的条数,默认10条</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;localhost:9200/accounts/person/_search&apos;  -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;desc&quot; : &quot;管理&quot; &#125;&#125;,</span><br><span class="line">  &quot;size&quot;: 1</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure></p><p>可以通过from字段指定位移<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;localhost:9200/accounts/person/_search&apos;  -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;desc&quot; : &quot;管理&quot; &#125;&#125;,</span><br><span class="line">  &quot;from&quot;: 1,</span><br><span class="line">  &quot;size&quot;: 1</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure></p><p>从位置1开始（默认是从位置0开始），只返回一条结果。</p><h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><p>如果有多个搜索关键字， Elastic 认为它们是or关系。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;localhost:9200/accounts/person/_search&apos;  -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;desc&quot; : &quot;软件 系统&quot; &#125;&#125;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure></p><p>上面代码搜索的是<strong>软件 or 系统</strong>。<br>如果要执行多个关键词的and搜索，必须使用<strong>布尔查询</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;localhost:9200/accounts/person/_search&apos;  -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: [</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;desc&quot;: &quot;软件&quot; &#125; &#125;,</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;desc&quot;: &quot;系统&quot; &#125; &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java实现动态代理</title>
      <link href="/2019/01/19/java%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
      <url>/2019/01/19/java%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>java的动态代理机制中，有两个重要的类或接口，一个是 <strong>InvocationHandler(Interface)</strong>、另一个是 Proxy(Class)<br><a id="more"></a></p><h2 id="InvocationHandler"><a href="#InvocationHandler" class="headerlink" title="InvocationHandler:"></a>InvocationHandler:</h2><blockquote><p>InvocationHandler is the interface implemented by the invocation handler of a proxy instance.<br>InvocationHandler是代理实例的调用处理程序实现的接口<br>Each proxy instance has an associated invocation handler. When a method is invoked on a proxy instance, the method invocation is encoded and dispatched to the invoke method of its invocation handler.<br>每个代理实例都有一个关联的调用处理程序。在代理实例上调用方法时，方法调用将被编码并发送到其调用处理程序的invoke方法。</p></blockquote><h2 id="invoke方法"><a href="#invoke方法" class="headerlink" title="invoke方法"></a>invoke方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object invoke(Object proxy, Method method, Object[] args) throws Throwable</span><br><span class="line"></span><br><span class="line">proxy:　　指代我们所代理的那个真实对象</span><br><span class="line">method:　　指代的是我们所要调用真实对象的某个方法的Method对象</span><br><span class="line">args:　　指代的是调用真实对象某个方法时接受的参数</span><br></pre></td></tr></table></figure><h2 id="newProxyInstance"><a href="#newProxyInstance" class="headerlink" title="newProxyInstance"></a>newProxyInstance</h2><p>Proxy这个类的作用就是用来动态创建一个代理对象的类，它提供了许多的方法，用的最多的就是 newProxyInstance 这个方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException</span><br><span class="line"></span><br><span class="line">loader:　　一个ClassLoader对象，定义了由哪个ClassLoader对象来对生成的代理对象进行加载</span><br><span class="line"></span><br><span class="line">interfaces:　　一个Interface对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了</span><br><span class="line"></span><br><span class="line">h:　　一个InvocationHandler对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上</span><br></pre></td></tr></table></figure></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>1.定义一个Subject类型的接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface Subject &#123;</span><br><span class="line">//定义了两个方法</span><br><span class="line">    public void rent();</span><br><span class="line">    public void hello(String str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.定义一个类来实现这个接口，这个类就是真实对象，RealSubject类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class RealSubject implements Subject&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void rent() &#123;</span><br><span class="line">        System.out.println(&quot;I want to rent&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void hello(String str) &#123;</span><br><span class="line">        System.out.println(&quot;hello: &quot; + str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3.定义一个动态代理类，每一个动态代理类都必须要实现 InvocationHandler<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class DynamicProxy implements InvocationHandler &#123;</span><br><span class="line">    //　这个就是我们要代理的真实对象</span><br><span class="line">    private Object subject;</span><br><span class="line"></span><br><span class="line">    //    构造方法，给我们要代理的真实对象赋初值</span><br><span class="line">    public DynamicProxy(Object subject)</span><br><span class="line">    &#123;</span><br><span class="line">        this.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object object, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">    //在代理真实对象前我们可以添加一些自己的操作</span><br><span class="line">        System.out.println(&quot;before rent house&quot;);</span><br><span class="line">        System.out.println(&quot;Method: &quot;+method);</span><br><span class="line">        //此时是调用真实对象的方法</span><br><span class="line">        method.invoke(subject,args);</span><br><span class="line">        //代理后同样可以添加一些操作</span><br><span class="line">        //doSomething();</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Client类"><a href="#Client类" class="headerlink" title="Client类"></a>Client类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">    //    要代理的真实对象</span><br><span class="line">        RealSubject realSubject = new RealSubject();</span><br><span class="line">    //    要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法的</span><br><span class="line">        InvocationHandler handler = new DynamicProxy(realSubject);</span><br><span class="line">        Subject subject =(Subject) Proxy.newProxyInstance(</span><br><span class="line">                                                            realSubject.getClass().getClassLoader(),//真实类的类加载器</span><br><span class="line">                                                            realSubject.getClass().getInterfaces(),//被代理类的接口</span><br><span class="line">                                                            handler//代理对象</span><br><span class="line">                                                          );</span><br><span class="line">        System.out.println(subject.getClass().getName());</span><br><span class="line">        subject.rent();</span><br><span class="line">        subject.hello(&quot;The world will become better&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">com.sun.proxy.$Proxy0</span><br><span class="line">before rent house</span><br><span class="line">Method: public abstract void 动态代理.Subject.rent()</span><br><span class="line">I want to rent</span><br><span class="line">before rent house</span><br><span class="line">Method: public abstract void 动态代理.Subject.hello(java.lang.String)</span><br><span class="line">hello: The world will become better</span><br></pre></td></tr></table></figure><p>通过 Proxy.newProxyInstance 创建的代理对象subject是在jvm运行时动态生成的一个对象，它并<strong>不是InvocationHandler类型，也不是我们定义的那组接口的类型，而是在运行时动态生成的一个对象，并且命名方式都是这样的形式，以$开头，proxy为中，最后一个数字表示对象的标号</strong>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 动态代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring相关</title>
      <link href="/2019/01/19/Spring%E7%9B%B8%E5%85%B3/"/>
      <url>/2019/01/19/Spring%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="IOC-DI"><a href="#IOC-DI" class="headerlink" title="IOC/DI"></a>IOC/DI</h2><a id="more"></a><h3 id="1-概念及原理"><a href="#1-概念及原理" class="headerlink" title="1. 概念及原理"></a>1. 概念及原理</h3><blockquote><p>IOC: Inversion of Control(控制反转)是一种设计思想,利用了工厂模式。对象及其依赖对象的创建及维护都不需要在应用程序中实现，将其交给IOC容器去管理。<strong>传统的开发中，我们自己在对象内部创建依赖对象并注入当前对象，完成依赖关系的维护；对于IOC而言，强调将主动变为被动，由IOC容器来负责依赖对象的创建和查找，由IOC容器来进行注入组合对象</strong>，只需要在相关的配置文件中维护对象之间的依赖关系即可。</p></blockquote><blockquote><p>DI: Dependency Injection，即“依赖注入”。其实IOC和DI本就是同一个概念的两种不同的表述，<strong>应用程序依赖容器提供的外部对象，容器将其依赖的外部资源在运行期注入到应用程序中；某个对象被调用时，其所依赖的对象由容器注入</strong>。</p></blockquote><h2 id="2-AOP"><a href="#2-AOP" class="headerlink" title="2.AOP"></a>2.AOP</h2><blockquote><p>AOP利用一种称为“<strong>横切</strong>”的技术，剖解开封装的对象内部，<strong>将那些影响多个类的公共行为封装到一个可重用模块，并将其名为切面(Aspect)</strong>。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑封装起来的部分。以便于减少系统的重复代码，降低模块间的耦合度，并有利于系统维护。<br>　　使用“横切”技术，AOP把软件系统分为两个部分：<strong>核心关注点（业务逻辑）和横切关注点（通用逻辑，即方面）。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。</strong>横切关注点的特点是，其经常发生在核心关注点的多处，而各处都基本相似。比如权限认证、日志、事务处理，debug管理，性能检测等。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。</p></blockquote><p>　　 </p>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十章 内部类</title>
      <link href="/2019/01/17/%E7%AC%AC%E5%8D%81%E7%AB%A0-%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <url>/2019/01/17/%E7%AC%AC%E5%8D%81%E7%AB%A0-%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="了解外围类-并且能与之通信"><a href="#了解外围类-并且能与之通信" class="headerlink" title="了解外围类,并且能与之通信"></a>了解外围类,并且能与之通信</h2><a id="more"></a><p>内部类能访问其外围对象的所有成员而不需要任何特殊条件，当某个外围类对象创建了一个内部类对象时，此内部类对象必定会秘密地捕获一个指向那个外部类对象的引用，然后在你访问此外围类的成员时,就是用那个引用来选择外围的成员。<br>使用.this 和.new<br>需要需要生成对外部类对象的引用,可以使用外部类的名字后紧跟原点和this.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class DotThis&#123;</span><br><span class="line">  void f()&#123;System.out.println(&quot;DotThis.f()&quot;);&#125;</span><br><span class="line">  public class Inner&#123;</span><br><span class="line">    public class DotThis outer()&#123;</span><br><span class="line">      return DotThis.this;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  public Inner inner()&#123;return new TInner();&#125;</span><br><span class="line">  public static void main(String[] args)&#123;</span><br><span class="line">    DotThis dt = new DotThis();</span><br><span class="line">    DotThis.Inner dti = dt.inner();</span><br><span class="line">    dti.outer().f();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*Output:</span><br><span class="line">DotThis.f()</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p><p>直接创建内部类的对象:<br>在ner表达式中提供对其外部类对象的引用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DotNew dn = new DotNew();</span><br><span class="line">DotNew.Inner dni = dn.new Inner();</span><br></pre></td></tr></table></figure></p><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p><strong>如果定义一个匿名内部类,并且希望它日用外部定义的对象,那么编译器会要求其参数引用为final</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public interface Destination&#123;</span><br><span class="line">  String readLabel();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Parcel9&#123;</span><br><span class="line">  public Destination destination(final String dest)&#123;</span><br><span class="line">    return new Destination()&#123;</span><br><span class="line">      private String label = dest;</span><br><span class="line">      public String readLabel()&#123;return label&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里引用了外部类的String对象dest,所以要求参数引用必须为final</p><h2 id="嵌套类-static"><a href="#嵌套类-static" class="headerlink" title="嵌套类(static)"></a>嵌套类(static)</h2><p>如果不需要内部类与外围类对象之间有练习,可以将内部类声明为static<br>普通内部类与static的嵌套类的区别:</p><blockquote><p>1.创建嵌套类的对象,并不需要其外围类的对象.<br>2.不能从嵌套类的对象中访问非静态的外围类对象.<br>3.普通的内部类不能有static数据和static字段,也不能包含嵌套类,即(内部类中还有内部类),而嵌套类(static)可以做到.</p></blockquote><h2 id="接口内部的类"><a href="#接口内部的类" class="headerlink" title="接口内部的类"></a>接口内部的类</h2><p>正常情况下,不能在接口内置任何代码,但嵌套类可以作为接口的一部分,放置到接口中的任何类都自动是public 和 static的.<br>因为类是static的,只是将嵌套类置于接口的命名空间,并不违反接口的规则. 甚至可以在内部类中实现其外围接口</p><h2 id="从多层嵌套类访问外部成员"><a href="#从多层嵌套类访问外部成员" class="headerlink" title="从多层嵌套类访问外部成员"></a>从多层嵌套类访问外部成员</h2><p>内部类—可以透明地访问所有它的外围成员(不论是不是private)<br>嵌套内部类—可以透明地访问它所嵌入的外围类的所有成员<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class MNA&#123;</span><br><span class="line">  private void f()&#123;&#125;</span><br><span class="line">  class A&#123;</span><br><span class="line">    private void g()&#123;&#125;</span><br><span class="line">    public class B&#123;</span><br><span class="line">      void h()&#123;</span><br><span class="line">        g();</span><br><span class="line">        f();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">public  class MultiNestingAccess&#123;</span><br><span class="line">  public static void main(String[] args)&#123;</span><br><span class="line">    MNA mna = new MNA();</span><br><span class="line">    MNA.A mnaa = mna.new A();</span><br><span class="line">    MNA.A.B mnaab = mnaa.new B();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>可以看到在MNA,A,A中, 调用方法g()和f()并不需要任何条件(即使被声明为private)</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> java编程思想 </tag>
            
            <tag> 内部类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常用命令</title>
      <link href="/2019/01/16/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/01/16/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="git-clone-url-克隆项目到本地"><a href="#git-clone-url-克隆项目到本地" class="headerlink" title="git clone url 克隆项目到本地"></a>git clone url 克隆项目到本地</h3><a id="more"></a><h3 id="git-push-提交"><a href="#git-push-提交" class="headerlink" title="git push 提交"></a>git push 提交</h3><h3 id="git-branch-显示所有分支"><a href="#git-branch-显示所有分支" class="headerlink" title="git branch 显示所有分支"></a>git branch 显示所有分支</h3><h3 id="git-status-查看修改的内容"><a href="#git-status-查看修改的内容" class="headerlink" title="git status 查看修改的内容"></a>git status 查看修改的内容</h3><h3 id="git-add-确认所有修改"><a href="#git-add-确认所有修改" class="headerlink" title="git add . 确认所有修改"></a>git add . 确认所有修改</h3><h3 id="git-commit-m-“这里是注释”"><a href="#git-commit-m-“这里是注释”" class="headerlink" title="git commit -m “这里是注释”"></a>git commit -m “这里是注释”</h3><h3 id="git-diff-显示差别"><a href="#git-diff-显示差别" class="headerlink" title="git diff 显示差别"></a>git diff 显示差别</h3><h3 id="git-log-查看提交的日志"><a href="#git-log-查看提交的日志" class="headerlink" title="git log 查看提交的日志"></a>git log 查看提交的日志</h3><h3 id="git-rebase-i-startpoint-endpoint"><a href="#git-rebase-i-startpoint-endpoint" class="headerlink" title="git rebase -i  [startpoint]  [endpoint]"></a>git rebase -i  [startpoint]  [endpoint]</h3><blockquote><p>其中-i的意思是–interactive，即弹出交互式的界面让用户编辑完成合并操作，[startpoint]  [endpoint]则指定了一个编辑区间，如果不指定[endpoint]，则该区间的终点默认是当前分支HEAD所指向的commit</p></blockquote><h3 id="fetch更新本地仓库两种方式"><a href="#fetch更新本地仓库两种方式" class="headerlink" title="fetch更新本地仓库两种方式"></a>fetch更新本地仓库两种方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//方法一</span><br><span class="line">$ git fetch origin master //从远程的origin仓库的master分支下载代码到本地的origin master</span><br><span class="line"></span><br><span class="line">$ git log -p master.. origin/master//比较本地的仓库和远程参考的区别</span><br><span class="line"></span><br><span class="line">$ git merge origin/master//把远程下载下来的代码合并到本地仓库，远程的和本地的合并</span><br><span class="line">//方法二</span><br><span class="line">$ git fetch origin master:temp //从远程的origin仓库的master分支下载到本地并新建一个分支temp</span><br><span class="line"></span><br><span class="line">$ git diff temp//比较master分支和temp分支的不同</span><br><span class="line"></span><br><span class="line">$ git merge temp//合并temp分支到master分支</span><br><span class="line"></span><br><span class="line">$ git branch -d temp//删除temp</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础笔记</title>
      <link href="/2019/01/15/Java%E5%9F%BA%E7%A1%80%E9%9B%B6%E6%95%A3%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/01/15/Java%E5%9F%BA%E7%A1%80%E9%9B%B6%E6%95%A3%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>1.URL u =new URL(“<a href="http://www.123.com&quot;);。如果www.123.com不存在，则返回______。" target="_blank" rel="noopener">http://www.123.com&quot;);。如果www.123.com不存在，则返回______。</a><br><a id="more"></a><br>result:<br>返回’<a href="http://www.123.com&#39;,我们在执行URL" target="_blank" rel="noopener">http://www.123.com&#39;,我们在执行URL</a> u =new URL(“<a href="http://www.123.com&quot;);这句话的时候确实要抛出异常，但是这个异常属于IOException，不管网址是否存在，最后都会返回该网址的一个连接，打印出来就是该网址。" target="_blank" rel="noopener">http://www.123.com&quot;);这句话的时候确实要抛出异常，但是这个异常属于IOException，不管网址是否存在，最后都会返回该网址的一个连接，打印出来就是该网址。</a></p><p>2.新建的线程调用start()方法就能立即进行运行状态<br>result:<br><strong>错误,调用start()后让thread进去可运行状态（runnable），只是等待获取CPU的使用权。</strong></p><p>3.</p><blockquote><p>CountDownLatch：允许一个或多个线程等待其他线程完成操作；</p></blockquote><blockquote><p>CyclicBarrier：同步屏障，让一组线程到达一个屏障时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会执行。</p></blockquote><p>4.</p><pre><code>String str1 = &quot;hello&quot;;String str2 = &quot;he&quot;+new String(&quot;llo&quot;);System.out.println(str1==str2);//false,</code></pre><p>5.java中的true,false,null不是关键字,只是一些显式常量值</p><p>6.<strong>异常相关</strong><br><img src="http://uploadfiles.nowcoder.com/images/20150920/458054_1442763788854_B47C957C7EB6BD455B267510F3DF76F1" alt="异常类图"></p><blockquote><p><strong>运行时异常</strong>： 都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。<br>       运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。<br><strong>非运行时异常</strong> （<strong>编译异常</strong>）： 是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</p></blockquote><p>7.类的加载</p><blockquote><p><strong>父类静态域(static修饰)=&gt;子类静态域(static修饰)=&gt;父类成员和构造块=&gt;父类的构造方法&gt;=子类的成员和构造代码块&gt;=子类的构造方法</strong></p></blockquote><blockquote><p><strong>普通成员变量和普通代码块是同级的 执行按照先后顺序进行</strong></p></blockquote><p>8.abstract和final</p><blockquote><p><strong>abstract和final不能用来修饰同一个类</strong><br><strong>abstract类中可以没有抽象方法，接口中也可以有abstract方法</strong>。</p></blockquote><p>9.servlet周期包括__.</p><blockquote><p>init()  –&gt; 初始化<br>service()  –&gt;  处理请求<br>destory () –&gt; 销毁</p></blockquote><p>10.下面哪个语句是创建数组的正确语句？( )<br>A.float f[][] = new float[6][6];<br>B.float []f[] = new float[6][6];<br>C.float f[][] = new float[][6];<br>D.float [][]f = new float[6][6];<br>E.float [][]f = new float[6][];</p><p>result:ABDE</p><blockquote><p>ABDE都可以。也就是说<strong>数组命名时名称与[]可以随意排列</strong>，但声明的二维数组中第一个中括号中必须要有值，它代表的是在该二维数组中有多少个一维数组。<br>阿里规范里，数组严禁使用int a[][] 等形式，应当使用int[][] a 的可读性较强的形式</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三章 操作符</title>
      <link href="/2019/01/15/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
      <url>/2019/01/15/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符:"></a>逻辑操作符:</h2><a id="more"></a><p>逻辑操作符使用双位字符(&amp;&amp;或者||)</p><h2 id="按位操作符"><a href="#按位操作符" class="headerlink" title="按位操作符:"></a>按位操作符:</h2><p>按位与 : &amp;</p><p>按位或 : |</p><p>~符号 : 每一位都取反</p><p>^异或操作符 : <strong>只要输入为的某一个是1,但不全是都是1,那么按位异或操作生成一个输出位1.(如果两个都为1,则异或的结果位0)</strong></p><p>相反数 : 除了第一个符号位不变外,所有位都取反最后加1</p><h2 id="Integer相关"><a href="#Integer相关" class="headerlink" title="Integer相关"></a>Integer相关</h2><p>Integer.MAX_VALUE =0111,1111,1111,1111,1111,1111,1111,1111. 一共31个1,值为2`31-1;</p><p>Integer.MIN_VALUE= 1000,0000,0000,0000,0000,0000,0000,0000 一共32位,值为-2`31;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Integer.MAX_VALUE+1==Integer.MIN_VALUE);</span><br></pre></td></tr></table></figure></p><p>输出结果为TRUE<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(1&lt;&lt;31==Integer.MIN_VALUE);</span><br></pre></td></tr></table></figure></p><p>输出结果为TRUE</p><h2 id="截尾和舍入"><a href="#截尾和舍入" class="headerlink" title="截尾和舍入"></a>截尾和舍入</h2><p>将float和double转化为整形值时 总是对该数字进行截尾 如29.7 转化为29 0.7转化为0</p><h2 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h2><p>基本类型的运算: 只要类型比int小 运算之前会把值自动转换为int，这样一来，最终生成的结果就是int类型。 <strong>表达式中出现的最大的数据类型决定了表达式最终结果的数据类型</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> java编程思想 </tag>
            
            <tag> 操作符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次防止渗透的措施</title>
      <link href="/2019/01/14/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%98%B2%E6%AD%A2%E6%B8%97%E9%80%8F%E7%9A%84%E6%8E%AA%E6%96%BD/"/>
      <url>/2019/01/14/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%98%B2%E6%AD%A2%E6%B8%97%E9%80%8F%E7%9A%84%E6%8E%AA%E6%96%BD/</url>
      
        <content type="html"><![CDATA[<p><strong>在后端做文件上传的格式校验时,不能只对Content-Type做校验</strong><br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if(!$image = CUploadedFile::getInstanceByName(&apos;upload_file&apos;)) &#123;</span><br><span class="line">            $response[&apos;code&apos;] = -2;</span><br><span class="line">            $response[&apos;msg&apos;]  =  &apos;param error&apos;;</span><br><span class="line">        &#125; else if($image-&gt;getSize() == 0 || $image-&gt;getSize() &gt; 1*1024*1024) &#123;</span><br><span class="line">            $response[&apos;code&apos;] = -3;</span><br><span class="line">            $response[&apos;msg&apos;]  =  &apos;size error&apos;;</span><br><span class="line">        &#125; else if(!in_array($image-&gt;type, array(&apos;image/jpeg&apos;, &apos;image/png&apos;, &apos;image/gif&apos;)))&#123;</span><br><span class="line">            $response[&apos;code&apos;] = -4;</span><br><span class="line">            $response[&apos;msg&apos;]  = &apos;type error&apos;;</span><br><span class="line">        &#125; else if(!$image-&gt;saveAs($local_file.&apos;.&apos;.$image-&gt;extensionName)) &#123;</span><br><span class="line">            $response[&apos;code&apos;] = -5;</span><br><span class="line">            $response[&apos;msg&apos;]  = &apos;file save error&apos;;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>项目原先的代码文件类型处只对Content-Type做了校验,无法防止渗透,<br>测试人员可以通过修改文件后缀名配合BuirSuit等抓包工具在绕过前端验证后删除后缀名达到成功上传其他格式文件的限制</p><blockquote><p>改善措施:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">else if(!in_array($image-&gt;extensionName,array(&apos;jpg&apos;,&apos;jpeg&apos;, &apos;png&apos;, &apos;gif&apos;)))&#123;</span><br><span class="line">            $response[&apos;code&apos;] = -4;</span><br><span class="line">            $response[&apos;msg&apos;]  = &apos;type error&apos;;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>添加对文件后缀名的验证</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP笔记</title>
      <link href="/2019/01/14/PHP%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/01/14/PHP%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-变量"><a href="#1-变量" class="headerlink" title="1. 变量"></a>1. 变量</h2><a id="more"></a><p>变量以\$符号开始，后面跟着变量的名称<br>变量名必须以字母或者下划线字符开始<br>变量名只能包含字母数字字符以及下划线（A-z、0-9 和 _ ）<br>变量名不能包含空格<br>变量名是区分大小写的（$y 和 $Y 是两个不同的变量）</p><h3 id="作用域："><a href="#作用域：" class="headerlink" title="作用域："></a>作用域：</h3><ul><li>local</li><li>global(global 关键字用于函数内访问全局变量)</li><li>static(希望某个局部变量在方法执行完后不删除,则使用static)</li><li>parameter(参数是在参数列表中声明的，作为函数声明的一部分：)</li></ul><h2 id="2-echo-和-print"><a href="#2-echo-和-print" class="headerlink" title="2. echo 和 print"></a>2. echo 和 print</h2><p>echo 和 print 区别:</p><blockquote><p>echo - 可以输出一个或多个字符串(echo “这是一个”, “字符串，”, “使用了”, “多个”, “参数。”;)<br>print - 只允许输出一个字符串，返回值总为 1<br>echo 输出的速度比 print 快， echo 没有返回值，print有返回值1。</p></blockquote><h2 id="3-EOF"><a href="#3-EOF" class="headerlink" title="3. EOF"></a>3. EOF</h2><blockquote><p>PHP EOF(heredoc)是一种在命令行shell（如sh、csh、ksh、bash、PowerShell和zsh）和程序语言（像Perl、PHP、Python和Ruby）里定义一个字串的方法。</p></blockquote><ol><li>必须后接分号，否则编译通不过。</li><li>EOF 可以用任意其它字符代替，只需保证结束标识与开始标识一致。</li><li>结束标识必须顶格独自占一行(即必须从行首开始，前后不能衔接任何空白和字符)。</li><li>开始标识可以不带引号或带单双引号，不带引号与带双引号效果一致，解释内嵌的变量和转义符号，带单引号则不解释内嵌的变量和转义符号。</li><li>当内容需要内嵌引号（单引号或双引号）时，不需要加转义符，本身对单双引号转义，此处相当与q和qq的用法。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo &lt;&lt;&lt;EOF</span><br><span class="line">    &lt;h1&gt;我的第一个标题&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;我的第一个段落。&lt;/p&gt;</span><br><span class="line">EOF;</span><br><span class="line">// 结束需要独立一行且前后不能空格</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p> <strong>EOF 的作用就是按照原样，包括换行格式什么的，输出在其内部的东西；在 PHP 定界符 EOF 中的任何特殊字符都不需要转义；</strong></p><h2 id="4-数据类型"><a href="#4-数据类型" class="headerlink" title="4.数据类型"></a>4.数据类型</h2><p>String（字符串）, Integer（整型）, Float（浮点型）, Boolean（布尔型）, Array（数组）, Object（对象）, NULL（空值）。<br><strong>var_dump() 函数返回变量的数据类型和值：</strong></p><p>PHP 对象:<br>对象数据类型也可以用于存储数据。</p><blockquote><p>在 PHP 中，对象必须声明。<br>首先，必须使用class关键字声明类对象。类是可以包含属性和方法的结构。<br>然后在类中定义数据类型，然后在实例化的类中使用数据类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Car</span><br><span class="line">&#123;</span><br><span class="line">  var $color;</span><br><span class="line">  function __construct($color=&quot;green&quot;) &#123;</span><br><span class="line">    $this-&gt;color = $color;</span><br><span class="line">  &#125;</span><br><span class="line">  function what_color() &#123;</span><br><span class="line">    return $this-&gt;color;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p></blockquote><p>this 就是指向当前对象的指针</p><h2 id="5-常量"><a href="#5-常量" class="headerlink" title="5.常量"></a>5.常量</h2><p>设置常量:</p><pre><code>define(name,value,case_insensitive);</code></pre><p>name：必选参数，常量名称，即标志符。<br>value：必选参数，常量的值。<br>case_insensitive ：可选参数，如果设置为TRUE，该常量则大小写不敏感。默认是大小写敏感的。    </p><p><strong>常量是全局的,常量在定义后，默认是全局变量，可以在整个运行的脚本的任何地方使用。</strong>    </p><h2 id="5-字符串"><a href="#5-字符串" class="headerlink" title="5.字符串"></a>5.字符串</h2><p>PHP 并置运算符:</p><blockquote><p>在 PHP 中，只有一个字符串运算符,并置运算符 (.) 用于把两个字符串值连接起来。</p></blockquote><p>strlen() 函数:</p><blockquote><p>获取长度</p></blockquote><p> strpos() 函数:</p><blockquote><p>strpos() 函数用于在字符串内查找一个字符或一段指定的文本。<br>如果在字符串中找到匹配，该函数会返回第一个匹配的字符位置。如果未找到匹配，则返回 FALSE。</p></blockquote><h2 id="6-运算符"><a href="#6-运算符" class="headerlink" title="6.运算符"></a>6.运算符</h2><p> 优先级： &amp;&amp;  &gt;  =  &gt;  and<br> 优先级： ||  &gt;  =  &gt;  or</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a = 3;</span><br><span class="line">$b = false;</span><br><span class="line">$c = $a or $b;</span><br><span class="line">var_dump($c);          // 这里的 $c 为 int 值3，而不是 boolean 值 true</span><br><span class="line">$d = $a || $b;</span><br><span class="line">var_dump($d);          //这里的 $d 就是 boolean 值 true </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="7-PHP-数组"><a href="#7-PHP-数组" class="headerlink" title="7.PHP 数组"></a>7.PHP 数组</h2><p>PHP一维数组:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);</span><br><span class="line">echo &quot;I like &quot; . $cars[0] . &quot;, &quot; . $cars[1] . &quot; and &quot; . $cars[2] . &quot;.&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p>关联数组:相当于键值对形式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$age=array(&quot;Peter&quot;=&gt;&quot;35&quot;,&quot;Ben&quot;=&gt;&quot;37&quot;,&quot;Joe&quot;=&gt;&quot;43&quot;);</span><br><span class="line">echo &quot;Peter is &quot; . $age[&apos;Peter&apos;] . &quot; years old.&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p>多维数组:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$cars = array</span><br><span class="line">(</span><br><span class="line">//二维数组</span><br><span class="line">array(&quot;Volvo&quot;,100,96),</span><br><span class="line">array(&quot;BMW&quot;,60,59),</span><br><span class="line">array(&quot;Toyota&quot;,110,100)</span><br><span class="line">);</span><br><span class="line">?&gt;</span><br><span class="line">//多维数组</span><br><span class="line">$sites = array</span><br><span class="line">(</span><br><span class="line">    &quot;runoob&quot;=&gt;array</span><br><span class="line">    (</span><br><span class="line">        &quot;菜鸟教程&quot;,</span><br><span class="line">        &quot;http://www.runoob.com&quot;</span><br><span class="line">    ),</span><br><span class="line">    &quot;google&quot;=&gt;array</span><br><span class="line">    (</span><br><span class="line">        &quot;Google 搜索&quot;,</span><br><span class="line">        &quot;http://www.google.com&quot;</span><br><span class="line">    ),</span><br><span class="line">    &quot;taobao&quot;=&gt;array</span><br><span class="line">    (</span><br><span class="line">        &quot;淘宝&quot;,</span><br><span class="line">        &quot;http://www.taobao.com&quot;</span><br><span class="line">    )</span><br><span class="line">);</span><br><span class="line">print(&quot;&lt;pre&gt;&quot;); // 格式化输出数组</span><br><span class="line">print_r($sites);</span><br><span class="line">print(&quot;&lt;/pre&gt;&quot;);</span><br></pre></td></tr></table></figure></p><h2 id="8-PHP超级全局变量"><a href="#8-PHP超级全局变量" class="headerlink" title="8.PHP超级全局变量"></a>8.PHP超级全局变量</h2><ul><li>\$GLOBALS</li><li>\$_SERVER</li><li>\$_REQUEST</li><li>\$_POST</li><li>\$_GET</li><li>\$_FILES</li><li>\$_ENV</li><li>\$_COOKIE</li><li>\$_SESSION</li></ul><h2 id="9-魔术常量"><a href="#9-魔术常量" class="headerlink" title="9.魔术常量"></a>9.魔术常量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo &apos;这是第 &quot; &apos; . __LINE__ . &apos; &quot; 行&apos;;</span><br><span class="line">?&gt;</span><br><span class="line">&lt;?php</span><br><span class="line">echo &apos;该文件位于 &quot; &apos; . __FILE__ . &apos; &quot; &apos;;</span><br><span class="line">?&gt;</span><br><span class="line">&lt;?php</span><br><span class="line">echo &apos;该文件位于 &quot; &apos; . __DIR__ . &apos; &quot; &apos;;</span><br><span class="line">?&gt;</span><br><span class="line">&lt;?php</span><br><span class="line">function test() &#123;</span><br><span class="line">echo &apos;函数名为：&apos; . __FUNCTION__ ;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line">?&gt;</span><br><span class="line">&lt;?php</span><br><span class="line">class test &#123;</span><br><span class="line">function _print() &#123;</span><br><span class="line">echo &apos;类名为：&apos; . __CLASS__ . &quot;&lt;br&gt;&quot;;</span><br><span class="line">echo &apos;函数名为：&apos; . __FUNCTION__ ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">$t = new test();</span><br><span class="line">$t-&gt;_print();</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//trait</span><br><span class="line">&lt;?php</span><br><span class="line">class Base &#123;</span><br><span class="line">public function sayHello() &#123;</span><br><span class="line">echo &apos;Hello &apos;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">trait SayWorld &#123;</span><br><span class="line">public function sayHello() &#123;</span><br><span class="line">parent::sayHello();</span><br><span class="line">echo &apos;World!&apos;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class MyHelloWorld extends Base &#123;</span><br><span class="line">use SayWorld;</span><br><span class="line">&#125;</span><br><span class="line">$o = new MyHelloWorld();</span><br><span class="line">$o-&gt;sayHello();</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">//method</span><br><span class="line">&lt;?php</span><br><span class="line">function test() &#123;</span><br><span class="line">echo &apos;函数名为：&apos; . __METHOD__ ;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">//namespace</span><br><span class="line">&lt;?php</span><br><span class="line">namespace MyProject;</span><br><span class="line">echo &apos;命名空间为：&quot;&apos;, __NAMESPACE__, &apos;&quot;&apos;; // 输出 &quot;MyProject&quot;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="10-命名空间"><a href="#10-命名空间" class="headerlink" title="10.命名空间"></a>10.命名空间</h2><blockquote><p><strong>非限定名称</strong>，或不包含前缀的类名称，例如 $a=new foo(); 或 foo::staticmethod();。如果当前命名空间是 currentnamespace，foo 将被解析为 currentnamespace\foo。如果使用 foo 的代码是全局的，不包含在任何命名空间中的代码，则 foo 会被解析为foo。 警告：如果命名空间中的函数或常量未定义，则该非限定的函数名称或常量名称会被解析为全局函数名称或常量名称。</p></blockquote><blockquote><p><strong>限定名称**</strong>,或包含前缀的名称，例如 $a = new subnamespace\foo(); 或 subnamespace\foo::staticmethod();。如果当前的命名空间是 currentnamespace，则 foo 会被解析为 currentnamespace\subnamespace\foo。如果使用 foo 的代码是全局的，不包含在任何命名空间中的代码，foo 会被解析为subnamespace\foo。</p></blockquote><blockquote><p><strong>完全限定名称</strong>，或包含了全局前缀操作符的名称，例如， $a = new \currentnamespace\foo(); 或 \currentnamespace\foo::staticmethod();。在这种情况下，foo 总是被解析为代码中的文字名(literal name)currentnamespace\foo。</p></blockquote><h2 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a>持续更新…</h2>]]></content>
      
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
