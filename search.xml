<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ElasticSearch笔记</title>
      <link href="/2019/01/25/ElasticSearch%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/01/25/ElasticSearch%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>全文搜索属于最常见的需求，开源的 Elasticsearch是目前全文搜索引擎的首选。<br>Elastic 的底层是开源库Lucene。但是，无法直接用Lucene，必须写代码去调用它的接口。<strong>Elastic 是 Lucene 的封装，提供了 REST API 的操作接口，开箱即用。</strong></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Elastic 需要 Java 8 环境。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.5.1.zip</span><br><span class="line">$ unzip elasticsearch-5.5.1.zip</span><br><span class="line">$ mv elasticsearch-5.5.1 destination(目标文件夹)</span><br><span class="line">$ cd elasticsearch-5.5.1/</span><br></pre></td></tr></table></figure></p><p>不要把es目录放在 ~目录下,这是root用户的用户目录,后面要切换到自定义用户</p><p>下载后在 elasticsearch  根目录下启动。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elasticsearch-2.2.0]# ./bin/elasticsearch</span><br></pre></td></tr></table></figure></p><p>启动时报java内存不足的解决方法</p><blockquote><p>解决办法：<br>1、进入/home/elasticsearch-5.3.1/config<br>2、修改jvm.options 的配置 vim jvm.options<br>3、修改为-Xms512M<br>-Xmx512M </p></blockquote><p>解决之后,继续报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.RuntimeException: don&apos;t run elasticsearch as root.</span><br><span class="line">        at org.elasticsearch.bootstrap.Bootstrap.initializeNatives(Bootstrap.java:93)</span><br><span class="line">        at org.elasticsearch.bootstrap.Bootstrap.setup(Bootstrap.java:144)</span><br><span class="line">        at org.elasticsearch.bootstrap.Bootstrap.init(Bootstrap.java:285)</span><br><span class="line">        at org.elasticsearch.bootstrap.Elasticsearch.main(Elasticsearch.java:35)</span><br><span class="line">Refer to the log for complete error details.</span><br></pre></td></tr></table></figure></p><p>这是版本的问题，最新的版本安全级别提高了，不允许采用root帐号启动，所以我们要添加一个用户。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#添加一个用户：elasticsearch</span><br><span class="line">$useradd elasticsearch</span><br><span class="line">#给用户elasticsearch设置密码，连续输入2次</span><br><span class="line">$passwd elasticsearch</span><br><span class="line">#创建一个用户组 es</span><br><span class="line">groupadd es</span><br><span class="line">#分配 elasticsearch 到 es 组</span><br><span class="line">usermod -G elasticsearch es</span><br><span class="line">#这里注意下，如果提示用户“es”不存在，那么是因为服务器版本问题，你可以换成 usermod -G es elasticsearch ,也就是用户和用户组对调一下使用。</span><br><span class="line">#在elasticsearch 根目录下，给定用户权限。-R表示逐级（N层目录） ， * 表示 任何文件</span><br><span class="line">chown -R elasticsearch.es *</span><br><span class="line">#切换到elasticsearch用户</span><br><span class="line">su elasticsearch</span><br></pre></td></tr></table></figure></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="Node-与-Cluster"><a href="#Node-与-Cluster" class="headerlink" title="Node 与 Cluster"></a>Node 与 Cluster</h3><p>Elastic 本质上是一个分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个 Elastic 实例。<br>单个 Elastic 实例称为一个节点（node）。一组节点构成一个集群（cluster）。</p><h3 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h3><p>Elastic 会索引所有字段，经过处理后写入一个反向索引（Inverted Index）。查找数据的时候，直接查找该索引。<br>所以，Elastic 数据管理的顶层单位就叫做 Index（索引）。它是单个数据库的同义词。每个 Index （即数据库）的名字必须是小写。<br>下面的命令可以查看当前节点的所有 Index。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X GET &apos;http://localhost:9200/_cat/indices?v&apos;</span><br></pre></td></tr></table></figure></p><h3 id="Document"><a href="#Document" class="headerlink" title="Document"></a>Document</h3><p>Index 里面单条的记录称为 Document（文档）。许多条 Document 构成了一个 Index。<br>Document 使用 JSON 格式表示，下面是一个例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;user&quot;: &quot;张三&quot;,</span><br><span class="line">  &quot;title&quot;: &quot;工程师&quot;,</span><br><span class="line">  &quot;desc&quot;: &quot;数据库管理&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同一个 Index 里面的 Document，不要求有相同的结构（scheme），但是最好保持相同，这样有利于提高搜索效率。</p><h3 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h3><p>Document 可以分组，比如weather这个Index里面，可以按城市分组（北京和上海），也可以按气候分组（晴天和雨天）。这种分组就叫做Type，它是虚拟的逻辑分组，用来过滤 Document。<br>不同的 Type 应该有相似的结构（schema），举例来说，id字段不能在这个组是字符串，在另一个组是数值。这是与关系型数据库的表的一个区别。性质完全不同的数据（比如products和logs）应该存成两个 Index，而不是一个 Index 里面的两个 Type（虽然可以做到）。<br>下面的命令可以列出每个 Index 所包含的 Type。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;localhost:9200/_mapping?pretty=true&apos;</span><br></pre></td></tr></table></figure></p><blockquote><p>pretty=true 表示让返回结果的显示格式更美观</p></blockquote><h2 id="新建和删除-Index"><a href="#新建和删除-Index" class="headerlink" title="新建和删除 Index"></a>新建和删除 Index</h2><p>新建 Index<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X PUT &apos;localhost:9200/weather&apos;</span><br></pre></td></tr></table></figure></p><p>服务器返回一个 JSON 对象，里面的acknowledged字段表示操作成功。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;acknowledged&quot;:true,</span><br><span class="line">  &quot;shards_acknowledged&quot;:true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后，我们发出 DELETE 请求，删除这个 Index。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X DELETE &apos;localhost:9200/weather&apos;</span><br></pre></td></tr></table></figure></p><h2 id="中文分词设置"><a href="#中文分词设置" class="headerlink" title="中文分词设置"></a>中文分词设置</h2><p>安装中文分词插件。使用 ik<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v5.5.1/elasticsearch-analysis-ik-5.5.1.zip</span><br></pre></td></tr></table></figure></p><p>重新启动 Elastic，会自动加载这个新安装的插件</p><h4 id="新建一个-Index，指定需要分词的字段。这一步根据数据结构而异，基本上，凡是需要搜索的中文字段，都要单独设置一下。"><a href="#新建一个-Index，指定需要分词的字段。这一步根据数据结构而异，基本上，凡是需要搜索的中文字段，都要单独设置一下。" class="headerlink" title="新建一个 Index，指定需要分词的字段。这一步根据数据结构而异，基本上，凡是需要搜索的中文字段，都要单独设置一下。"></a>新建一个 Index，指定需要分词的字段。这一步根据数据结构而异，基本上，凡是需要搜索的中文字段，都要单独设置一下。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X PUT &apos;localhost:9200/accounts&apos; -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;person&quot;: &#123;</span><br><span class="line">      &quot;properties&quot;: &#123;</span><br><span class="line">        &quot;user&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">          &quot;analyzer&quot;: &quot;ik_max_word&quot;,</span><br><span class="line">          &quot;search_analyzer&quot;: &quot;ik_max_word&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;title&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">          &quot;analyzer&quot;: &quot;ik_max_word&quot;,</span><br><span class="line">          &quot;search_analyzer&quot;: &quot;ik_max_word&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;desc&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">          &quot;analyzer&quot;: &quot;ik_max_word&quot;,</span><br><span class="line">          &quot;search_analyzer&quot;: &quot;ik_max_word&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure><p>以上是新建一个名称为accounts的 Index，里面有一个名称为person的 Type。person有三个字段</p><ol><li>user</li><li>title</li><li>desc</li></ol><p>而且类型都是文本（text），所以需要指定中文分词器，不能使用默认的英文分词器。<br>lastic 的分词器称为 analyzer。对每个字段指定分词器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;user&quot;: &#123;</span><br><span class="line">  &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">  &quot;analyzer&quot;: &quot;ik_max_word&quot;,</span><br><span class="line">  &quot;search_analyzer&quot;: &quot;ik_max_word&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码中，<strong>analyzer</strong>是字段文本的分词器，<strong>search_analyzer</strong>是搜索词的分词器。<strong>ik_max_word</strong>分词器是插件ik提供的，可以对文本进行最大数量的分词。</p><h2 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h2><h3 id="新增记录"><a href="#新增记录" class="headerlink" title="新增记录"></a>新增记录</h3><p>向指定的 /Index/Type 发送 PUT 请求，就可以在 Index 里面新增一条记录。比如，向<strong>/accounts/person</strong>发送请求，就可以新增一条人员记录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X PUT &apos;localhost:9200/accounts/person/1&apos; -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;user&quot;: &quot;张三&quot;,</span><br><span class="line">  &quot;title&quot;: &quot;工程师&quot;,</span><br><span class="line">  &quot;desc&quot;: &quot;数据库管理&quot;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure></p><p>服务器返回的 JSON 对象，会给出 Index、Type、Id、Version 等信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot;:&quot;accounts&quot;,</span><br><span class="line">  &quot;_type&quot;:&quot;person&quot;,</span><br><span class="line">  &quot;_id&quot;:&quot;1&quot;,</span><br><span class="line">  &quot;_version&quot;:1,</span><br><span class="line">  &quot;result&quot;:&quot;created&quot;,</span><br><span class="line">  &quot;_shards&quot;:&#123;&quot;total&quot;:2,&quot;successful&quot;:1,&quot;failed&quot;:0&#125;,</span><br><span class="line">  &quot;created&quot;:true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>请求路径是/accounts/person/1，最后的1是该条记录的Id。它不一定是数字，任意字符串（比如abc）都可以。<br>新增记录的时候，也可以不指定 Id，这时要改成 POST 请求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X POST &apos;localhost:9200/accounts/person&apos; -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;user&quot;: &quot;李四&quot;,</span><br><span class="line">  &quot;title&quot;: &quot;工程师&quot;,</span><br><span class="line">  &quot;desc&quot;: &quot;系统管理&quot;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure></p><p>向<strong>/accounts/person</strong>发出一个 POST 请求，添加一个记录。这时，服务器返回的 JSON 对象里面，_id字段就是一个随机字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot;:&quot;accounts&quot;,</span><br><span class="line">  &quot;_type&quot;:&quot;person&quot;,</span><br><span class="line">  &quot;_id&quot;:&quot;AV3qGfrC6jMbsbXb6k1p&quot;,</span><br><span class="line">  &quot;_version&quot;:1,</span><br><span class="line">  &quot;result&quot;:&quot;created&quot;,</span><br><span class="line">  &quot;_shards&quot;:&#123;&quot;total&quot;:2,&quot;successful&quot;:1,&quot;failed&quot;:0&#125;,</span><br><span class="line">  &quot;created&quot;:true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意，如果没有先创建 Index（这个例子是accounts），直接执行上面的命令，Elastic 也不会报错，而是直接生成指定的 Index。</p><h3 id="查看记录"><a href="#查看记录" class="headerlink" title="查看记录"></a>查看记录</h3><p>向/Index/Type/Id发出 GET 请求，就可以查看这条记录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;localhost:9200/accounts/person/1?pretty=true&apos;</span><br></pre></td></tr></table></figure></p><p>上面代码请求查看/accounts/person/1这条记录，URL 的参数<strong>pretty=true</strong>表示以易读的格式返回。<br>返回的数据中，<strong>found</strong>字段表示查询成功，<strong>_source</strong>字段返回原始记录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot; : &quot;accounts&quot;,</span><br><span class="line">  &quot;_type&quot; : &quot;person&quot;,</span><br><span class="line">  &quot;_id&quot; : &quot;1&quot;,</span><br><span class="line">  &quot;_version&quot; : 1,</span><br><span class="line">  &quot;found&quot; : true,</span><br><span class="line">  &quot;_source&quot; : &#123;</span><br><span class="line">    &quot;user&quot; : &quot;张三&quot;,</span><br><span class="line">    &quot;title&quot; : &quot;工程师&quot;,</span><br><span class="line">    &quot;desc&quot; : &quot;数据库管理&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果 Id 不正确，就查不到数据，found字段就是false。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;localhost:9200/weather/beijing/abc?pretty=true&apos;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot; : &quot;accounts&quot;,</span><br><span class="line">  &quot;_type&quot; : &quot;person&quot;,</span><br><span class="line">  &quot;_id&quot; : &quot;abc&quot;,</span><br><span class="line">  &quot;found&quot; : false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="删除记录"><a href="#删除记录" class="headerlink" title="删除记录"></a>删除记录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X DELETE &apos;localhost:9200/accounts/person/1&apos;</span><br></pre></td></tr></table></figure><h3 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h3><p>更新记录就是使用 PUT 请求，重新发送一次数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X PUT &apos;localhost:9200/accounts/person/1&apos; -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;user&quot; : &quot;张三&quot;,</span><br><span class="line">    &quot;title&quot; : &quot;工程师&quot;,</span><br><span class="line">    &quot;desc&quot; : &quot;数据库管理，软件开发&quot;</span><br><span class="line">&#125;&apos; </span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot;:&quot;accounts&quot;,</span><br><span class="line">  &quot;_type&quot;:&quot;person&quot;,</span><br><span class="line">  &quot;_id&quot;:&quot;1&quot;,</span><br><span class="line">  &quot;_version&quot;:2,</span><br><span class="line">  &quot;result&quot;:&quot;updated&quot;,</span><br><span class="line">  &quot;_shards&quot;:&#123;&quot;total&quot;:2,&quot;successful&quot;:1,&quot;failed&quot;:0&#125;,</span><br><span class="line">  &quot;created&quot;:false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码中，我们将原始数据从”数据库管理”改成”数据库管理，软件开发”。 返回结果里面，几个字段发生了变化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;_version&quot; : 2,</span><br><span class="line">&quot;result&quot; : &quot;updated&quot;,</span><br><span class="line">&quot;created&quot; : false</span><br></pre></td></tr></table></figure></p><p><strong>记录的 Id 没变，但是版本（version）从1变成2，操作类型（result）从created变成updated，created字段变成false，因为这次不是新建记录。</strong></p><h2 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h2><h3 id="返回所有记录"><a href="#返回所有记录" class="headerlink" title="返回所有记录"></a>返回所有记录</h3><p>使用 GET 方法，直接请求/Index/Type/_search，就会返回所有记录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;localhost:9200/accounts/person/_search&apos;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;took&quot;:2,</span><br><span class="line">  &quot;timed_out&quot;:false,</span><br><span class="line">  &quot;_shards&quot;:&#123;&quot;total&quot;:5,&quot;successful&quot;:5,&quot;failed&quot;:0&#125;,</span><br><span class="line">  &quot;hits&quot;:&#123;</span><br><span class="line">    &quot;total&quot;:2,</span><br><span class="line">    &quot;max_score&quot;:1.0,</span><br><span class="line">    &quot;hits&quot;:[</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;_index&quot;:&quot;accounts&quot;,</span><br><span class="line">        &quot;_type&quot;:&quot;person&quot;,</span><br><span class="line">        &quot;_id&quot;:&quot;AV3qGfrC6jMbsbXb6k1p&quot;,</span><br><span class="line">        &quot;_score&quot;:1.0,</span><br><span class="line">        &quot;_source&quot;: &#123;</span><br><span class="line">          &quot;user&quot;: &quot;李四&quot;,</span><br><span class="line">          &quot;title&quot;: &quot;工程师&quot;,</span><br><span class="line">          &quot;desc&quot;: &quot;系统管理&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;_index&quot;:&quot;accounts&quot;,</span><br><span class="line">        &quot;_type&quot;:&quot;person&quot;,</span><br><span class="line">        &quot;_id&quot;:&quot;1&quot;,</span><br><span class="line">        &quot;_score&quot;:1.0,</span><br><span class="line">        &quot;_source&quot;: &#123;</span><br><span class="line">          &quot;user&quot; : &quot;张三&quot;,</span><br><span class="line">          &quot;title&quot; : &quot;工程师&quot;,</span><br><span class="line">          &quot;desc&quot; : &quot;数据库管理，软件开发&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>took</strong>字段表示该操作的耗时（单位为毫秒），<strong>timed_out</strong>字段表示是否超时，<strong>hits</strong>字段表示命中的记录，里面子字段的含义如下。</p><blockquote><p>total：返回记录数，本例是2条。<br>max_score：最高的匹配程度，本例是1.0。<br>hits：返回的记录组成的数组。<br>返回的记录中，每条记录都有一个<strong>_score字段</strong>，表示匹配的程序，默认是按照这个字段降序排列。</p></blockquote><h3 id="全文搜索"><a href="#全文搜索" class="headerlink" title="全文搜索"></a>全文搜索</h3><p> 使用GET 请求并带有数据体。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;localhost:9200/accounts/person/_search&apos;  -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;desc&quot; : &quot;软件&quot; &#125;&#125;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure></p><p> 上面代码使用 <strong>Match</strong>查询，指定的匹配条件是<strong>desc</strong>字段里面包含”<strong>软件</strong>“这个词。返回结果如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;took&quot;:3,</span><br><span class="line">  &quot;timed_out&quot;:false,</span><br><span class="line">  &quot;_shards&quot;:&#123;&quot;total&quot;:5,&quot;successful&quot;:5,&quot;failed&quot;:0&#125;,</span><br><span class="line">  &quot;hits&quot;:&#123;</span><br><span class="line">    &quot;total&quot;:1,</span><br><span class="line">    &quot;max_score&quot;:0.28582606,</span><br><span class="line">    &quot;hits&quot;:[</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;_index&quot;:&quot;accounts&quot;,</span><br><span class="line">        &quot;_type&quot;:&quot;person&quot;,</span><br><span class="line">        &quot;_id&quot;:&quot;1&quot;,</span><br><span class="line">        &quot;_score&quot;:0.28582606,</span><br><span class="line">        &quot;_source&quot;: &#123;</span><br><span class="line">          &quot;user&quot; : &quot;张三&quot;,</span><br><span class="line">          &quot;title&quot; : &quot;工程师&quot;,</span><br><span class="line">          &quot;desc&quot; : &quot;数据库管理，软件开发&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>可以通过size字段改变这个返回的条数,默认10条</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;localhost:9200/accounts/person/_search&apos;  -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;desc&quot; : &quot;管理&quot; &#125;&#125;,</span><br><span class="line">  &quot;size&quot;: 1</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure></p><p>可以通过from字段指定位移<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;localhost:9200/accounts/person/_search&apos;  -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;desc&quot; : &quot;管理&quot; &#125;&#125;,</span><br><span class="line">  &quot;from&quot;: 1,</span><br><span class="line">  &quot;size&quot;: 1</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure></p><p>从位置1开始（默认是从位置0开始），只返回一条结果。</p><h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><p>如果有多个搜索关键字， Elastic 认为它们是or关系。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;localhost:9200/accounts/person/_search&apos;  -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;desc&quot; : &quot;软件 系统&quot; &#125;&#125;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure></p><p>上面代码搜索的是<strong>软件 or 系统</strong>。<br>如果要执行多个关键词的and搜索，必须使用<strong>布尔查询</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;localhost:9200/accounts/person/_search&apos;  -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: [</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;desc&quot;: &quot;软件&quot; &#125; &#125;,</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;desc&quot;: &quot;系统&quot; &#125; &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java实现动态代理</title>
      <link href="/2019/01/19/java%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
      <url>/2019/01/19/java%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>java的动态代理机制中，有两个重要的类或接口，一个是 <strong>InvocationHandler(Interface)</strong>、另一个是 Proxy(Class)<br><a id="more"></a></p><h2 id="InvocationHandler"><a href="#InvocationHandler" class="headerlink" title="InvocationHandler:"></a>InvocationHandler:</h2><blockquote><p>InvocationHandler is the interface implemented by the invocation handler of a proxy instance.<br>InvocationHandler是代理实例的调用处理程序实现的接口<br>Each proxy instance has an associated invocation handler. When a method is invoked on a proxy instance, the method invocation is encoded and dispatched to the invoke method of its invocation handler.<br>每个代理实例都有一个关联的调用处理程序。在代理实例上调用方法时，方法调用将被编码并发送到其调用处理程序的invoke方法。</p></blockquote><h2 id="invoke方法"><a href="#invoke方法" class="headerlink" title="invoke方法"></a>invoke方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object invoke(Object proxy, Method method, Object[] args) throws Throwable</span><br><span class="line"></span><br><span class="line">proxy:　　指代我们所代理的那个真实对象</span><br><span class="line">method:　　指代的是我们所要调用真实对象的某个方法的Method对象</span><br><span class="line">args:　　指代的是调用真实对象某个方法时接受的参数</span><br></pre></td></tr></table></figure><h2 id="newProxyInstance"><a href="#newProxyInstance" class="headerlink" title="newProxyInstance"></a>newProxyInstance</h2><p>Proxy这个类的作用就是用来动态创建一个代理对象的类，它提供了许多的方法，用的最多的就是 newProxyInstance 这个方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException</span><br><span class="line"></span><br><span class="line">loader:　　一个ClassLoader对象，定义了由哪个ClassLoader对象来对生成的代理对象进行加载</span><br><span class="line"></span><br><span class="line">interfaces:　　一个Interface对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了</span><br><span class="line"></span><br><span class="line">h:　　一个InvocationHandler对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上</span><br></pre></td></tr></table></figure></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>1.定义一个Subject类型的接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface Subject &#123;</span><br><span class="line">//定义了两个方法</span><br><span class="line">    public void rent();</span><br><span class="line">    public void hello(String str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.定义一个类来实现这个接口，这个类就是真实对象，RealSubject类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class RealSubject implements Subject&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void rent() &#123;</span><br><span class="line">        System.out.println(&quot;I want to rent&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void hello(String str) &#123;</span><br><span class="line">        System.out.println(&quot;hello: &quot; + str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3.定义一个动态代理类，每一个动态代理类都必须要实现 InvocationHandler<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class DynamicProxy implements InvocationHandler &#123;</span><br><span class="line">    //　这个就是我们要代理的真实对象</span><br><span class="line">    private Object subject;</span><br><span class="line"></span><br><span class="line">    //    构造方法，给我们要代理的真实对象赋初值</span><br><span class="line">    public DynamicProxy(Object subject)</span><br><span class="line">    &#123;</span><br><span class="line">        this.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object object, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">    //在代理真实对象前我们可以添加一些自己的操作</span><br><span class="line">        System.out.println(&quot;before rent house&quot;);</span><br><span class="line">        System.out.println(&quot;Method: &quot;+method);</span><br><span class="line">        //此时是调用真实对象的方法</span><br><span class="line">        method.invoke(subject,args);</span><br><span class="line">        //代理后同样可以添加一些操作</span><br><span class="line">        //doSomething();</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Client类"><a href="#Client类" class="headerlink" title="Client类"></a>Client类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">    //    要代理的真实对象</span><br><span class="line">        RealSubject realSubject = new RealSubject();</span><br><span class="line">    //    要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法的</span><br><span class="line">        InvocationHandler handler = new DynamicProxy(realSubject);</span><br><span class="line">        Subject subject =(Subject) Proxy.newProxyInstance(</span><br><span class="line">                                                            realSubject.getClass().getClassLoader(),//真实类的类加载器</span><br><span class="line">                                                            realSubject.getClass().getInterfaces(),//被代理类的接口</span><br><span class="line">                                                            handler//代理对象</span><br><span class="line">                                                          );</span><br><span class="line">        System.out.println(subject.getClass().getName());</span><br><span class="line">        subject.rent();</span><br><span class="line">        subject.hello(&quot;The world will become better&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">com.sun.proxy.$Proxy0</span><br><span class="line">before rent house</span><br><span class="line">Method: public abstract void 动态代理.Subject.rent()</span><br><span class="line">I want to rent</span><br><span class="line">before rent house</span><br><span class="line">Method: public abstract void 动态代理.Subject.hello(java.lang.String)</span><br><span class="line">hello: The world will become better</span><br></pre></td></tr></table></figure><p>通过 Proxy.newProxyInstance 创建的代理对象subject是在jvm运行时动态生成的一个对象，它并<strong>不是InvocationHandler类型，也不是我们定义的那组接口的类型，而是在运行时动态生成的一个对象，并且命名方式都是这样的形式，以$开头，proxy为中，最后一个数字表示对象的标号</strong>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 动态代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring相关</title>
      <link href="/2019/01/19/spring%E7%9B%B8%E5%85%B3/"/>
      <url>/2019/01/19/spring%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="IOC-DI"><a href="#IOC-DI" class="headerlink" title="IOC/DI"></a>IOC/DI</h2><a id="more"></a><h3 id="1-概念及原理"><a href="#1-概念及原理" class="headerlink" title="1. 概念及原理"></a>1. 概念及原理</h3><blockquote><p>IOC: Inversion of Control(控制反转)是一种设计思想,利用了工厂模式。对象及其依赖对象的创建及维护都不需要在应用程序中实现，将其交给IOC容器去管理。<strong>传统的开发中，我们自己在对象内部创建依赖对象并注入当前对象，完成依赖关系的维护；对于IOC而言，强调将主动变为被动，由IOC容器来负责依赖对象的创建和查找，由IOC容器来进行注入组合对象</strong>，只需要在相关的配置文件中维护对象之间的依赖关系即可。</p></blockquote><blockquote><p>DI: Dependency Injection，即“依赖注入”。其实IOC和DI本就是同一个概念的两种不同的表述，<strong>应用程序依赖容器提供的外部对象，容器将其依赖的外部资源在运行期注入到应用程序中；某个对象被调用时，其所依赖的对象由容器注入</strong>。</p></blockquote><h2 id="2-AOP"><a href="#2-AOP" class="headerlink" title="2.AOP"></a>2.AOP</h2><blockquote><p>AOP利用一种称为“<strong>横切</strong>”的技术，剖解开封装的对象内部，<strong>将那些影响多个类的公共行为封装到一个可重用模块，并将其名为切面(Aspect)</strong>。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑封装起来的部分。以便于减少系统的重复代码，降低模块间的耦合度，并有利于系统维护。<br>　　使用“横切”技术，AOP把软件系统分为两个部分：<strong>核心关注点（业务逻辑）和横切关注点（通用逻辑，即方面）。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。</strong>横切关注点的特点是，其经常发生在核心关注点的多处，而各处都基本相似。比如权限认证、日志、事务处理，debug管理，性能检测等。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。</p></blockquote><p>　　 </p>]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十章 内部类</title>
      <link href="/2019/01/17/%E7%AC%AC%E5%8D%81%E7%AB%A0-%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <url>/2019/01/17/%E7%AC%AC%E5%8D%81%E7%AB%A0-%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="了解外围类-并且能与之通信"><a href="#了解外围类-并且能与之通信" class="headerlink" title="了解外围类,并且能与之通信"></a>了解外围类,并且能与之通信</h2><a id="more"></a><p>内部类能访问其外围对象的所有成员而不需要任何特殊条件，当某个外围类对象创建了一个内部类对象时，此内部类对象必定会秘密地捕获一个指向那个外部类对象的引用，然后在你访问此外围类的成员时,就是用那个引用来选择外围的成员。<br>使用.this 和.new<br>需要需要生成对外部类对象的引用,可以使用外部类的名字后紧跟原点和this.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class DotThis&#123;</span><br><span class="line">  void f()&#123;System.out.println(&quot;DotThis.f()&quot;);&#125;</span><br><span class="line">  public class Inner&#123;</span><br><span class="line">    public class DotThis outer()&#123;</span><br><span class="line">      return DotThis.this;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  public Inner inner()&#123;return new TInner();&#125;</span><br><span class="line">  public static void main(String[] args)&#123;</span><br><span class="line">    DotThis dt = new DotThis();</span><br><span class="line">    DotThis.Inner dti = dt.inner();</span><br><span class="line">    dti.outer().f();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*Output:</span><br><span class="line">DotThis.f()</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p><p>直接创建内部类的对象:<br>在ner表达式中提供对其外部类对象的引用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DotNew dn = new DotNew();</span><br><span class="line">DotNew.Inner dni = dn.new Inner();</span><br></pre></td></tr></table></figure></p><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p><strong>如果定义一个匿名内部类,并且希望它日用外部定义的对象,那么编译器会要求其参数引用为final</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public interface Destination&#123;</span><br><span class="line">  String readLabel();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Parcel9&#123;</span><br><span class="line">  public Destination destination(final String dest)&#123;</span><br><span class="line">    return new Destination()&#123;</span><br><span class="line">      private String label = dest;</span><br><span class="line">      public String readLabel()&#123;return label&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里引用了外部类的String对象dest,所以要求参数引用必须为final</p><h2 id="嵌套类-static"><a href="#嵌套类-static" class="headerlink" title="嵌套类(static)"></a>嵌套类(static)</h2><p>如果不需要内部类与外围类对象之间有练习,可以将内部类声明为static<br>普通内部类与static的嵌套类的区别:</p><blockquote><p>1.创建嵌套类的对象,并不需要其外围类的对象.<br>2.不能从嵌套类的对象中访问非静态的外围类对象.<br>3.普通的内部类不能有static数据和static字段,也不能包含嵌套类,即(内部类中还有内部类),而嵌套类(static)可以做到.</p></blockquote><h2 id="接口内部的类"><a href="#接口内部的类" class="headerlink" title="接口内部的类"></a>接口内部的类</h2><p>正常情况下,不能在接口内置任何代码,但嵌套类可以作为接口的一部分,放置到接口中的任何类都自动是public 和 static的.<br>因为类是static的,只是将嵌套类置于接口的命名空间,并不违反接口的规则. 甚至可以在内部类中实现其外围接口</p><h2 id="从多层嵌套类访问外部成员"><a href="#从多层嵌套类访问外部成员" class="headerlink" title="从多层嵌套类访问外部成员"></a>从多层嵌套类访问外部成员</h2><p>内部类—可以透明地访问所有它的外围成员(不论是不是private)<br>嵌套内部类—可以透明地访问它所嵌入的外围类的所有成员<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class MNA&#123;</span><br><span class="line">  private void f()&#123;&#125;</span><br><span class="line">  class A&#123;</span><br><span class="line">    private void g()&#123;&#125;</span><br><span class="line">    public class B&#123;</span><br><span class="line">      void h()&#123;</span><br><span class="line">        g();</span><br><span class="line">        f();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">public  class MultiNestingAccess&#123;</span><br><span class="line">  public static void main(String[] args)&#123;</span><br><span class="line">    MNA mna = new MNA();</span><br><span class="line">    MNA.A mnaa = mna.new A();</span><br><span class="line">    MNA.A.B mnaab = mnaa.new B();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>可以看到在MNA,A,A中, 调用方法g()和f()并不需要任何条件(即使被声明为private)</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> java编程思想 </tag>
            
            <tag> 内部类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常用命令</title>
      <link href="/2019/01/16/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/01/16/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="git-clone-url-克隆项目到本地"><a href="#git-clone-url-克隆项目到本地" class="headerlink" title="git clone url 克隆项目到本地"></a>git clone url 克隆项目到本地</h3><a id="more"></a><h3 id="git-push-提交"><a href="#git-push-提交" class="headerlink" title="git push 提交"></a>git push 提交</h3><h3 id="git-branch-显示所有分支"><a href="#git-branch-显示所有分支" class="headerlink" title="git branch 显示所有分支"></a>git branch 显示所有分支</h3><h3 id="git-status-查看修改的内容"><a href="#git-status-查看修改的内容" class="headerlink" title="git status 查看修改的内容"></a>git status 查看修改的内容</h3><h3 id="git-add-确认所有修改"><a href="#git-add-确认所有修改" class="headerlink" title="git add . 确认所有修改"></a>git add . 确认所有修改</h3><h3 id="git-commit-m-“这里是注释”"><a href="#git-commit-m-“这里是注释”" class="headerlink" title="git commit -m “这里是注释”"></a>git commit -m “这里是注释”</h3><h3 id="git-diff-显示差别"><a href="#git-diff-显示差别" class="headerlink" title="git diff 显示差别"></a>git diff 显示差别</h3><h3 id="git-log-查看提交的日志"><a href="#git-log-查看提交的日志" class="headerlink" title="git log 查看提交的日志"></a>git log 查看提交的日志</h3><h3 id="git-rebase-i-startpoint-endpoint"><a href="#git-rebase-i-startpoint-endpoint" class="headerlink" title="git rebase -i  [startpoint]  [endpoint]"></a>git rebase -i  [startpoint]  [endpoint]</h3><blockquote><p>其中-i的意思是–interactive，即弹出交互式的界面让用户编辑完成合并操作，[startpoint]  [endpoint]则指定了一个编辑区间，如果不指定[endpoint]，则该区间的终点默认是当前分支HEAD所指向的commit</p></blockquote><h3 id="fetch更新本地仓库两种方式"><a href="#fetch更新本地仓库两种方式" class="headerlink" title="fetch更新本地仓库两种方式"></a>fetch更新本地仓库两种方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//方法一</span><br><span class="line">$ git fetch origin master //从远程的origin仓库的master分支下载代码到本地的origin master</span><br><span class="line"></span><br><span class="line">$ git log -p master.. origin/master//比较本地的仓库和远程参考的区别</span><br><span class="line"></span><br><span class="line">$ git merge origin/master//把远程下载下来的代码合并到本地仓库，远程的和本地的合并</span><br><span class="line">//方法二</span><br><span class="line">$ git fetch origin master:temp //从远程的origin仓库的master分支下载到本地并新建一个分支temp</span><br><span class="line"></span><br><span class="line">$ git diff temp//比较master分支和temp分支的不同</span><br><span class="line"></span><br><span class="line">$ git merge temp//合并temp分支到master分支</span><br><span class="line"></span><br><span class="line">$ git branch -d temp//删除temp</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础笔记</title>
      <link href="/2019/01/15/Java%E5%9F%BA%E7%A1%80%E9%9B%B6%E6%95%A3%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/01/15/Java%E5%9F%BA%E7%A1%80%E9%9B%B6%E6%95%A3%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>1.URL u =new URL(“<a href="http://www.123.com&quot;);。如果www.123.com不存在，则返回______。" target="_blank" rel="noopener">http://www.123.com&quot;);。如果www.123.com不存在，则返回______。</a><br><a id="more"></a><br>result:<br>返回’<a href="http://www.123.com&#39;,我们在执行URL" target="_blank" rel="noopener">http://www.123.com&#39;,我们在执行URL</a> u =new URL(“<a href="http://www.123.com&quot;);这句话的时候确实要抛出异常，但是这个异常属于IOException，不管网址是否存在，最后都会返回该网址的一个连接，打印出来就是该网址。" target="_blank" rel="noopener">http://www.123.com&quot;);这句话的时候确实要抛出异常，但是这个异常属于IOException，不管网址是否存在，最后都会返回该网址的一个连接，打印出来就是该网址。</a></p><p>2.新建的线程调用start()方法就能立即进行运行状态<br>result:<br><strong>错误,调用start()后让thread进去可运行状态（runnable），只是等待获取CPU的使用权。</strong></p><p>3.</p><blockquote><p>CountDownLatch：允许一个或多个线程等待其他线程完成操作；</p></blockquote><blockquote><p>CyclicBarrier：同步屏障，让一组线程到达一个屏障时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会执行。</p></blockquote><p>4.</p><pre><code>String str1 = &quot;hello&quot;;String str2 = &quot;he&quot;+new String(&quot;llo&quot;);System.out.println(str1==str2);//false,</code></pre><p>5.java中的true,false,null不是关键字,只是一些显式常量值</p><p>6.<strong>异常相关</strong><br><img src="http://uploadfiles.nowcoder.com/images/20150920/458054_1442763788854_B47C957C7EB6BD455B267510F3DF76F1" alt="异常类图"></p><blockquote><p><strong>运行时异常</strong>： 都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。<br>       运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。<br><strong>非运行时异常</strong> （<strong>编译异常</strong>）： 是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</p></blockquote><p>7.类的加载</p><blockquote><p><strong>父类静态域(static修饰)=&gt;子类静态域(static修饰)=&gt;父类成员和构造块=&gt;父类的构造方法&gt;=子类的成员和构造代码块&gt;=子类的构造方法</strong></p></blockquote><blockquote><p><strong>普通成员变量和普通代码块是同级的 执行按照先后顺序进行</strong></p></blockquote><p>8.abstract和final</p><blockquote><p><strong>abstract和final不能用来修饰同一个类</strong><br><strong>abstract类中可以没有抽象方法，接口中也可以有abstract方法</strong>。</p></blockquote><p>9.servlet周期包括__.</p><blockquote><p>init()  –&gt; 初始化<br>service()  –&gt;  处理请求<br>destory () –&gt; 销毁</p></blockquote><p>10.下面哪个语句是创建数组的正确语句？( )<br>A.float f[][] = new float[6][6];<br>B.float []f[] = new float[6][6];<br>C.float f[][] = new float[][6];<br>D.float [][]f = new float[6][6];<br>E.float [][]f = new float[6][];</p><p>result:ABDE</p><blockquote><p>ABDE都可以。也就是说<strong>数组命名时名称与[]可以随意排列</strong>，但声明的二维数组中第一个中括号中必须要有值，它代表的是在该二维数组中有多少个一维数组。<br>阿里规范里，数组严禁使用int a[][] 等形式，应当使用int[][] a 的可读性较强的形式</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三章 操作符</title>
      <link href="/2019/01/15/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
      <url>/2019/01/15/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符:"></a>逻辑操作符:</h2><a id="more"></a><p>逻辑操作符使用双位字符(&amp;&amp;或者||)</p><h2 id="按位操作符"><a href="#按位操作符" class="headerlink" title="按位操作符:"></a>按位操作符:</h2><p>按位与 : &amp;</p><p>按位或 : |</p><p>~符号 : 每一位都取反</p><p>^异或操作符 : <strong>只要输入为的某一个是1,但不全是都是1,那么按位异或操作生成一个输出位1.(如果两个都为1,则异或的结果位0)</strong></p><p>相反数 : 除了第一个符号位不变外,所有位都取反最后加1</p><h2 id="Integer相关"><a href="#Integer相关" class="headerlink" title="Integer相关"></a>Integer相关</h2><p>Integer.MAX_VALUE =0111,1111,1111,1111,1111,1111,1111,1111. 一共31个1,值为2`31-1;</p><p>Integer.MIN_VALUE= 1000,0000,0000,0000,0000,0000,0000,0000 一共32位,值为-2`31;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Integer.MAX_VALUE+1==Integer.MIN_VALUE);</span><br></pre></td></tr></table></figure></p><p>输出结果为TRUE<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(1&lt;&lt;31==Integer.MIN_VALUE);</span><br></pre></td></tr></table></figure></p><p>输出结果为TRUE</p><h2 id="截尾和舍入"><a href="#截尾和舍入" class="headerlink" title="截尾和舍入"></a>截尾和舍入</h2><p>将float和double转化为整形值时 总是对该数字进行截尾 如29.7 转化为29 0.7转化为0</p><h2 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h2><p>基本类型的运算: 只要类型比int小 运算之前会把值自动转换为int，这样一来，最终生成的结果就是int类型。 <strong>表达式中出现的最大的数据类型决定了表达式最终结果的数据类型</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> java编程思想 </tag>
            
            <tag> 操作符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次防止渗透的措施</title>
      <link href="/2019/01/14/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%98%B2%E6%AD%A2%E6%B8%97%E9%80%8F%E7%9A%84%E6%8E%AA%E6%96%BD/"/>
      <url>/2019/01/14/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%98%B2%E6%AD%A2%E6%B8%97%E9%80%8F%E7%9A%84%E6%8E%AA%E6%96%BD/</url>
      
        <content type="html"><![CDATA[<p><strong>在后端做文件上传的格式校验时,不能只对Content-Type做校验</strong><br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if(!$image = CUploadedFile::getInstanceByName(&apos;upload_file&apos;)) &#123;</span><br><span class="line">            $response[&apos;code&apos;] = -2;</span><br><span class="line">            $response[&apos;msg&apos;]  =  &apos;param error&apos;;</span><br><span class="line">        &#125; else if($image-&gt;getSize() == 0 || $image-&gt;getSize() &gt; 1*1024*1024) &#123;</span><br><span class="line">            $response[&apos;code&apos;] = -3;</span><br><span class="line">            $response[&apos;msg&apos;]  =  &apos;size error&apos;;</span><br><span class="line">        &#125; else if(!in_array($image-&gt;type, array(&apos;image/jpeg&apos;, &apos;image/png&apos;, &apos;image/gif&apos;)))&#123;</span><br><span class="line">            $response[&apos;code&apos;] = -4;</span><br><span class="line">            $response[&apos;msg&apos;]  = &apos;type error&apos;;</span><br><span class="line">        &#125; else if(!$image-&gt;saveAs($local_file.&apos;.&apos;.$image-&gt;extensionName)) &#123;</span><br><span class="line">            $response[&apos;code&apos;] = -5;</span><br><span class="line">            $response[&apos;msg&apos;]  = &apos;file save error&apos;;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>项目原先的代码文件类型处只对Content-Type做了校验,无法防止渗透,<br>测试人员可以通过修改文件后缀名配合BuirSuit等抓包工具在绕过前端验证后删除后缀名达到成功上传其他格式文件的限制</p><blockquote><p>改善措施:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">else if(!in_array($image-&gt;extensionName,array(&apos;jpg&apos;,&apos;jpeg&apos;, &apos;png&apos;, &apos;gif&apos;)))&#123;</span><br><span class="line">            $response[&apos;code&apos;] = -4;</span><br><span class="line">            $response[&apos;msg&apos;]  = &apos;type error&apos;;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>添加对文件后缀名的验证</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP笔记</title>
      <link href="/2019/01/14/PHP%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/01/14/PHP%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-变量"><a href="#1-变量" class="headerlink" title="1. 变量"></a>1. 变量</h2><a id="more"></a><p>变量以\$符号开始，后面跟着变量的名称<br>变量名必须以字母或者下划线字符开始<br>变量名只能包含字母数字字符以及下划线（A-z、0-9 和 _ ）<br>变量名不能包含空格<br>变量名是区分大小写的（$y 和 $Y 是两个不同的变量）</p><h3 id="作用域："><a href="#作用域：" class="headerlink" title="作用域："></a>作用域：</h3><ul><li>local</li><li>global(global 关键字用于函数内访问全局变量)</li><li>static(希望某个局部变量在方法执行完后不删除,则使用static)</li><li>parameter(参数是在参数列表中声明的，作为函数声明的一部分：)</li></ul><h2 id="2-echo-和-print"><a href="#2-echo-和-print" class="headerlink" title="2. echo 和 print"></a>2. echo 和 print</h2><p>echo 和 print 区别:</p><blockquote><p>echo - 可以输出一个或多个字符串(echo “这是一个”, “字符串，”, “使用了”, “多个”, “参数。”;)<br>print - 只允许输出一个字符串，返回值总为 1<br>echo 输出的速度比 print 快， echo 没有返回值，print有返回值1。</p></blockquote><h2 id="3-EOF"><a href="#3-EOF" class="headerlink" title="3. EOF"></a>3. EOF</h2><blockquote><p>PHP EOF(heredoc)是一种在命令行shell（如sh、csh、ksh、bash、PowerShell和zsh）和程序语言（像Perl、PHP、Python和Ruby）里定义一个字串的方法。</p></blockquote><ol><li>必须后接分号，否则编译通不过。</li><li>EOF 可以用任意其它字符代替，只需保证结束标识与开始标识一致。</li><li>结束标识必须顶格独自占一行(即必须从行首开始，前后不能衔接任何空白和字符)。</li><li>开始标识可以不带引号或带单双引号，不带引号与带双引号效果一致，解释内嵌的变量和转义符号，带单引号则不解释内嵌的变量和转义符号。</li><li>当内容需要内嵌引号（单引号或双引号）时，不需要加转义符，本身对单双引号转义，此处相当与q和qq的用法。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo &lt;&lt;&lt;EOF</span><br><span class="line">    &lt;h1&gt;我的第一个标题&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;我的第一个段落。&lt;/p&gt;</span><br><span class="line">EOF;</span><br><span class="line">// 结束需要独立一行且前后不能空格</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p> <strong>EOF 的作用就是按照原样，包括换行格式什么的，输出在其内部的东西；在 PHP 定界符 EOF 中的任何特殊字符都不需要转义；</strong></p><h2 id="4-数据类型"><a href="#4-数据类型" class="headerlink" title="4.数据类型"></a>4.数据类型</h2><p>String（字符串）, Integer（整型）, Float（浮点型）, Boolean（布尔型）, Array（数组）, Object（对象）, NULL（空值）。<br><strong>var_dump() 函数返回变量的数据类型和值：</strong></p><p>PHP 对象:<br>对象数据类型也可以用于存储数据。</p><blockquote><p>在 PHP 中，对象必须声明。<br>首先，必须使用class关键字声明类对象。类是可以包含属性和方法的结构。<br>然后在类中定义数据类型，然后在实例化的类中使用数据类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Car</span><br><span class="line">&#123;</span><br><span class="line">  var $color;</span><br><span class="line">  function __construct($color=&quot;green&quot;) &#123;</span><br><span class="line">    $this-&gt;color = $color;</span><br><span class="line">  &#125;</span><br><span class="line">  function what_color() &#123;</span><br><span class="line">    return $this-&gt;color;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p></blockquote><p>this 就是指向当前对象的指针</p><h2 id="5-常量"><a href="#5-常量" class="headerlink" title="5.常量"></a>5.常量</h2><p>设置常量:</p><pre><code>define(name,value,case_insensitive);</code></pre><p>name：必选参数，常量名称，即标志符。<br>value：必选参数，常量的值。<br>case_insensitive ：可选参数，如果设置为TRUE，该常量则大小写不敏感。默认是大小写敏感的。    </p><p><strong>常量是全局的,常量在定义后，默认是全局变量，可以在整个运行的脚本的任何地方使用。</strong>    </p><h2 id="5-字符串"><a href="#5-字符串" class="headerlink" title="5.字符串"></a>5.字符串</h2><p>PHP 并置运算符:</p><blockquote><p>在 PHP 中，只有一个字符串运算符,并置运算符 (.) 用于把两个字符串值连接起来。</p></blockquote><p>strlen() 函数:</p><blockquote><p>获取长度</p></blockquote><p> strpos() 函数:</p><blockquote><p>strpos() 函数用于在字符串内查找一个字符或一段指定的文本。<br>如果在字符串中找到匹配，该函数会返回第一个匹配的字符位置。如果未找到匹配，则返回 FALSE。</p></blockquote><h2 id="6-运算符"><a href="#6-运算符" class="headerlink" title="6.运算符"></a>6.运算符</h2><p> 优先级： &amp;&amp;  &gt;  =  &gt;  and<br> 优先级： ||  &gt;  =  &gt;  or</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a = 3;</span><br><span class="line">$b = false;</span><br><span class="line">$c = $a or $b;</span><br><span class="line">var_dump($c);          // 这里的 $c 为 int 值3，而不是 boolean 值 true</span><br><span class="line">$d = $a || $b;</span><br><span class="line">var_dump($d);          //这里的 $d 就是 boolean 值 true </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="7-PHP-数组"><a href="#7-PHP-数组" class="headerlink" title="7.PHP 数组"></a>7.PHP 数组</h2><p>PHP一维数组:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);</span><br><span class="line">echo &quot;I like &quot; . $cars[0] . &quot;, &quot; . $cars[1] . &quot; and &quot; . $cars[2] . &quot;.&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p>关联数组:相当于键值对形式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$age=array(&quot;Peter&quot;=&gt;&quot;35&quot;,&quot;Ben&quot;=&gt;&quot;37&quot;,&quot;Joe&quot;=&gt;&quot;43&quot;);</span><br><span class="line">echo &quot;Peter is &quot; . $age[&apos;Peter&apos;] . &quot; years old.&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p>多维数组:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$cars = array</span><br><span class="line">(</span><br><span class="line">//二维数组</span><br><span class="line">array(&quot;Volvo&quot;,100,96),</span><br><span class="line">array(&quot;BMW&quot;,60,59),</span><br><span class="line">array(&quot;Toyota&quot;,110,100)</span><br><span class="line">);</span><br><span class="line">?&gt;</span><br><span class="line">//多维数组</span><br><span class="line">$sites = array</span><br><span class="line">(</span><br><span class="line">    &quot;runoob&quot;=&gt;array</span><br><span class="line">    (</span><br><span class="line">        &quot;菜鸟教程&quot;,</span><br><span class="line">        &quot;http://www.runoob.com&quot;</span><br><span class="line">    ),</span><br><span class="line">    &quot;google&quot;=&gt;array</span><br><span class="line">    (</span><br><span class="line">        &quot;Google 搜索&quot;,</span><br><span class="line">        &quot;http://www.google.com&quot;</span><br><span class="line">    ),</span><br><span class="line">    &quot;taobao&quot;=&gt;array</span><br><span class="line">    (</span><br><span class="line">        &quot;淘宝&quot;,</span><br><span class="line">        &quot;http://www.taobao.com&quot;</span><br><span class="line">    )</span><br><span class="line">);</span><br><span class="line">print(&quot;&lt;pre&gt;&quot;); // 格式化输出数组</span><br><span class="line">print_r($sites);</span><br><span class="line">print(&quot;&lt;/pre&gt;&quot;);</span><br></pre></td></tr></table></figure></p><h2 id="8-PHP超级全局变量"><a href="#8-PHP超级全局变量" class="headerlink" title="8.PHP超级全局变量"></a>8.PHP超级全局变量</h2><ul><li>\$GLOBALS</li><li>\$_SERVER</li><li>\$_REQUEST</li><li>\$_POST</li><li>\$_GET</li><li>\$_FILES</li><li>\$_ENV</li><li>\$_COOKIE</li><li>\$_SESSION</li></ul><h2 id="9-魔术常量"><a href="#9-魔术常量" class="headerlink" title="9.魔术常量"></a>9.魔术常量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo &apos;这是第 &quot; &apos; . __LINE__ . &apos; &quot; 行&apos;;</span><br><span class="line">?&gt;</span><br><span class="line">&lt;?php</span><br><span class="line">echo &apos;该文件位于 &quot; &apos; . __FILE__ . &apos; &quot; &apos;;</span><br><span class="line">?&gt;</span><br><span class="line">&lt;?php</span><br><span class="line">echo &apos;该文件位于 &quot; &apos; . __DIR__ . &apos; &quot; &apos;;</span><br><span class="line">?&gt;</span><br><span class="line">&lt;?php</span><br><span class="line">function test() &#123;</span><br><span class="line">echo &apos;函数名为：&apos; . __FUNCTION__ ;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line">?&gt;</span><br><span class="line">&lt;?php</span><br><span class="line">class test &#123;</span><br><span class="line">function _print() &#123;</span><br><span class="line">echo &apos;类名为：&apos; . __CLASS__ . &quot;&lt;br&gt;&quot;;</span><br><span class="line">echo &apos;函数名为：&apos; . __FUNCTION__ ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">$t = new test();</span><br><span class="line">$t-&gt;_print();</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//trait</span><br><span class="line">&lt;?php</span><br><span class="line">class Base &#123;</span><br><span class="line">public function sayHello() &#123;</span><br><span class="line">echo &apos;Hello &apos;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">trait SayWorld &#123;</span><br><span class="line">public function sayHello() &#123;</span><br><span class="line">parent::sayHello();</span><br><span class="line">echo &apos;World!&apos;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class MyHelloWorld extends Base &#123;</span><br><span class="line">use SayWorld;</span><br><span class="line">&#125;</span><br><span class="line">$o = new MyHelloWorld();</span><br><span class="line">$o-&gt;sayHello();</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">//method</span><br><span class="line">&lt;?php</span><br><span class="line">function test() &#123;</span><br><span class="line">echo &apos;函数名为：&apos; . __METHOD__ ;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">//namespace</span><br><span class="line">&lt;?php</span><br><span class="line">namespace MyProject;</span><br><span class="line">echo &apos;命名空间为：&quot;&apos;, __NAMESPACE__, &apos;&quot;&apos;; // 输出 &quot;MyProject&quot;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="10-命名空间"><a href="#10-命名空间" class="headerlink" title="10.命名空间"></a>10.命名空间</h2><blockquote><p><strong>非限定名称</strong>，或不包含前缀的类名称，例如 $a=new foo(); 或 foo::staticmethod();。如果当前命名空间是 currentnamespace，foo 将被解析为 currentnamespace\foo。如果使用 foo 的代码是全局的，不包含在任何命名空间中的代码，则 foo 会被解析为foo。 警告：如果命名空间中的函数或常量未定义，则该非限定的函数名称或常量名称会被解析为全局函数名称或常量名称。</p></blockquote><blockquote><p><strong>限定名称**</strong>,或包含前缀的名称，例如 $a = new subnamespace\foo(); 或 subnamespace\foo::staticmethod();。如果当前的命名空间是 currentnamespace，则 foo 会被解析为 currentnamespace\subnamespace\foo。如果使用 foo 的代码是全局的，不包含在任何命名空间中的代码，foo 会被解析为subnamespace\foo。</p></blockquote><blockquote><p><strong>完全限定名称</strong>，或包含了全局前缀操作符的名称，例如， $a = new \currentnamespace\foo(); 或 \currentnamespace\foo::staticmethod();。在这种情况下，foo 总是被解析为代码中的文字名(literal name)currentnamespace\foo。</p></blockquote><h2 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a>持续更新…</h2>]]></content>
      
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
