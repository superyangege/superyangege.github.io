{"meta":{"title":"炎の博客","subtitle":"不积跬步无以至千里","description":"广东工业大学-大三-信息与计算科学","author":"LinJiayan","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2019-01-25T08:09:18.000Z","updated":"2019-01-25T08:09:18.465Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-01-25T08:07:15.000Z","updated":"2019-01-25T08:07:15.215Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ElasticSearch笔记","slug":"ElasticSearch笔记","date":"2019-01-25T07:14:02.000Z","updated":"2019-01-25T09:00:56.101Z","comments":true,"path":"2019/01/25/ElasticSearch笔记/","link":"","permalink":"http://yoursite.com/2019/01/25/ElasticSearch笔记/","excerpt":"","text":"全文搜索属于最常见的需求，开源的 Elasticsearch是目前全文搜索引擎的首选。Elastic 的底层是开源库Lucene。但是，无法直接用Lucene，必须写代码去调用它的接口。Elastic 是 Lucene 的封装，提供了 REST API 的操作接口，开箱即用。 安装Elastic 需要 Java 8 环境。1234$ wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.5.1.zip$ unzip elasticsearch-5.5.1.zip$ mv elasticsearch-5.5.1 destination(目标文件夹)$ cd elasticsearch-5.5.1/ 不要把es目录放在 ~目录下,这是root用户的用户目录,后面要切换到自定义用户 下载后在 elasticsearch 根目录下启动。1elasticsearch-2.2.0]# ./bin/elasticsearch 启动时报java内存不足的解决方法 解决办法：1、进入/home/elasticsearch-5.3.1/config2、修改jvm.options 的配置 vim jvm.options3、修改为-Xms512M-Xmx512M 解决之后,继续报错123456Exception in thread &quot;main&quot; java.lang.RuntimeException: don&apos;t run elasticsearch as root. at org.elasticsearch.bootstrap.Bootstrap.initializeNatives(Bootstrap.java:93) at org.elasticsearch.bootstrap.Bootstrap.setup(Bootstrap.java:144) at org.elasticsearch.bootstrap.Bootstrap.init(Bootstrap.java:285) at org.elasticsearch.bootstrap.Elasticsearch.main(Elasticsearch.java:35)Refer to the log for complete error details. 这是版本的问题，最新的版本安全级别提高了，不允许采用root帐号启动，所以我们要添加一个用户。12345678910111213#添加一个用户：elasticsearch$useradd elasticsearch#给用户elasticsearch设置密码，连续输入2次$passwd elasticsearch#创建一个用户组 esgroupadd es#分配 elasticsearch 到 es 组usermod -G elasticsearch es#这里注意下，如果提示用户“es”不存在，那么是因为服务器版本问题，你可以换成 usermod -G es elasticsearch ,也就是用户和用户组对调一下使用。#在elasticsearch 根目录下，给定用户权限。-R表示逐级（N层目录） ， * 表示 任何文件chown -R elasticsearch.es *#切换到elasticsearch用户su elasticsearch 基本概念Node 与 ClusterElastic 本质上是一个分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个 Elastic 实例。单个 Elastic 实例称为一个节点（node）。一组节点构成一个集群（cluster）。 IndexElastic 会索引所有字段，经过处理后写入一个反向索引（Inverted Index）。查找数据的时候，直接查找该索引。所以，Elastic 数据管理的顶层单位就叫做 Index（索引）。它是单个数据库的同义词。每个 Index （即数据库）的名字必须是小写。下面的命令可以查看当前节点的所有 Index。1$ curl -X GET &apos;http://localhost:9200/_cat/indices?v&apos; DocumentIndex 里面单条的记录称为 Document（文档）。许多条 Document 构成了一个 Index。Document 使用 JSON 格式表示，下面是一个例子。12345&#123; &quot;user&quot;: &quot;张三&quot;, &quot;title&quot;: &quot;工程师&quot;, &quot;desc&quot;: &quot;数据库管理&quot;&#125; 同一个 Index 里面的 Document，不要求有相同的结构（scheme），但是最好保持相同，这样有利于提高搜索效率。 TypeDocument 可以分组，比如weather这个Index里面，可以按城市分组（北京和上海），也可以按气候分组（晴天和雨天）。这种分组就叫做Type，它是虚拟的逻辑分组，用来过滤 Document。不同的 Type 应该有相似的结构（schema），举例来说，id字段不能在这个组是字符串，在另一个组是数值。这是与关系型数据库的表的一个区别。性质完全不同的数据（比如products和logs）应该存成两个 Index，而不是一个 Index 里面的两个 Type（虽然可以做到）。下面的命令可以列出每个 Index 所包含的 Type。1$ curl &apos;localhost:9200/_mapping?pretty=true&apos; pretty=true 表示让返回结果的显示格式更美观 新建和删除 Index新建 Index1$ curl -X PUT &apos;localhost:9200/weather&apos; 服务器返回一个 JSON 对象，里面的acknowledged字段表示操作成功。1234&#123; &quot;acknowledged&quot;:true, &quot;shards_acknowledged&quot;:true&#125; 然后，我们发出 DELETE 请求，删除这个 Index。1$ curl -X DELETE &apos;localhost:9200/weather&apos; 中文分词设置安装中文分词插件。使用 ik1./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v5.5.1/elasticsearch-analysis-ik-5.5.1.zip 重新启动 Elastic，会自动加载这个新安装的插件 新建一个 Index，指定需要分词的字段。这一步根据数据结构而异，基本上，凡是需要搜索的中文字段，都要单独设置一下。123456789101112131415161718192021222324$ curl -X PUT &apos;localhost:9200/accounts&apos; -d &apos;&#123; &quot;mappings&quot;: &#123; &quot;person&quot;: &#123; &quot;properties&quot;: &#123; &quot;user&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;search_analyzer&quot;: &quot;ik_max_word&quot; &#125;, &quot;title&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;search_analyzer&quot;: &quot;ik_max_word&quot; &#125;, &quot;desc&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;search_analyzer&quot;: &quot;ik_max_word&quot; &#125; &#125; &#125; &#125;&#125;&apos; 以上是新建一个名称为accounts的 Index，里面有一个名称为person的 Type。person有三个字段 user title desc而且类型都是文本（text），所以需要指定中文分词器，不能使用默认的英文分词器。lastic 的分词器称为 analyzer。对每个字段指定分词器。12345&quot;user&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;search_analyzer&quot;: &quot;ik_max_word&quot;&#125; 上面代码中，analyzer是字段文本的分词器，search_analyzer是搜索词的分词器。ik_max_word分词器是插件ik提供的，可以对文本进行最大数量的分词。 数据操作### 新增记录 向指定的 /Index/Type 发送 PUT 请求，就可以在 Index 里面新增一条记录。比如，向/accounts/person发送请求，就可以新增一条人员记录。123456$ curl -X PUT &apos;localhost:9200/accounts/person/1&apos; -d &apos;&#123; &quot;user&quot;: &quot;张三&quot;, &quot;title&quot;: &quot;工程师&quot;, &quot;desc&quot;: &quot;数据库管理&quot;&#125;&apos; 服务器返回的 JSON 对象，会给出 Index、Type、Id、Version 等信息。123456789&#123; &quot;_index&quot;:&quot;accounts&quot;, &quot;_type&quot;:&quot;person&quot;, &quot;_id&quot;:&quot;1&quot;, &quot;_version&quot;:1, &quot;result&quot;:&quot;created&quot;, &quot;_shards&quot;:&#123;&quot;total&quot;:2,&quot;successful&quot;:1,&quot;failed&quot;:0&#125;, &quot;created&quot;:true&#125; 请求路径是/accounts/person/1，最后的1是该条记录的Id。它不一定是数字，任意字符串（比如abc）都可以。新增记录的时候，也可以不指定 Id，这时要改成 POST 请求。123456$ curl -X POST &apos;localhost:9200/accounts/person&apos; -d &apos;&#123; &quot;user&quot;: &quot;李四&quot;, &quot;title&quot;: &quot;工程师&quot;, &quot;desc&quot;: &quot;系统管理&quot;&#125;&apos; 向/accounts/person发出一个 POST 请求，添加一个记录。这时，服务器返回的 JSON 对象里面，_id字段就是一个随机字符串。123456789&#123; &quot;_index&quot;:&quot;accounts&quot;, &quot;_type&quot;:&quot;person&quot;, &quot;_id&quot;:&quot;AV3qGfrC6jMbsbXb6k1p&quot;, &quot;_version&quot;:1, &quot;result&quot;:&quot;created&quot;, &quot;_shards&quot;:&#123;&quot;total&quot;:2,&quot;successful&quot;:1,&quot;failed&quot;:0&#125;, &quot;created&quot;:true&#125; 注意，如果没有先创建 Index（这个例子是accounts），直接执行上面的命令，Elastic 也不会报错，而是直接生成指定的 Index。 查看记录向/Index/Type/Id发出 GET 请求，就可以查看这条记录。1$ curl &apos;localhost:9200/accounts/person/1?pretty=true&apos; 上面代码请求查看/accounts/person/1这条记录，URL 的参数pretty=true表示以易读的格式返回。返回的数据中，found字段表示查询成功，_source字段返回原始记录。123456789101112&#123; &quot;_index&quot; : &quot;accounts&quot;, &quot;_type&quot; : &quot;person&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_version&quot; : 1, &quot;found&quot; : true, &quot;_source&quot; : &#123; &quot;user&quot; : &quot;张三&quot;, &quot;title&quot; : &quot;工程师&quot;, &quot;desc&quot; : &quot;数据库管理&quot; &#125;&#125; 如果 Id 不正确，就查不到数据，found字段就是false。12345678$ curl &apos;localhost:9200/weather/beijing/abc?pretty=true&apos;&#123; &quot;_index&quot; : &quot;accounts&quot;, &quot;_type&quot; : &quot;person&quot;, &quot;_id&quot; : &quot;abc&quot;, &quot;found&quot; : false&#125; 删除记录1$ curl -X DELETE &apos;localhost:9200/accounts/person/1&apos; 更新记录更新记录就是使用 PUT 请求，重新发送一次数据。12345678910111213141516$ curl -X PUT &apos;localhost:9200/accounts/person/1&apos; -d &apos;&#123; &quot;user&quot; : &quot;张三&quot;, &quot;title&quot; : &quot;工程师&quot;, &quot;desc&quot; : &quot;数据库管理，软件开发&quot;&#125;&apos; &#123; &quot;_index&quot;:&quot;accounts&quot;, &quot;_type&quot;:&quot;person&quot;, &quot;_id&quot;:&quot;1&quot;, &quot;_version&quot;:2, &quot;result&quot;:&quot;updated&quot;, &quot;_shards&quot;:&#123;&quot;total&quot;:2,&quot;successful&quot;:1,&quot;failed&quot;:0&#125;, &quot;created&quot;:false&#125; 上面代码中，我们将原始数据从”数据库管理”改成”数据库管理，软件开发”。 返回结果里面，几个字段发生了变化。123&quot;_version&quot; : 2,&quot;result&quot; : &quot;updated&quot;,&quot;created&quot; : false 记录的 Id 没变，但是版本（version）从1变成2，操作类型（result）从created变成updated，created字段变成false，因为这次不是新建记录。 数据查询返回所有记录使用 GET 方法，直接请求/Index/Type/_search，就会返回所有记录。1234567891011121314151617181920212223242526272829303132333435$ curl &apos;localhost:9200/accounts/person/_search&apos;&#123; &quot;took&quot;:2, &quot;timed_out&quot;:false, &quot;_shards&quot;:&#123;&quot;total&quot;:5,&quot;successful&quot;:5,&quot;failed&quot;:0&#125;, &quot;hits&quot;:&#123; &quot;total&quot;:2, &quot;max_score&quot;:1.0, &quot;hits&quot;:[ &#123; &quot;_index&quot;:&quot;accounts&quot;, &quot;_type&quot;:&quot;person&quot;, &quot;_id&quot;:&quot;AV3qGfrC6jMbsbXb6k1p&quot;, &quot;_score&quot;:1.0, &quot;_source&quot;: &#123; &quot;user&quot;: &quot;李四&quot;, &quot;title&quot;: &quot;工程师&quot;, &quot;desc&quot;: &quot;系统管理&quot; &#125; &#125;, &#123; &quot;_index&quot;:&quot;accounts&quot;, &quot;_type&quot;:&quot;person&quot;, &quot;_id&quot;:&quot;1&quot;, &quot;_score&quot;:1.0, &quot;_source&quot;: &#123; &quot;user&quot; : &quot;张三&quot;, &quot;title&quot; : &quot;工程师&quot;, &quot;desc&quot; : &quot;数据库管理，软件开发&quot; &#125; &#125; ] &#125;&#125; took字段表示该操作的耗时（单位为毫秒），timed_out字段表示是否超时，hits字段表示命中的记录，里面子字段的含义如下。 total：返回记录数，本例是2条。max_score：最高的匹配程度，本例是1.0。hits：返回的记录组成的数组。返回的记录中，每条记录都有一个_score字段，表示匹配的程序，默认是按照这个字段降序排列。 全文搜索 使用GET 请求并带有数据体。1234$ curl &apos;localhost:9200/accounts/person/_search&apos; -d &apos;&#123; &quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;desc&quot; : &quot;软件&quot; &#125;&#125;&#125;&apos; 上面代码使用 Match查询，指定的匹配条件是desc字段里面包含”软件“这个词。返回结果如下。12345678910111213141516171819202122&#123; &quot;took&quot;:3, &quot;timed_out&quot;:false, &quot;_shards&quot;:&#123;&quot;total&quot;:5,&quot;successful&quot;:5,&quot;failed&quot;:0&#125;, &quot;hits&quot;:&#123; &quot;total&quot;:1, &quot;max_score&quot;:0.28582606, &quot;hits&quot;:[ &#123; &quot;_index&quot;:&quot;accounts&quot;, &quot;_type&quot;:&quot;person&quot;, &quot;_id&quot;:&quot;1&quot;, &quot;_score&quot;:0.28582606, &quot;_source&quot;: &#123; &quot;user&quot; : &quot;张三&quot;, &quot;title&quot; : &quot;工程师&quot;, &quot;desc&quot; : &quot;数据库管理，软件开发&quot; &#125; &#125; ] &#125;&#125; 可以通过size字段改变这个返回的条数,默认10条。12345$ curl &apos;localhost:9200/accounts/person/_search&apos; -d &apos;&#123; &quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;desc&quot; : &quot;管理&quot; &#125;&#125;, &quot;size&quot;: 1&#125;&apos; 可以通过from字段指定位移123456$ curl &apos;localhost:9200/accounts/person/_search&apos; -d &apos;&#123; &quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;desc&quot; : &quot;管理&quot; &#125;&#125;, &quot;from&quot;: 1, &quot;size&quot;: 1&#125;&apos; 从位置1开始（默认是从位置0开始），只返回一条结果。 逻辑运算如果有多个搜索关键字， Elastic 认为它们是or关系。1234$ curl &apos;localhost:9200/accounts/person/_search&apos; -d &apos;&#123; &quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;desc&quot; : &quot;软件 系统&quot; &#125;&#125;&#125;&apos; 上面代码搜索的是软件 or 系统。如果要执行多个关键词的and搜索，必须使用布尔查询。1234567891011$ curl &apos;localhost:9200/accounts/person/_search&apos; -d &apos;&#123; &quot;query&quot;: &#123; &quot;bool&quot;: &#123; &quot;must&quot;: [ &#123; &quot;match&quot;: &#123; &quot;desc&quot;: &quot;软件&quot; &#125; &#125;, &#123; &quot;match&quot;: &#123; &quot;desc&quot;: &quot;系统&quot; &#125; &#125; ] &#125; &#125;&#125;&apos;","categories":[],"tags":[{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"http://yoursite.com/tags/ElasticSearch/"}]},{"title":"java实现动态代理","slug":"java实现动态代理","date":"2019-01-19T11:04:56.000Z","updated":"2019-01-25T07:29:11.324Z","comments":true,"path":"2019/01/19/java实现动态代理/","link":"","permalink":"http://yoursite.com/2019/01/19/java实现动态代理/","excerpt":"java的动态代理机制中，有两个重要的类或接口，一个是 InvocationHandler(Interface)、另一个是 Proxy(Class)","text":"java的动态代理机制中，有两个重要的类或接口，一个是 InvocationHandler(Interface)、另一个是 Proxy(Class) InvocationHandler: InvocationHandler is the interface implemented by the invocation handler of a proxy instance.InvocationHandler是代理实例的调用处理程序实现的接口Each proxy instance has an associated invocation handler. When a method is invoked on a proxy instance, the method invocation is encoded and dispatched to the invoke method of its invocation handler.每个代理实例都有一个关联的调用处理程序。在代理实例上调用方法时，方法调用将被编码并发送到其调用处理程序的invoke方法。 invoke方法12345Object invoke(Object proxy, Method method, Object[] args) throws Throwableproxy: 指代我们所代理的那个真实对象method: 指代的是我们所要调用真实对象的某个方法的Method对象args: 指代的是调用真实对象某个方法时接受的参数 newProxyInstanceProxy这个类的作用就是用来动态创建一个代理对象的类，它提供了许多的方法，用的最多的就是 newProxyInstance 这个方法1234567public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentExceptionloader: 一个ClassLoader对象，定义了由哪个ClassLoader对象来对生成的代理对象进行加载interfaces: 一个Interface对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了h: 一个InvocationHandler对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上 实现1.定义一个Subject类型的接口12345public interface Subject &#123;//定义了两个方法 public void rent(); public void hello(String str);&#125; 2.定义一个类来实现这个接口，这个类就是真实对象，RealSubject类：1234567891011public class RealSubject implements Subject&#123; @Override public void rent() &#123; System.out.println(&quot;I want to rent&quot;); &#125; @Override public void hello(String str) &#123; System.out.println(&quot;hello: &quot; + str); &#125;&#125; 3.定义一个动态代理类，每一个动态代理类都必须要实现 InvocationHandler123456789101112131415161718192021222324import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class DynamicProxy implements InvocationHandler &#123; // 这个就是我们要代理的真实对象 private Object subject; // 构造方法，给我们要代理的真实对象赋初值 public DynamicProxy(Object subject) &#123; this.subject = subject; &#125; @Override public Object invoke(Object object, Method method, Object[] args) throws Throwable &#123; //在代理真实对象前我们可以添加一些自己的操作 System.out.println(&quot;before rent house&quot;); System.out.println(&quot;Method: &quot;+method); //此时是调用真实对象的方法 method.invoke(subject,args); //代理后同样可以添加一些操作 //doSomething(); return null; &#125;&#125; Client类1234567891011121314151617181920212223242526272829import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;public class Client &#123; public static void main(String[] args)&#123; // 要代理的真实对象 RealSubject realSubject = new RealSubject(); // 要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法的 InvocationHandler handler = new DynamicProxy(realSubject); Subject subject =(Subject) Proxy.newProxyInstance( realSubject.getClass().getClassLoader(),//真实类的类加载器 realSubject.getClass().getInterfaces(),//被代理类的接口 handler//代理对象 ); System.out.println(subject.getClass().getName()); subject.rent(); subject.hello(&quot;The world will become better&quot;); &#125;&#125;输出:com.sun.proxy.$Proxy0before rent houseMethod: public abstract void 动态代理.Subject.rent()I want to rentbefore rent houseMethod: public abstract void 动态代理.Subject.hello(java.lang.String)hello: The world will become better 通过 Proxy.newProxyInstance 创建的代理对象subject是在jvm运行时动态生成的一个对象，它并不是InvocationHandler类型，也不是我们定义的那组接口的类型，而是在运行时动态生成的一个对象，并且命名方式都是这样的形式，以$开头，proxy为中，最后一个数字表示对象的标号。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"动态代理","slug":"动态代理","permalink":"http://yoursite.com/tags/动态代理/"}]},{"title":"spring相关","slug":"spring相关","date":"2019-01-19T09:45:30.000Z","updated":"2019-01-25T07:29:37.456Z","comments":true,"path":"2019/01/19/spring相关/","link":"","permalink":"http://yoursite.com/2019/01/19/spring相关/","excerpt":"IOC/DI","text":"IOC/DI 1. 概念及原理 IOC: Inversion of Control(控制反转)是一种设计思想,利用了工厂模式。对象及其依赖对象的创建及维护都不需要在应用程序中实现，将其交给IOC容器去管理。传统的开发中，我们自己在对象内部创建依赖对象并注入当前对象，完成依赖关系的维护；对于IOC而言，强调将主动变为被动，由IOC容器来负责依赖对象的创建和查找，由IOC容器来进行注入组合对象，只需要在相关的配置文件中维护对象之间的依赖关系即可。 DI: Dependency Injection，即“依赖注入”。其实IOC和DI本就是同一个概念的两种不同的表述，应用程序依赖容器提供的外部对象，容器将其依赖的外部资源在运行期注入到应用程序中；某个对象被调用时，其所依赖的对象由容器注入。 2.AOP AOP利用一种称为“横切”的技术，剖解开封装的对象内部，将那些影响多个类的公共行为封装到一个可重用模块，并将其名为切面(Aspect)。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑封装起来的部分。以便于减少系统的重复代码，降低模块间的耦合度，并有利于系统维护。 使用“横切”技术，AOP把软件系统分为两个部分：核心关注点（业务逻辑）和横切关注点（通用逻辑，即方面）。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的特点是，其经常发生在核心关注点的多处，而各处都基本相似。比如权限认证、日志、事务处理，debug管理，性能检测等。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。","categories":[],"tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"第十章 内部类","slug":"第十章-内部类","date":"2019-01-17T02:52:05.000Z","updated":"2019-01-25T07:29:50.401Z","comments":true,"path":"2019/01/17/第十章-内部类/","link":"","permalink":"http://yoursite.com/2019/01/17/第十章-内部类/","excerpt":"了解外围类,并且能与之通信","text":"了解外围类,并且能与之通信 内部类能访问其外围对象的所有成员而不需要任何特殊条件，当某个外围类对象创建了一个内部类对象时，此内部类对象必定会秘密地捕获一个指向那个外部类对象的引用，然后在你访问此外围类的成员时,就是用那个引用来选择外围的成员。使用.this 和.new需要需要生成对外部类对象的引用,可以使用外部类的名字后紧跟原点和this.1234567891011121314151617public class DotThis&#123; void f()&#123;System.out.println(&quot;DotThis.f()&quot;);&#125; public class Inner&#123; public class DotThis outer()&#123; return DotThis.this; &#125; &#125; public Inner inner()&#123;return new TInner();&#125; public static void main(String[] args)&#123; DotThis dt = new DotThis(); DotThis.Inner dti = dt.inner(); dti.outer().f(); &#125;&#125;/*Output:DotThis.f()*/ 直接创建内部类的对象:在ner表达式中提供对其外部类对象的引用12DotNew dn = new DotNew();DotNew.Inner dni = dn.new Inner(); 匿名内部类如果定义一个匿名内部类,并且希望它日用外部定义的对象,那么编译器会要求其参数引用为final123456789101112public interface Destination&#123; String readLabel();&#125;public class Parcel9&#123; public Destination destination(final String dest)&#123; return new Destination()&#123; private String label = dest; public String readLabel()&#123;return label&#125; &#125;; &#125;&#125; 这里引用了外部类的String对象dest,所以要求参数引用必须为final 嵌套类(static)如果不需要内部类与外围类对象之间有练习,可以将内部类声明为static普通内部类与static的嵌套类的区别: 1.创建嵌套类的对象,并不需要其外围类的对象.2.不能从嵌套类的对象中访问非静态的外围类对象.3.普通的内部类不能有static数据和static字段,也不能包含嵌套类,即(内部类中还有内部类),而嵌套类(static)可以做到. 接口内部的类正常情况下,不能在接口内置任何代码,但嵌套类可以作为接口的一部分,放置到接口中的任何类都自动是public 和 static的.因为类是static的,只是将嵌套类置于接口的命名空间,并不违反接口的规则. 甚至可以在内部类中实现其外围接口 从多层嵌套类访问外部成员内部类—可以透明地访问所有它的外围成员(不论是不是private)嵌套内部类—可以透明地访问它所嵌入的外围类的所有成员12345678910111213141516171819class MNA&#123; private void f()&#123;&#125; class A&#123; private void g()&#123;&#125; public class B&#123; void h()&#123; g(); f(); &#125; &#125; &#125;&#125;public class MultiNestingAccess&#123; public static void main(String[] args)&#123; MNA mna = new MNA(); MNA.A mnaa = mna.new A(); MNA.A.B mnaab = mnaa.new B(); &#125;&#125; 可以看到在MNA,A,A中, 调用方法g()和f()并不需要任何条件(即使被声明为private)","categories":[],"tags":[{"name":"java编程思想","slug":"java编程思想","permalink":"http://yoursite.com/tags/java编程思想/"},{"name":"内部类","slug":"内部类","permalink":"http://yoursite.com/tags/内部类/"}]},{"title":"git常用命令","slug":"git常用命令","date":"2019-01-16T12:08:04.000Z","updated":"2019-01-25T07:28:52.763Z","comments":true,"path":"2019/01/16/git常用命令/","link":"","permalink":"http://yoursite.com/2019/01/16/git常用命令/","excerpt":"git clone url 克隆项目到本地","text":"git clone url 克隆项目到本地 git push 提交git branch 显示所有分支git status 查看修改的内容git add . 确认所有修改git commit -m “这里是注释”git diff 显示差别git log 查看提交的日志git rebase -i [startpoint] [endpoint] 其中-i的意思是–interactive，即弹出交互式的界面让用户编辑完成合并操作，[startpoint] [endpoint]则指定了一个编辑区间，如果不指定[endpoint]，则该区间的终点默认是当前分支HEAD所指向的commit fetch更新本地仓库两种方式1234567891011121314//方法一$ git fetch origin master //从远程的origin仓库的master分支下载代码到本地的origin master$ git log -p master.. origin/master//比较本地的仓库和远程参考的区别$ git merge origin/master//把远程下载下来的代码合并到本地仓库，远程的和本地的合并//方法二$ git fetch origin master:temp //从远程的origin仓库的master分支下载到本地并新建一个分支temp$ git diff temp//比较master分支和temp分支的不同$ git merge temp//合并temp分支到master分支$ git branch -d temp//删除temp","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"Java基础笔记","slug":"Java基础零散笔记","date":"2019-01-15T07:55:12.000Z","updated":"2019-01-25T07:31:18.636Z","comments":true,"path":"2019/01/15/Java基础零散笔记/","link":"","permalink":"http://yoursite.com/2019/01/15/Java基础零散笔记/","excerpt":"1.URL u =new URL(“http://www.123.com&quot;);。如果www.123.com不存在，则返回______。","text":"1.URL u =new URL(“http://www.123.com&quot;);。如果www.123.com不存在，则返回______。result:返回’http://www.123.com&#39;,我们在执行URL u =new URL(“http://www.123.com&quot;);这句话的时候确实要抛出异常，但是这个异常属于IOException，不管网址是否存在，最后都会返回该网址的一个连接，打印出来就是该网址。 2.新建的线程调用start()方法就能立即进行运行状态result:错误,调用start()后让thread进去可运行状态（runnable），只是等待获取CPU的使用权。 3. CountDownLatch：允许一个或多个线程等待其他线程完成操作； CyclicBarrier：同步屏障，让一组线程到达一个屏障时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会执行。 4. String str1 = &quot;hello&quot;; String str2 = &quot;he&quot;+new String(&quot;llo&quot;); System.out.println(str1==str2); //false, 5.java中的true,false,null不是关键字,只是一些显式常量值 6.异常相关 运行时异常： 都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。 运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。非运行时异常 （编译异常）： 是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。 7.类的加载 父类静态域(static修饰)=&gt;子类静态域(static修饰)=&gt;父类成员和构造块=&gt;父类的构造方法&gt;=子类的成员和构造代码块&gt;=子类的构造方法 普通成员变量和普通代码块是同级的 执行按照先后顺序进行 8.abstract和final abstract和final不能用来修饰同一个类abstract类中可以没有抽象方法，接口中也可以有abstract方法。 9.servlet周期包括__. init() –&gt; 初始化service() –&gt; 处理请求destory () –&gt; 销毁 10.下面哪个语句是创建数组的正确语句？( )A.float f[][] = new float[6][6];B.float []f[] = new float[6][6];C.float f[][] = new float[][6];D.float [][]f = new float[6][6];E.float [][]f = new float[6][]; result:ABDE ABDE都可以。也就是说数组命名时名称与[]可以随意排列，但声明的二维数组中第一个中括号中必须要有值，它代表的是在该二维数组中有多少个一维数组。阿里规范里，数组严禁使用int a[][] 等形式，应当使用int[][] a 的可读性较强的形式","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"第三章 操作符","slug":"第三章-操作符","date":"2019-01-15T02:51:54.000Z","updated":"2019-01-25T07:29:42.474Z","comments":true,"path":"2019/01/15/第三章-操作符/","link":"","permalink":"http://yoursite.com/2019/01/15/第三章-操作符/","excerpt":"逻辑操作符:","text":"逻辑操作符: 逻辑操作符使用双位字符(&amp;&amp;或者||) 按位操作符:按位与 : &amp; 按位或 : | ~符号 : 每一位都取反 ^异或操作符 : 只要输入为的某一个是1,但不全是都是1,那么按位异或操作生成一个输出位1.(如果两个都为1,则异或的结果位0) 相反数 : 除了第一个符号位不变外,所有位都取反最后加1 Integer相关Integer.MAX_VALUE =0111,1111,1111,1111,1111,1111,1111,1111. 一共31个1,值为2`31-1; Integer.MIN_VALUE= 1000,0000,0000,0000,0000,0000,0000,0000 一共32位,值为-2`31;1System.out.println(Integer.MAX_VALUE+1==Integer.MIN_VALUE); 输出结果为TRUE1System.out.println(1&lt;&lt;31==Integer.MIN_VALUE); 输出结果为TRUE 截尾和舍入将float和double转化为整形值时 总是对该数字进行截尾 如29.7 转化为29 0.7转化为0 提升基本类型的运算: 只要类型比int小 运算之前会把值自动转换为int，这样一来，最终生成的结果就是int类型。 表达式中出现的最大的数据类型决定了表达式最终结果的数据类型","categories":[],"tags":[{"name":"java编程思想","slug":"java编程思想","permalink":"http://yoursite.com/tags/java编程思想/"},{"name":"操作符","slug":"操作符","permalink":"http://yoursite.com/tags/操作符/"}]},{"title":"记一次防止渗透的措施","slug":"记一次防止渗透的措施","date":"2019-01-14T14:47:28.000Z","updated":"2019-01-25T07:29:58.798Z","comments":true,"path":"2019/01/14/记一次防止渗透的措施/","link":"","permalink":"http://yoursite.com/2019/01/14/记一次防止渗透的措施/","excerpt":"在后端做文件上传的格式校验时,不能只对Content-Type做校验","text":"在后端做文件上传的格式校验时,不能只对Content-Type做校验12345678910111213if(!$image = CUploadedFile::getInstanceByName(&apos;upload_file&apos;)) &#123; $response[&apos;code&apos;] = -2; $response[&apos;msg&apos;] = &apos;param error&apos;; &#125; else if($image-&gt;getSize() == 0 || $image-&gt;getSize() &gt; 1*1024*1024) &#123; $response[&apos;code&apos;] = -3; $response[&apos;msg&apos;] = &apos;size error&apos;; &#125; else if(!in_array($image-&gt;type, array(&apos;image/jpeg&apos;, &apos;image/png&apos;, &apos;image/gif&apos;)))&#123; $response[&apos;code&apos;] = -4; $response[&apos;msg&apos;] = &apos;type error&apos;; &#125; else if(!$image-&gt;saveAs($local_file.&apos;.&apos;.$image-&gt;extensionName)) &#123; $response[&apos;code&apos;] = -5; $response[&apos;msg&apos;] = &apos;file save error&apos;; &#125; 项目原先的代码文件类型处只对Content-Type做了校验,无法防止渗透,测试人员可以通过修改文件后缀名配合BuirSuit等抓包工具在绕过前端验证后删除后缀名达到成功上传其他格式文件的限制 改善措施:1234else if(!in_array($image-&gt;extensionName,array(&apos;jpg&apos;,&apos;jpeg&apos;, &apos;png&apos;, &apos;gif&apos;)))&#123; $response[&apos;code&apos;] = -4; $response[&apos;msg&apos;] = &apos;type error&apos;; &#125; 添加对文件后缀名的验证","categories":[],"tags":[{"name":"记","slug":"记","permalink":"http://yoursite.com/tags/记/"}]},{"title":"PHP笔记","slug":"PHP笔记","date":"2019-01-14T12:45:53.000Z","updated":"2019-01-25T07:29:27.067Z","comments":true,"path":"2019/01/14/PHP笔记/","link":"","permalink":"http://yoursite.com/2019/01/14/PHP笔记/","excerpt":"1. 变量","text":"1. 变量 变量以\\$符号开始，后面跟着变量的名称变量名必须以字母或者下划线字符开始变量名只能包含字母数字字符以及下划线（A-z、0-9 和 _ ）变量名不能包含空格变量名是区分大小写的（$y 和 $Y 是两个不同的变量） 作用域： local global(global 关键字用于函数内访问全局变量) static(希望某个局部变量在方法执行完后不删除,则使用static) parameter(参数是在参数列表中声明的，作为函数声明的一部分：) 2. echo 和 printecho 和 print 区别: echo - 可以输出一个或多个字符串(echo “这是一个”, “字符串，”, “使用了”, “多个”, “参数。”;)print - 只允许输出一个字符串，返回值总为 1echo 输出的速度比 print 快， echo 没有返回值，print有返回值1。 3. EOF PHP EOF(heredoc)是一种在命令行shell（如sh、csh、ksh、bash、PowerShell和zsh）和程序语言（像Perl、PHP、Python和Ruby）里定义一个字串的方法。 必须后接分号，否则编译通不过。 EOF 可以用任意其它字符代替，只需保证结束标识与开始标识一致。 结束标识必须顶格独自占一行(即必须从行首开始，前后不能衔接任何空白和字符)。 开始标识可以不带引号或带单双引号，不带引号与带双引号效果一致，解释内嵌的变量和转义符号，带单引号则不解释内嵌的变量和转义符号。 当内容需要内嵌引号（单引号或双引号）时，不需要加转义符，本身对单双引号转义，此处相当与q和qq的用法。 1234567&lt;?phpecho &lt;&lt;&lt;EOF &lt;h1&gt;我的第一个标题&lt;/h1&gt; &lt;p&gt;我的第一个段落。&lt;/p&gt;EOF;// 结束需要独立一行且前后不能空格?&gt; EOF 的作用就是按照原样，包括换行格式什么的，输出在其内部的东西；在 PHP 定界符 EOF 中的任何特殊字符都不需要转义； 4.数据类型String（字符串）, Integer（整型）, Float（浮点型）, Boolean（布尔型）, Array（数组）, Object（对象）, NULL（空值）。var_dump() 函数返回变量的数据类型和值： PHP 对象:对象数据类型也可以用于存储数据。 在 PHP 中，对象必须声明。首先，必须使用class关键字声明类对象。类是可以包含属性和方法的结构。然后在类中定义数据类型，然后在实例化的类中使用数据类型：123456789101112&lt;?phpclass Car&#123; var $color; function __construct($color=&quot;green&quot;) &#123; $this-&gt;color = $color; &#125; function what_color() &#123; return $this-&gt;color; &#125;&#125;?&gt; this 就是指向当前对象的指针 5.常量设置常量: define(name,value,case_insensitive); name：必选参数，常量名称，即标志符。value：必选参数，常量的值。case_insensitive ：可选参数，如果设置为TRUE，该常量则大小写不敏感。默认是大小写敏感的。 常量是全局的,常量在定义后，默认是全局变量，可以在整个运行的脚本的任何地方使用。 5.字符串PHP 并置运算符: 在 PHP 中，只有一个字符串运算符,并置运算符 (.) 用于把两个字符串值连接起来。 strlen() 函数: 获取长度 strpos() 函数: strpos() 函数用于在字符串内查找一个字符或一段指定的文本。如果在字符串中找到匹配，该函数会返回第一个匹配的字符位置。如果未找到匹配，则返回 FALSE。 6.运算符 优先级： &amp;&amp; &gt; = &gt; and 优先级： || &gt; = &gt; or 12345678&lt;?php$a = 3;$b = false;$c = $a or $b;var_dump($c); // 这里的 $c 为 int 值3，而不是 boolean 值 true$d = $a || $b;var_dump($d); //这里的 $d 就是 boolean 值 true ?&gt; 7.PHP 数组PHP一维数组:1234&lt;?php$cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);echo &quot;I like &quot; . $cars[0] . &quot;, &quot; . $cars[1] . &quot; and &quot; . $cars[2] . &quot;.&quot;;?&gt; 关联数组:相当于键值对形式1234&lt;?php$age=array(&quot;Peter&quot;=&gt;&quot;35&quot;,&quot;Ben&quot;=&gt;&quot;37&quot;,&quot;Joe&quot;=&gt;&quot;43&quot;);echo &quot;Peter is &quot; . $age[&apos;Peter&apos;] . &quot; years old.&quot;;?&gt; 多维数组:12345678910111213141516171819202122232425262728293031&lt;?php$cars = array(//二维数组array(&quot;Volvo&quot;,100,96),array(&quot;BMW&quot;,60,59),array(&quot;Toyota&quot;,110,100));?&gt;//多维数组$sites = array( &quot;runoob&quot;=&gt;array ( &quot;菜鸟教程&quot;, &quot;http://www.runoob.com&quot; ), &quot;google&quot;=&gt;array ( &quot;Google 搜索&quot;, &quot;http://www.google.com&quot; ), &quot;taobao&quot;=&gt;array ( &quot;淘宝&quot;, &quot;http://www.taobao.com&quot; ));print(&quot;&lt;pre&gt;&quot;); // 格式化输出数组print_r($sites);print(&quot;&lt;/pre&gt;&quot;); 8.PHP超级全局变量 \\$GLOBALS \\$_SERVER \\$_REQUEST \\$_POST \\$_GET \\$_FILES \\$_ENV \\$_COOKIE \\$_SESSION 9.魔术常量123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?phpecho &apos;这是第 &quot; &apos; . __LINE__ . &apos; &quot; 行&apos;;?&gt;&lt;?phpecho &apos;该文件位于 &quot; &apos; . __FILE__ . &apos; &quot; &apos;;?&gt;&lt;?phpecho &apos;该文件位于 &quot; &apos; . __DIR__ . &apos; &quot; &apos;;?&gt;&lt;?phpfunction test() &#123;echo &apos;函数名为：&apos; . __FUNCTION__ ;&#125;test();?&gt;&lt;?phpclass test &#123;function _print() &#123;echo &apos;类名为：&apos; . __CLASS__ . &quot;&lt;br&gt;&quot;;echo &apos;函数名为：&apos; . __FUNCTION__ ;&#125;&#125;$t = new test();$t-&gt;_print();?&gt;//trait&lt;?phpclass Base &#123;public function sayHello() &#123;echo &apos;Hello &apos;;&#125;&#125;trait SayWorld &#123;public function sayHello() &#123;parent::sayHello();echo &apos;World!&apos;;&#125;&#125;class MyHelloWorld extends Base &#123;use SayWorld;&#125;$o = new MyHelloWorld();$o-&gt;sayHello();?&gt;//method&lt;?phpfunction test() &#123;echo &apos;函数名为：&apos; . __METHOD__ ;&#125;test();?&gt;//namespace&lt;?phpnamespace MyProject;echo &apos;命名空间为：&quot;&apos;, __NAMESPACE__, &apos;&quot;&apos;; // 输出 &quot;MyProject&quot;?&gt; 10.命名空间 非限定名称，或不包含前缀的类名称，例如 $a=new foo(); 或 foo::staticmethod();。如果当前命名空间是 currentnamespace，foo 将被解析为 currentnamespace\\foo。如果使用 foo 的代码是全局的，不包含在任何命名空间中的代码，则 foo 会被解析为foo。 警告：如果命名空间中的函数或常量未定义，则该非限定的函数名称或常量名称会被解析为全局函数名称或常量名称。 限定名称**,或包含前缀的名称，例如 $a = new subnamespace\\foo(); 或 subnamespace\\foo::staticmethod();。如果当前的命名空间是 currentnamespace，则 foo 会被解析为 currentnamespace\\subnamespace\\foo。如果使用 foo 的代码是全局的，不包含在任何命名空间中的代码，foo 会被解析为subnamespace\\foo。 完全限定名称，或包含了全局前缀操作符的名称，例如， $a = new \\currentnamespace\\foo(); 或 \\currentnamespace\\foo::staticmethod();。在这种情况下，foo 总是被解析为代码中的文字名(literal name)currentnamespace\\foo。 持续更新…","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]}]}