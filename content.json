{"meta":{"title":"炎の博客","subtitle":"不积跬步无以至千里","description":"广东工业大学-大三-信息与计算科学","author":"LinJiayan","url":"http://yoursite.com"},"pages":[{"title":"tags","date":"2019-01-25T08:07:15.000Z","updated":"2019-01-25T08:07:15.215Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2019-01-25T08:09:18.000Z","updated":"2019-01-25T08:09:18.465Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"JVM 堆内存设置原理","slug":"JVM-堆内存设置原理","date":"2019-02-20T17:01:07.000Z","updated":"2019-02-20T17:02:02.596Z","comments":true,"path":"2019/02/21/JVM-堆内存设置原理/","link":"","permalink":"http://yoursite.com/2019/02/21/JVM-堆内存设置原理/","excerpt":"","text":"原理JVM堆内存分为2块：Permanent Space 和 Heap Space。 Permanent 即 持久代（Permanent Generation），主要存放的是Java类定义信息，与垃圾收集器要收集的Java对象关系不大。Heap = { Old + NEW = {Eden, from, to} }，Old 即 年老代（Old Generation），New 即 年轻代（Young Generation）。年老代和年轻代的划分对垃圾收集影响比较大。 年轻代所有新生成的对象首先都是放在年轻代。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。年轻代一般分3个区，1个Eden区，2个Survivor区（from 和 to）。 大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当一个Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当另一个Survivor区也满了的时候，从前一个Survivor区复制过来的并且此时还存活的对象，将可能被复制到年老代。 2个Survivor区是对称的，没有先后关系，所以同一个Survivor区中可能同时存在从Eden区复制过来对象，和从另一个Survivor区复制过来的对象；而复制到年老区的只有从另一个Survivor区过来的对象。而且，因为需要交换的原因，Survivor区至少有一个是空的。特殊的情况下，根据程序需要，Survivor区是可以配置为多个的（多于2个），这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。 针对年轻代的垃圾回收即 Young GC。 年老代在年轻代中经历了N次（可配置）垃圾回收后仍然存活的对象，就会被复制到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。针对年老代的垃圾回收即 Full GC。 持久代用于存放静态类型数据，如 Java Class, Method 等。持久代对垃圾回收没有显著影响。但是有些应用可能动态生成或调用一些Class，例如 Hibernate CGLib 等，在这种时候往往需要设置一个比较大的持久代空间来存放这些运行过程中动态增加的类型。 所以，当一组对象生成时，内存申请过程如下： JVM会试图为相关Java对象在年轻代的Eden区中初始化一块内存区域。 当Eden区空间足够时，内存申请结束。否则执行下一步。 JVM试图释放在Eden区中所有不活跃的对象（YoungGC）,释放后若Eden空间仍然不足以放入新对象，JVM则试图将部分Eden区中活跃对象放入Survivor区。 Survivor区被用来作为Eden区及年老代的中间交换区域。当年老代空间足够时，Survivor区中存活了一定次数的对象会被移到年老代。 当年老代空间不够时，JVM会在年老代进行完全的垃圾回收（Full GC）。 Full GC后，若Survivor区及年老代仍然无法存放从Eden区复制过来的对象，则会导致JVM无法在Eden区为新生成的对象申请内存，即出现“Out of Memory”。 OOM（“Out of Memory”）异常一般主要有如下2种原因： 年老代溢出，表现为：java.lang.OutOfMemoryError:Javaheapspace这是最常见的情况，产生的原因可能是：设置的内存参数Xmx过小或程序的内存泄露及使用不当问题。例如循环上万次的字符串处理、创建上千万个对象、在一段代码内申请上百M甚至上G的内存。还有的时候虽然不会报内存溢出，却会使系统不间断的垃圾回收，也无法处理其它请求。这种情况下除了检查程序、打印堆内存等方法排查，还可以借助一些内存分析工具，比如MAT就很不错。 持久代溢出，表现为：java.lang.OutOfMemoryError:PermGenspace通常由于持久代设置过小，动态加载了大量Java类而导致溢出，解决办法唯有将参数 -XX:MaxPermSize 调大（一般256m能满足绝大多数应用程序需求）。将部分Java类放到容器共享区（例如Tomcat share lib）去加载的办法也是一个思路，但前提是容器里部署了多个应用，且这些应用有大量的共享类库。 参数说明-Xmx3550m：设置JVM最大堆内存为3550M。-Xms3550m：设置JVM初始堆内存为3550M。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。-Xss128k：设置每个线程的栈大小。JDK5.0以后每个线程栈大小为1M，之前每个线程栈大小为256K。应当根据应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。需要注意的是：当这个值被设置的较大（例如&gt;2MB）时将会在很大程度上降低系统的性能。-Xmn2g：设置年轻代大小为2G。在整个堆内存大小确定的情况下，增大年轻代将会减小年老代，反之亦然。此值关系到JVM垃圾回收，对系统性能影响较大，官方推荐配置为整个堆大小的3/8。-XX:NewSize=1024m：设置年轻代初始值为1024M。-XX:MaxNewSize=1024m：设置年轻代最大值为1024M。-XX:PermSize=256m：设置持久代初始值为256M。-XX:MaxPermSize=256m：设置持久代最大值为256M。-XX:NewRatio=4：表示年轻代比年老代为1:4。-XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的比值。表示2个Survivor区（JVM堆内存年轻代中默认有2个大小相等的Survivor区）与1个Eden区的比值为2:4，即1个Survivor区占整个年轻代大小的1/6。-XX:MaxTenuringThreshold=7：表示一个对象如果在Survivor区（救助空间）移动了7次还没有被垃圾回收就进入年老代。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代，对于需要大量常驻内存的应用，这样做可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象在年轻代存活时间，增加对象在年轻代被垃圾回收的概率，减少Full GC的频率，这样做可以在某种程度上提高服务稳定性。 疑问解答-Xmn，-XX:NewSize/-XX:MaxNewSize，-XX:NewRatio 3组参数都可以影响年轻代的大小，混合使用的情况下，优先级是什么？如下：高优先级：-XX:NewSize/-XX:MaxNewSize中优先级：-Xmn（默认等效 -Xmn=-XX:NewSize=-XX:MaxNewSize=?）低优先级：-XX:NewRatio推荐使用-Xmn参数，原因是这个参数简洁，相当于一次设定 NewSize/MaxNewSIze，而且两者相等，适用于生产环境。-Xmn 配合 -Xms/-Xmx，即可将堆内存布局完成。-Xmn参数是在JDK 1.4 开始支持。 垃圾回收器选择JVM给出了3种选择：串行收集器、并行收集器、并发收集器。串行收集器只适用于小数据量的情况，所以生产环境的选择主要是并行收集器和并发收集器。 默认情况下JDK5.0以前都是使用串行收集器，如果想使用其他收集器需要在启动时加入相应参数。JDK5.0以后，JVM会根据当前系统配置进行智能判断。 串行收集器-XX:+UseSerialGC：设置串行收集器。 并行收集器（吞吐量优先）-XX:+UseParallelGC：设置为并行收集器。此配置仅对年轻代有效。即年轻代使用并行收集，而年老代仍使用串行收集。-XX:ParallelGCThreads=20：配置并行收集器的线程数，即：同时有多少个线程一起进行垃圾回收。此值建议配置与CPU数目相等。-XX:+UseParallelOldGC：配置年老代垃圾收集方式为并行收集。JDK6.0开始支持对年老代并行收集。-XX:MaxGCPauseMillis=100：设置每次年轻代垃圾回收的最长时间（单位毫秒）。如果无法满足此时间，JVM会自动调整年轻代大小，以满足此时间。-XX:+UseAdaptiveSizePolicy：设置此选项后，并行收集器会自动调整年轻代Eden区大小和Survivor区大小的比例，以达成目标系统规定的最低响应时间或者收集频率等指标。此参数建议在使用并行收集器时，一直打开。 并发收集器（响应时间优先）-XX:+UseConcMarkSweepGC：即CMS收集，设置年老代为并发收集。CMS收集是JDK1.4后期版本开始引入的新GC算法。它的主要适合场景是对响应时间的重要性需求大于对吞吐量的需求，能够承受垃圾回收线程和应用线程共享CPU资源，并且应用中存在比较多的长生命周期对象。CMS收集的目标是尽量减少应用的暂停时间，减少Full GC发生的几率，利用和应用程序线程并发的垃圾回收线程来标记清除年老代内存。-XX:+UseParNewGC：设置年轻代为并发收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此参数。-XX:CMSFullGCsBeforeCompaction=0：由于并发收集器不对内存空间进行压缩和整理，所以运行一段时间并行收集以后会产生内存碎片，内存使用效率降低。此参数设置运行0次Full GC后对内存空间进行压缩和整理，即每次Full GC后立刻开始压缩和整理内存。-XX:+UseCMSCompactAtFullCollection：打开内存空间的压缩和整理，在Full GC后执行。可能会影响性能，但可以消除内存碎片。-XX:+CMSIncrementalMode：设置为增量收集模式。一般适用于单CPU情况。-XX:CMSInitiatingOccupancyFraction=70：表示年老代内存空间使用到70%时就开始执行CMS收集，以确保年老代有足够的空间接纳来自年轻代的对象，避免Full GC的发生。其它垃圾回收参数-XX:+ScavengeBeforeFullGC：年轻代GC优于Full GC执行。-XX:-DisableExplicitGC：不响应 System.gc() 代码。-XX:+UseThreadPriorities：启用本地线程优先级API。即使 java.lang.Thread.setPriority() 生效，不启用则无效。-XX:SoftRefLRUPolicyMSPerMB=0：软引用对象在最后一次被访问后能存活0毫秒（JVM默认为1000毫秒）。-XX:TargetSurvivorRatio=90：允许90%的Survivor区被占用（JVM默认为50%）。提高对于Survivor区的使用率。辅助信息参数设置-XX:-CITime：打印消耗在JIT编译的时间。-XX:ErrorFile=./hs_err_pid.log：保存错误日志或数据到指定文件中。-XX:HeapDumpPath=./java_pid.hprof：指定Dump堆内存时的路径。-XX:-HeapDumpOnOutOfMemoryError：当首次遭遇内存溢出时Dump出此时的堆内存。-XX:OnError=”;”：出现致命ERROR后运行自定义命令。-XX:OnOutOfMemoryError=”;”：当首次遭遇内存溢出时执行自定义命令。-XX:-PrintClassHistogram：按下 Ctrl+Break 后打印堆内存中类实例的柱状信息，同JDK的 jmap -histo 命令。-XX:-PrintConcurrentLocks：按下 Ctrl+Break 后打印线程栈中并发锁的相关信息，同JDK的 jstack -l 命令。-XX:-PrintCompilation：当一个方法被编译时打印相关信息。-XX:-PrintGC：每次GC时打印相关信息。-XX:-PrintGCDetails：每次GC时打印详细信息。-XX:-PrintGCTimeStamps：打印每次GC的时间戳。-XX:-TraceClassLoading：跟踪类的加载信息。-XX:-TraceClassLoadingPreorder：跟踪被引用到的所有类的加载信息。-XX:-TraceClassResolution：跟踪常量池。-XX:-TraceClassUnloading：跟踪类的卸载信息。 粗体文本关于参数名称等标准参数（-），所有JVM都必须支持这些参数的功能，而且向后兼容；例如：-client——设置JVM使用Client模式，特点是启动速度比较快，但运行时性能和内存管理效率不高，通常用于客户端应用程序或开发调试；在32位环境下直接运行Java程序默认启用该模式。-server——设置JVM使Server模式，特点是启动速度比较慢，但运行时性能和内存管理效率很高，适用于生产环境。在具有64位能力的JDK环境下默认启用该模式。非标准参数（-X），默认JVM实现这些参数的功能，但是并不保证所有JVM实现都满足，且不保证向后兼容；非稳定参数（-XX），此类参数各个JVM实现会有所不同，将来可能会不被支持，需要慎重使用；","categories":[],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"}]},{"title":"JS中的Promise对象","slug":"JS中的Promise对象","date":"2019-02-20T02:31:36.000Z","updated":"2019-02-20T02:32:27.776Z","comments":true,"path":"2019/02/20/JS中的Promise对象/","link":"","permalink":"http://yoursite.com/2019/02/20/JS中的Promise对象/","excerpt":"","text":"Promise 的含义Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 Promise对象有以下两个特点。 （1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 （2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 基本用法ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。下面代码创造了一个Promise实例。123456789const promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;); Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。12345promise.then(function(value) &#123; // success&#125;, function(error) &#123; // failure&#125;); then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。 Promise对象的简单例子。12345678910function timeout(ms) &#123; return new Promise((resolve, reject) =&gt; &#123; //setTimeout的第三个参数将作为第一个参数(也就是要执行的方法)的参数) setTimeout(resolve, ms, &apos;done&apos;); &#125;);&#125;timeout(100).then((value) =&gt; &#123; console.log(value);&#125;); 上面代码中，timeout方法返回一个Promise实例，表示一段时间以后才会发生的结果。过了指定的时间（ms参数）以后，Promise实例的状态变为resolved，就会触发then方法绑定的回调函数。 Promise 新建后就会立即执行。12345678910let promise = new Promise(function(resolve, reject) &#123; console.log(&apos;Promise&apos;); resolve();&#125;);promise.then(function() &#123; console.log(&apos;resolved.&apos;);&#125;);console.log(&apos;Hi!&apos;); resolve函数的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。12345678const p1 = new Promise(function (resolve, reject) &#123; // ...&#125;);const p2 = new Promise(function (resolve, reject) &#123; // ... resolve(p1);&#125;) 上面代码中，p1和p2都是 Promise 的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。 注意，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。1234567891011const p1 = new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; reject(new Error(&apos;fail&apos;)), 3000)&#125;)const p2 = new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; resolve(p1), 1000)&#125;)p2 .then(result =&gt; console.log(result)) .catch(error =&gt; console.log(error)) 上面代码中，p1是一个 Promise，3 秒之后变为rejected。p2的状态在 1 秒之后改变，resolve方法返回的是p1。由于p2返回的是另一个 Promise，导致p2自己的状态无效了，由p1的状态决定p2的状态。所以，后面的then语句都变成针对后者（p1）。又过了 2 秒，p1变为rejected，导致触发catch方法指定的回调函数。 调用resolve或reject并不会终结 Promise 的参数函数的执行。123456new Promise((resolve, reject) =&gt; &#123; resolve(1); console.log(2);&#125;).then(r =&gt; &#123; console.log(r);&#125;); 上面代码中，调用resolve(1)以后，后面的console.log(2)还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。 一般来说，调用resolve或reject以后，Promise 的使命就完成了，后继操作应该放到then方法里面，而不应该直接写在resolve或reject的后面。所以，最好在它们前面加上return语句，这样就不会有意外。12345new Promise((resolve, reject) =&gt; &#123; return resolve(1); // 后面的语句不会执行 console.log(2);&#125;) Promise.prototype.then()Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。 then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。12345getJSON(&quot;/posts.json&quot;).then(function(json) &#123; return json.post;&#125;).then(function(post) &#123; // ...&#125;); 上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。 采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。1234567getJSON(&quot;/post/1.json&quot;).then(function(post) &#123; return getJSON(post.commentURL);&#125;).then(function funcA(comments) &#123; console.log(&quot;resolved: &quot;, comments);&#125;, function funcB(err)&#123; console.log(&quot;rejected: &quot;, err);&#125;); 上面代码中，第一个then方法指定的回调函数，返回的是另一个Promise对象。这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。如果变为resolved，就调用funcA，如果状态变为rejected，就调用funcB。 采用箭头函数的写法123456getJSON(&quot;/post/1.json&quot;).then( post =&gt; getJSON(post.commentURL)).then( comments =&gt; console.log(&quot;resolved: &quot;, comments), err =&gt; console.log(&quot;rejected: &quot;, err)); Promise.prototype.catch()Promise.prototype.catch方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数123456getJSON(&apos;/posts.json&apos;).then(function(posts) &#123; // ...&#125;).catch(function(error) &#123; // 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log(&apos;发生错误！&apos;, error);&#125;); 上面代码中，getJSON方法返回一个 Promise 对象，如果该对象状态变为resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。123456p.then((val) =&gt; console.log(&apos;fulfilled:&apos;, val)) .catch((err) =&gt; console.log(&apos;rejected&apos;, err));// 等同于p.then((val) =&gt; console.log(&apos;fulfilled:&apos;, val)) .then(null, (err) =&gt; console.log(&quot;rejected:&quot;, err)); 例子:123456const promise = new Promise(function(resolve, reject) &#123; throw new Error(&apos;test&apos;);&#125;);promise.catch(function(error) &#123; console.log(error);&#125;); promise抛出一个错误，就被catch方法指定的回调函数捕获。注意，上面的写法与下面两种写法等价。12345678910111213141516171819// 写法一const promise = new Promise(function(resolve, reject) &#123; try &#123; throw new Error(&apos;test&apos;); &#125; catch(e) &#123; reject(e); &#125;&#125;);promise.catch(function(error) &#123; console.log(error);&#125;);// 写法二const promise = new Promise(function(resolve, reject) &#123; reject(new Error(&apos;test&apos;));&#125;);promise.catch(function(error) &#123; console.log(error);&#125;); reject方法的作用，等同于抛出错误。如果 Promise 状态已经变成resolved，再抛出错误是无效的。1234567const promise = new Promise(function(resolve, reject) &#123; resolve(&apos;ok&apos;); throw new Error(&apos;test&apos;);&#125;);promise .then(function(value) &#123; console.log(value) &#125;) .catch(function(error) &#123; console.log(error) &#125;); 上面代码中，Promise 在resolve语句后面，再抛出错误，不会被捕获，等于没有抛出。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了。 Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。1234567getJSON(&apos;/post/1.json&apos;).then(function(post) &#123; return getJSON(post.commentURL);&#125;).then(function(comments) &#123; // some code&#125;).catch(function(error) &#123; // 处理前面三个Promise产生的错误&#125;); 三个 Promise 对象：一个由getJSON产生，两个由then产生。它们之中任何一个抛出的错误，都会被最后一个catch捕获。一般来说，不要在then方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。123456789101112131415promise .then(function(data) &#123; // success &#125;, function(err) &#123; // error &#125;);// goodpromise .then(function(data) &#123; //cb // success &#125;) .catch(function(err) &#123; // error &#125;); 第二种写法要好于第一种写法，理由是第二种写法可以捕获前面then方法执行中的错误，也更接近同步的写法（try/catch）。建议使用catch方法，而不使用then方法的第二个参数。跟传统的try/catch代码块不同的是，如果没有使用catch方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。123456789101112const someAsyncThing = function() &#123; return new Promise(function(resolve, reject) &#123; // 下面一行会报错，因为x没有声明 resolve(x + 2); &#125;);&#125;;someAsyncThing().then(function() &#123; console.log(&apos;everything is great&apos;);&#125;);setTimeout(() =&gt; &#123; console.log(123) &#125;, 2000); Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。 这个脚本放在服务器执行，退出码就是0（即表示执行成功）。不过，Node 有一个unhandledRejection事件，专门监听未捕获的reject错误，上面的脚本会触发这个事件的监听函数，可以在监听函数里面抛出错误。123process.on(&apos;unhandledRejection&apos;, function (err, p) &#123; throw err;&#125;); 一般总是建议，Promise 对象后面要跟catch方法，这样可以处理 Promise 内部发生的错误。catch方法返回的还是一个 Promise 对象，因此后面还可以接着调用then方法。12345678910111213141516const someAsyncThing = function() &#123; return new Promise(function(resolve, reject) &#123; // 下面一行会报错，因为x没有声明 resolve(x + 2); &#125;);&#125;;someAsyncThing().catch(function(error) &#123; console.log(&apos;oh no&apos;, error);&#125;).then(function() &#123; console.log(&apos;carry on&apos;);&#125;);// oh no [ReferenceError: x is not defined]// carry on 上面代码运行完catch方法指定的回调函数，会接着运行后面那个then方法指定的回调函数。如果没有报错，则会跳过catch方法。1234567Promise.resolve().catch(function(error) &#123; console.log(&apos;oh no&apos;, error);&#125;).then(function() &#123; console.log(&apos;carry on&apos;);&#125;); 上面的代码因为没有报错，跳过了catch方法，直接执行后面的then方法。此时，要是then方法里面报错，就与前面的catch无关了。 catch方法之中，还能再抛出错误。1234567891011121314151617const someAsyncThing = function() &#123; return new Promise(function(resolve, reject) &#123; // 下面一行会报错，因为x没有声明 resolve(x + 2); &#125;);&#125;;someAsyncThing().then(function() &#123; return someOtherAsyncThing();&#125;).catch(function(error) &#123; console.log(&apos;oh no&apos;, error); // 下面一行会报错，因为 y 没有声明 y + 2;&#125;).then(function() &#123; console.log(&apos;carry on&apos;);&#125;);// oh no [ReferenceError: x is not defined] 上面代码中，catch方法抛出一个错误，因为后面没有别的catch方法了，导致这个错误不会被捕获，也不会传递到外层。继续改写一下1234567891011someAsyncThing().then(function() &#123; return someOtherAsyncThing();&#125;).catch(function(error) &#123; console.log(&apos;oh no&apos;, error); // 下面一行会报错，因为y没有声明 y + 2;&#125;).catch(function(error) &#123; console.log(&apos;carry on&apos;, error);&#125;);// oh no [ReferenceError: x is not defined]// carry on [ReferenceError: y is not defined] 第二个catch方法用来捕获前一个catch方法抛出的错误。 Promise.prototype.finally()finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。1234promise.then(result =&gt; &#123;···&#125;).catch(error =&gt; &#123;···&#125;).finally(() =&gt; &#123;···&#125;); 上面代码中，不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。 下面是一个例子，服务器使用 Promise 处理请求，然后使用finally方法关掉服务器。12345server.listen(port) .then(function () &#123; // ... &#125;) .finally(server.stop); finally方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是fulfilled还是rejected。这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。 finally本质上是then方法的特例。1234567891011121314151617promise.finally(() =&gt; &#123; // 语句&#125;);// 等同于promise.then( result =&gt; &#123; // 语句 return result; &#125;, error =&gt; &#123; // 语句 throw error; &#125;); 上面代码中，如果不使用finally方法，同样的语句需要为成功和失败两种情况各写一次。有了finally方法，则只需要写一次。 它的实现也很简单。1234567Promise.prototype.finally = function (callback) &#123; let P = this.constructor; return this.then( value =&gt; P.resolve(callback()).then(() =&gt; value), reason =&gt; P.resolve(callback()).then(() =&gt; &#123; throw reason &#125;) );&#125;; 上面代码中，不管前面的 Promise 是fulfilled还是rejected，都会执行回调函数callback。 从上面的实现还可以看到，finally方法总是会返回原来的值。1234567891011// resolve 的值是 undefinedPromise.resolve(2).then(() =&gt; &#123;&#125;, () =&gt; &#123;&#125;)// resolve 的值是 2Promise.resolve(2).finally(() =&gt; &#123;&#125;)// reject 的值是 undefinedPromise.reject(3).then(() =&gt; &#123;&#125;, () =&gt; &#123;&#125;)// reject 的值是 3Promise.reject(3).finally(() =&gt; &#123;&#125;) Promise.all()Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例1const p = Promise.all([p1, p2, p3]); 上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。） p的状态由p1、p2、p3决定，分成两种情况。（1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。下面是一个具体的例子。12345678910// 生成一个Promise对象的数组const promises = [2, 3, 5, 7, 11, 13].map(function (id) &#123; return getJSON(&apos;/post/&apos; + id + &quot;.json&quot;);&#125;);Promise.all(promises).then(function (posts) &#123; // ...&#125;).catch(function(reason)&#123; // ...&#125;); 上面代码中，promises是包含 6 个 Promise 实例的数组，只有这 6 个实例的状态都变成fulfilled，或者其中有一个变为rejected，才会调用Promise.all方法后面的回调函数。12345678910111213const databasePromise = connectDatabase();const booksPromise = databasePromise .then(findAllBooks);const userPromise = databasePromise .then(getCurrentUser);Promise.all([ booksPromise, userPromise]).then(([books, user]) =&gt; pickTopRecommendations(books, user)); 上面代码中，booksPromise和userPromise是两个异步操作，只有等到它们的结果都返回了，才会触发pickTopRecommendations这个回调函数。 注意，如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。12345678910111213141516const p1 = new Promise((resolve, reject) =&gt; &#123; resolve(&apos;hello&apos;);&#125;).then(result =&gt; result).catch(e =&gt; e);const p2 = new Promise((resolve, reject) =&gt; &#123; throw new Error(&apos;报错了&apos;);&#125;).then(result =&gt; result).catch(e =&gt; e);Promise.all([p1, p2]).then(result =&gt; console.log(result)).catch(e =&gt; console.log(e));// [&quot;hello&quot;, Error: 报错了] 上面代码中，p1会resolved，p2首先会rejected，但是p2有自己的catch方法，该方法返回的是一个新的 Promise 实例，p2指向的实际上是这个实例。该实例执行完catch方法后，也会变成resolved，导致Promise.all()方法参数里面的两个实例都会resolved，因此会调用then方法指定的回调函数，而不会调用catch方法指定的回调函数。 如果p2没有自己的catch方法，就会调用Promise.all()的catch方法。1234567891011121314const p1 = new Promise((resolve, reject) =&gt; &#123; resolve(&apos;hello&apos;);&#125;).then(result =&gt; result);const p2 = new Promise((resolve, reject) =&gt; &#123; throw new Error(&apos;报错了&apos;);&#125;).then(result =&gt; result);Promise.all([p1, p2]).then(result =&gt; console.log(result)).catch(e =&gt; console.log(e));// Error: 报错了","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JS中const,var,let的区别","slug":"JS中const-var-let的区别","date":"2019-02-19T14:19:45.000Z","updated":"2019-02-19T14:21:57.974Z","comments":true,"path":"2019/02/19/JS中const-var-let的区别/","link":"","permalink":"http://yoursite.com/2019/02/19/JS中const-var-let的区别/","excerpt":"","text":"1. 块作用域{ }JS中作用域有：全局作用域、函数作用域。没有块作用域的概念。ECMAScript 6(简称ES6)中新增了块级作用域。块作用域由 { } 包括，if语句和for语句里面的{ }也属于块作用域。123456789101112131415161718192021222324252627&lt;script type=&quot;text/javascript&quot;&gt; &#123; var a = 1; console.log(a); // 1 &#125; console.log(a); // 1 // 可见，通过var定义的变量可以跨块作用域访问到。 (function A() &#123; var b = 2; console.log(b); // 2 &#125;)(); // console.log(b); // 报错， // 可见，通过var定义的变量不能跨函数作用域访问到 if(true) &#123; var c = 3; &#125; console.log(c); // 3 for(var i = 0; i &lt; 4; i++) &#123; var d = 5; &#125;; console.log(i); // 4 (循环结束i已经是4，所以此处i为4) console.log(d); // 5 // if语句和for语句中用var定义的变量可以在外面访问到， // 可见，if语句和for语句属于块作用域，不属于函数作用域。&lt;/script&gt; 2. var、let、const的区别var定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问。let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改。12345678910111213141516171819202122232425262728293031323334&lt;script type=&quot;text/javascript&quot;&gt; // 块作用域 &#123; var a = 1; let b = 2; const c = 3; // c = 4; // 报错 var aa; let bb; // const cc; // 报错 console.log(a); // 1 console.log(b); // 2 console.log(c); // 3 console.log(aa); // undefined console.log(bb); // undefined &#125; console.log(a); // 1 // console.log(b); // 报错 // console.log(c); // 报错 // 函数作用域 (function A() &#123; var d = 5; let e = 6; const f = 7; console.log(d); // 5 console.log(e); // 6 (在同一个&#123; &#125;中,也属于同一个块，可以正常访问到) console.log(f); // 7 (在同一个&#123; &#125;中,也属于同一个块，可以正常访问到) &#125;)(); // console.log(d); // 报错 // console.log(e); // 报错 // console.log(f); // 报错&lt;/script&gt;","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"SpringBoot整合SpringSecurity","slug":"SpringBoot整合SpringSecurity","date":"2019-02-16T11:28:08.000Z","updated":"2019-02-16T11:35:03.454Z","comments":true,"path":"2019/02/16/SpringBoot整合SpringSecurity/","link":"","permalink":"http://yoursite.com/2019/02/16/SpringBoot整合SpringSecurity/","excerpt":"","text":"引入maven依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; 在config包下创建配置文件WebSecurityConfig,自定义用户认证逻辑每个系统肯定是有自己的一套用户体系的，所以我们需要自定义自己的认证逻辑以及登录界面。这里我们需要先对SpringSecurity进行相应的配置1234567891011121314151617181920212223242526272829303132@Configurationpublic class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; @Autowired //登陆成功的handler MyAuthenctiationSuccessHandler successHandler; @Autowired MyAuthenctiationFailureHandler failureHandler; @Bean public PasswordEncoder passwordEncoder()&#123; return new BCryptPasswordEncoder(); &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.formLogin() // 定义当需要用户登录时候，转到的登录页面。 .loginPage(&quot;/login&quot;) .loginProcessingUrl(&quot;/user/login&quot;) // 自定义的登录接口 .successHandler(successHandler)// .failureHandler(failureHandler) .and() .authorizeRequests() // 定义哪些URL需要被保护、哪些不需要被保护 .antMatchers(&quot;/login&quot;).permitAll() .anyRequest() // 任何请求,登录后可以访问 .authenticated().and() .csrf().disable(); &#125; @Override public void configure(WebSecurity web) throws Exception &#123; //css,js等资源放行 web.ignoring().antMatchers(&quot;/assets/**&quot;); &#125;&#125; UserDetailUserDetails 就是封装了用户信息的对象，里面包含了七个方法12345678910111213141516public interface UserDetails extends Serializable &#123; // 封装了权限信息 Collection&lt;? extends GrantedAuthority&gt; getAuthorities(); // 密码信息 String getPassword(); // 登录用户名 String getUsername(); // 帐户是否过期 boolean isAccountNonExpired(); // 帐户是否被冻结 boolean isAccountNonLocked(); // 帐户密码是否过期，一般有的密码要求性高的系统会使用到，比较每隔一段时间就要求用户重置密码 boolean isCredentialsNonExpired(); // 帐号是否可用 boolean isEnabled();&#125; 在返回UserDetails的实现类User的时候，可以通过User的构造方法，设置对应的参数 密码加密解密SpringSecurity中有一个PasswordEncoder接口123456public interface PasswordEncoder &#123; // 对密码进行加密 String encode(CharSequence var1); // 对密码进行判断匹配 boolean matches(CharSequence var1, String var2);&#125; 需要自己实现这个接口，并在配置文件中配置一下就可以了。这里我暂时以默认提供的一个实现类进行测试12345// BrowerSecurityConfig @Beanpublic PasswordEncoder passwordEncoder() &#123; return new BCryptPasswordEncoder(); &#125; 新建一个类实现UserDetailsService,并配置密码加密解密1234567891011121314151617181920212223@Componentpublic class CustomUserService implements UserDetailsService &#123; //自定义UserDetailsService 接口 @Autowired private PasswordEncoder passwordEncoder; @Autowired UserRepository userRepository; @Override public UserDetails loadUserByUsername(String username) &#123; //重写loadUserByUsername 方法获得 userdetails 类型用户 //直接调用JPA的接口即可获取用户信息 User user = userRepository.findByName(username); if(user == null)&#123; throw new UsernameNotFoundException(&quot;用户名不存在&quot;); &#125; List&lt;SimpleGrantedAuthority&gt; authorities = new ArrayList&lt;&gt;(); //用于添加用户的权限。只要把用户权限添加到authorities 就万事大吉。 for(Authority role:user.getAuthorityList())&#123; authorities.add(new SimpleGrantedAuthority(role.getAuthorityname())); &#125; return new org.springframework.security.core.userdetails.User(user.getName(), passwordEncoder.encode(user.getPassword()), authorities); &#125;&#125; 定义控制器12345678@RequestMapping(&quot;/login&quot;)public String login()&#123; return &quot;login&quot;;&#125;@RequestMapping(&quot;/&quot;)public String getIndex(HttpServletRequest request)&#123; return &quot;success&quot;;&#125; User类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@Entity@Proxy(lazy = false)//若没有声明table 则表名和类名一致public class User &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; @Column private String name; @Column private String password; @ManyToMany @JoinTable(name = &quot;user_authority&quot;,joinColumns = @JoinColumn(name = &quot;user_id&quot;), inverseJoinColumns = @JoinColumn(name = &quot;authority_id&quot;)) //1、关系维护端，负责多对多关系的绑定和解除 //2、@JoinTable注解的name属性指定关联表的名字，joinColumns指定外键的名字，关联到关系维护端(User) //3、inverseJoinColumns指定外键的名字，要关联的关系被维护端(Authority) //4、其实可以不使用@JoinTable注解，默认生成的关联表名称为主表表名+下划线+从表表名， //即表名为user_authority //关联到主表的外键名：主表名+下划线+主表中的主键列名,即user_id //关联到从表的外键名：主表中用于关联的属性名+下划线+从表的主键列名,即authority_id //主表就是关系维护端对应的表，从表就是关系被维护端对应的表 private List&lt;Authority&gt; authorityList; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; public List&lt;Authority&gt; getAuthorityList() &#123; return authorityList; &#125; public void setAuthorityList(List&lt;Authority&gt; authorityList) &#123; this.authorityList = authorityList; &#125;&#125; 个性化用户认证逻辑自定义登录页面先写一个简单的登录页面12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;登录页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;自定义登录页面&lt;/h2&gt; &lt;form action=&quot;/user/login&quot; method=&quot;post&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;用户名：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt;&lt;button type=&quot;submit&quot;&gt;登录&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 这样，每当访问被保护的接口的时候，就会调转到login.html页面 自定义处理登录成功/失败Spring Security中的两个接口AuthenticationSuccessHandler和AuthenticationFailureHandler。可用于认证结果的处理。可以实现这个接口，并进行相应的配置就可以了。 当然框架是有默认的实现类的，可以继承这个实现类再来自定义自己的业务 可以通过response返回一个JSON字符串回去。这个方法中的第三个参数Authentication，它里面包含了登录后的用户信息（UserDetails），Session的信息，登录信息等。12345678910111213141516171819@Component(&quot;myAuthenctiationFailureHandler&quot;)public class MyAuthenctiationFailureHandler extends SimpleUrlAuthenticationFailureHandler &#123; private Logger logger = LoggerFactory.getLogger(getClass()); @Autowired private ObjectMapper objectMapper; @Override public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException &#123; logger.info(&quot;登录失败&quot;); response.setStatus(HttpStatus.INTERNAL_SERVER_ERROR.value()); response.setContentType(&quot;application/json;charset=UTF-8&quot;); response.getWriter().write(objectMapper.writeValueAsString(new BaseResponse(exception.getMessage()))); &#125;&#125; 同样的方式,可以配置失败处理器,通过successHandler和failureHandler方法注入处理器12.successHandler(myAuthenticationSuccessHandler) // 自定义登录成功处理 .failureHandler(myAuthenticationFailureHandler) // 自定义登录失败处理","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"},{"name":"SpringSecurity","slug":"SpringSecurity","permalink":"http://yoursite.com/tags/SpringSecurity/"}]},{"title":"Yii操作Mysql","slug":"Yii操作Mysql","date":"2019-01-29T12:11:01.000Z","updated":"2019-01-29T12:39:29.790Z","comments":true,"path":"2019/01/29/Yii操作Mysql/","link":"","permalink":"http://yoursite.com/2019/01/29/Yii操作Mysql/","excerpt":"","text":"创建Model对象1234567891011class Myguest extends CActiveRecord &#123; //返回当前模型对象的静态方法 public static function mmodel($className = __CLASS__)&#123; return parent::model($className); &#125; //返回当前模型的名字的方法 public function tableName()&#123; return &quot;test_myguest&quot;; &#125;&#125; 编辑数据库配置编辑main.php文件中的’db’数组123456789&apos;db&apos;=&gt;array( &apos;connectionString&apos;=&gt;&apos;mysql:host=localhost;dbname=phpdb&apos;, &apos;emulatePrepare&apos;=&gt;true, &apos;username&apos;=&gt;&apos;root&apos;, &apos;password&apos;=&gt;&apos;123&apos;, &apos;charset&apos;=&gt;&apos;utf8&apos;, //把数据表的前缀设置好 //&apos;tablePrefix&apos;=&gt;&apos;test_&apos;,), 创建controller123456class UserController extends Controller &#123; function actionLogin()&#123; $this-&gt;renderPartial(&quot;login&quot;); &#125;&#125; renderPartial方法会跳转到views/user/login.php Yii操作数据库123 //执行增加更新或者删除操作,$sql = &quot;update test_myguest set firstname = &apos;林&apos; where id =23&quot;; $res = Yii::app()-&gt;db-&gt;createCommand($sql)-&gt;execute(); 更新:12345678$res = Yii::app()-&gt;db-&gt;createCommand()-&gt;update(//表名&apos;test_myguest&apos;,//操作array(&apos;firstname&apos;=&gt;&quot;改名字辣&quot;),//条件&apos;id=:id&apos;,array(&apos;:id&apos;=&gt;15)); 删除:1234$res = Yii::app()-&gt;db-&gt;createCommand()-&gt;delete(&apos;test_myguest&apos;,&apos;id=:id&apos;,array(&apos;:id&apos;=&gt;12)); 插入123456$res = Yii::app()-&gt;getDb()-&gt;createCommand()-&gt;insert(&apos;test_myguest&apos;,array(&apos;firstname&apos;=&gt;&apos;陈&apos;,&apos;lastname&apos;=&gt;&apos;大伟&apos;));var_dump($res); 查询123456789method1: //这是一个list $res = Yii::app()-&gt;getDb()-&gt;createCommand() -&gt;select(&apos;id,firstname,lastname&apos;) -&gt;from(&apos;test_myguest&apos;) -&gt;where(&apos;id&gt;1&apos;) -&gt;queryAll(); echo $res[3][&apos;lastname&apos;]; 返回一个数组,第一个参数是第几列,第二个参数是属性,不是对象,不能使用-&gt;1234567method2:$obj = CustomGame::model()-&gt;find(&quot;game_id=:gi&quot;,array(&apos;gi&apos;=&gt;163804000));//上面的语句返回一个对象$user_id = $obj-&gt;user_id;//取属性 分页查询:12345678910$res = Yii::app()-&gt;getDb()-&gt;createCommand() -&gt;select(&apos;id,firstname,lastname&apos;) -&gt;from(&apos;test_myguest&apos;) // -&gt;where(&apos;id=:id&apos;,array(&quot;:id&quot;=&gt;1)) -&gt;offset(10) -&gt;limit(10) -&gt;queryAll();// var_dump($res[2]); $res[2]是第二条数据// echo $res[2][&apos;lastname&apos;]; 第二条数据的lastname属性 var_dump($res);","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/tags/PHP/"},{"name":"Yii","slug":"Yii","permalink":"http://yoursite.com/tags/Yii/"}]},{"title":"NodeJs domain的作用","slug":"NodeJs-domain的作用","date":"2019-01-29T12:09:20.000Z","updated":"2019-01-29T12:10:30.949Z","comments":true,"path":"2019/01/29/NodeJs-domain的作用/","link":"","permalink":"http://yoursite.com/2019/01/29/NodeJs-domain的作用/","excerpt":"","text":"Domain 可以简化异步代码的异常处理，可以捕捉处理try catch无法捕捉的异常。 引入 Domain 模块 语法格式1var domain = require(&quot;domain&quot;) 把处理多个不同的IO的操作作为一个组。注册事件和回调到domain，当发生一个错误事件或抛出一个错误时，domain对象会被通知，不会丢失上下文环境，也不导致程序错误立即退出，与process.on(‘uncaughtException’)不同。 常用方法12345678910111213141516domain.run(function)//在域的上下文运行提供的函数，隐式的绑定了所有的事件分发器，计时器和底层请求。domain.add(emitter)//显式的增加事件domain.remove(emitter)//删除事件domain.create()//返回一个domain对象。domain.exit()//退出当前的domain，切换到不同的链的异步调用的上下文中。对应domain.enter()。domain.dispose()//释放一个domain对象，让node进程回收这部分资源。 Demo12345678910111213141516171819202122232425262728293031323334353637383940var EventEmitter = require(&quot;events&quot;).EventEmitter;var domain = require(&quot;domain&quot;);var emitter1 = new EventEmitter();// 创建域var domain1 = domain.create();domain1.on(&apos;error&apos;, function(err)&#123; console.log(&quot;domain1 处理这个错误 (&quot;+err.message+&quot;)&quot;);&#125;);// 显式绑定domain1.add(emitter1);emitter1.on(&apos;error&apos;,function(err)&#123; console.log(&quot;监听器处理此错误 (&quot;+err.message+&quot;)&quot;);&#125;);emitter1.emit(&apos;error&apos;,new Error(&apos;通过监听器来处理&apos;));emitter1.removeAllListeners(&apos;error&apos;);emitter1.emit(&apos;error&apos;,new Error(&apos;通过 domain1 处理&apos;));var domain2 = domain.create();domain2.on(&apos;error&apos;, function(err)&#123; console.log(&quot;domain2 处理这个错误 (&quot;+err.message+&quot;)&quot;);&#125;);// 隐式绑定domain2.run(function()&#123; var emitter2 = new EventEmitter(); emitter2.emit(&apos;error&apos;,new Error(&apos;通过 domain2 处理&apos;)); &#125;);domain1.remove(emitter1);emitter1.emit(&apos;error&apos;, new Error(&apos;转换为异常，系统将崩溃!&apos;)); Domain的关键就在于错误会传到domain而不会引发系统崩溃","categories":[],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"http://yoursite.com/tags/NodeJs/"}]},{"title":"NodeJs path的join和resolve的区别","slug":"NodeJs-path的join和resolve的区别","date":"2019-01-29T08:03:43.000Z","updated":"2019-01-29T12:05:54.078Z","comments":true,"path":"2019/01/29/NodeJs-path的join和resolve的区别/","link":"","permalink":"http://yoursite.com/2019/01/29/NodeJs-path的join和resolve的区别/","excerpt":"连接路径：path.join([path1][, path2][, …])","text":"连接路径：path.join([path1][, path2][, …]) path.join()方法可以连接任意多个路径字符串。要连接的多个路径可做为参数传入。path.join()方法在接边路径的同时也会对路径进行规范化。例如：123456789var path = require(&apos;path&apos;); //合法的字符串连接 path.join(&apos;/foo&apos;, &apos;bar&apos;, &apos;baz/asdf&apos;, &apos;quux&apos;, &apos;..&apos;) // 连接后 &apos;/foo/bar/baz/asdf&apos; //不合法的字符串将抛出异常 path.join(&apos;foo&apos;, &#123;&#125;, &apos;bar&apos;) // 抛出的异常 TypeError: Arguments to path.join must be strings&apos; 路径解析：path.resolve([from …], to)path.resolve()方法可以将多个路径解析为一个规范化的绝对路径。其处理方式类似于对这些路径逐一进行cd操作，与cd操作不同的是，这引起路径可以是文件，并且可不必实际存在（resolve()方法不会利用底层的文件系统判断路径是否存在，而只是进行路径字符串操作）。例如：1path.resolve(&apos;foo/bar&apos;, &apos;/tmp/file/&apos;, &apos;..&apos;, &apos;a/../subfile&apos;) 相当于12345cd foo/barcd /tmp/file/cd ..cd a/../subfilepwd 例子:12345678910path.resolve(&apos;/foo/bar&apos;, &apos;./baz&apos;) // 输出结果为 &apos;/foo/bar/baz&apos; path.resolve(&apos;/foo/bar&apos;, &apos;/tmp/file/&apos;) // 输出结果为 &apos;/tmp/file&apos; path.resolve(&apos;wwwroot&apos;, &apos;static_files/png/&apos;, &apos;../gif/image.gif&apos;) // 当前的工作路径是 /home/itbilu/node，则输出结果为 &apos;/home/itbilu/node/wwwroot/static_files/gif/image.gif&apos; 对比12345678910const path = require(&apos;path&apos;); let myPath = path.join(__dirname,&apos;/img/so&apos;); let myPath2 = path.join(__dirname,&apos;./img/so&apos;); let myPath3 = path.resolve(__dirname,&apos;/img/so&apos;); let myPath4 = path.resolve(__dirname,&apos;./img/so&apos;); console.log(__dirname); //D:\\myProgram\\test console.log(myPath); //D:\\myProgram\\test\\img\\so console.log(myPath2); //D:\\myProgram\\test\\img\\so console.log(myPath3); //D:\\img\\so&lt;br&gt; console.log(myPath4); //D:\\myProgram\\test\\img\\so","categories":[],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"http://yoursite.com/tags/NodeJs/"}]},{"title":"安装ElasticSearch_head插件","slug":"安装ElasticSearch_head插件","date":"2019-01-28T15:56:21.000Z","updated":"2019-01-28T16:18:28.750Z","comments":true,"path":"2019/01/28/安装ElasticSearch_head插件/","link":"","permalink":"http://yoursite.com/2019/01/28/安装ElasticSearch_head插件/","excerpt":"","text":"ElasticSearch安装Head插件 安装ElasticSearch安装node安装gruntgrunt是一个很方便的构建工具，可以进行打包压缩、测试、执行等等的工作，5.0里的head插件就是通过grunt启动的。因此需要安装grunt：1npm install -g grunt-cli -g代表全局安装。安装路径为C:\\Users\\yourname\\AppData\\Roaming\\npm，并且自动加入PATH变量。安装完成后检查一下：1grunt -version 下载elastichsearch-head插件1$ git clone git://github.com/mobz/elasticsearch-head.git 修改head源码由于head的代码还是2.6版本的，直接执行有很多限制，比如无法跨机器访问。因此需要用户修改两个地方：目录：head/Gruntfile.js：12345678910connect: &#123; server: &#123; options: &#123; port: 9100, hostname: &apos;*&apos;, base: &apos;.&apos;, keepalive: true &#125; &#125;&#125; 增加hostname属性，设置为* 修改链接地址目录：head/_site/app.js修改head的连接地址:1this.base_uri = this.config.base_uri || this.prefs.get(&quot;app-base_uri&quot;) || &quot;http://localhost:9200&quot;; 把localhost修改成你es的服务器地址，如：1this.base_uri = this.config.base_uri || this.prefs.get(&quot;app-base_uri&quot;) || &quot;http://10.10.10.10:9200&quot;; 运行修改elasticsearch的参数修改一下es使用的参数。编辑config/elasticsearch.yml：123456789101112131415# 换个集群的名字，免得跟别人的集群混在一起cluster.name: es-5.0-test# 换个节点名字node.name: node-101# 修改一下ES的监听地址，这样别的机器也可以访问network.host: 0.0.0.0# 默认的就好http.port: 9200# 增加新的参数，这样head插件可以访问eshttp.cors.enabled: truehttp.cors.allow-origin: &quot;*&quot; 设置参数的时候:后面要有空格！ 开启ES-5.6.0：1G:\\background\\elasticsearch-5.6.0\\bin\\elasticsearch.bat 在head源码目录中，执行npm install 下载的包：1npm install 在head源代码目录下启动nodejs：1grunt server 访问1http://localhost:9100","categories":[],"tags":[{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"http://yoursite.com/tags/ElasticSearch/"}]},{"title":"SpringBoot整合ElasticSearch","slug":"SpringBoot整合ElasticSearch","date":"2019-01-27T07:28:06.000Z","updated":"2019-01-27T07:39:34.636Z","comments":true,"path":"2019/01/27/SpringBoot整合ElasticSearch/","link":"","permalink":"http://yoursite.com/2019/01/27/SpringBoot整合ElasticSearch/","excerpt":"","text":"SpringBoot整合ElasticSearch 引入Maven依赖12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;net.java.dev.jna&lt;/groupId&gt; &lt;artifactId&gt;jna&lt;/artifactId&gt; &lt;version&gt;4.3.0&lt;/version&gt;&lt;/dependency&gt; 配置文件增加ElasticSearch相关信息1234##Elastic服务地址spring.data.elasticsearch.cluster-nodes=localhost:9300#设置连接超时时间spring.data.elasticsearch.properties.transport.tcp.connect_timeout=120s 新建Domain类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import java.io.Serializable;@Document(indexName = &quot;blog&quot;, type=&quot;blog&quot;)public class EsBlog implements Serializable &#123; private static final long seriaVersionUID = 1L; @Id private String id; private String title; private String summary; private String content; @Override public String toString() &#123; return String.format( &quot;EsBlog[id=&apos;%s&apos;,title=&apos;%s&apos;,summary=&apos;%s&apos;,content=&apos;%s&apos;]&quot; ,id,title,summary,content ); &#125; protected EsBlog() &#123; &#125; public EsBlog(String title,String summary,String content)&#123; this.title = title; this.summary = summary; this.content = content; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public String getSummary() &#123; return summary; &#125; public void setSummary(String summary) &#123; this.summary = summary; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125;&#125; 配置Jpa的ElasticSeach查询接口新建EsBlogRepository接口,继承ElasticsearchRepository&lt;EsBlog,String&gt;12//分页查询博客,去重功能Page&lt;EsBlog&gt; findDistinctEsBlogByTitleContainingOrSummaryContainingOrContentContaining(String title, String summary, String content, Pageable pageable); Distinct:去重containing:包含内容即可返回 编写测试类12345678910111213141516171819202122232425262728@RunWith(SpringRunner.class)@SpringBootTest(classes= Application.class)public class EsBlogRepositoryTest&#123; @Autowired private EsBlogRepository esBlogRepository; //Before注解下的方法会在测试方法前执行 @Before public void initRRepositoryData()&#123; //清除所有数据 esBlogRepository.deleteAll(); esBlogRepository.save(new EsBlog(&quot;登鹳雀楼&quot;,&quot;王之涣的登鹳雀楼&quot;,&quot;白日依山尽，黄河入海流。欲穷千里目，更上一层楼。&quot;)); esBlogRepository.save(new EsBlog(&quot;相思&quot;,&quot;王维的相思&quot;,&quot;红豆生南国，春来发几枝。愿君多采撷，此物最相思。&quot;)); esBlogRepository.save(new EsBlog(&quot;静夜思&quot;,&quot;李白的静夜思&quot;,&quot;床前明月光，疑似地上霜，举头望明月，低头思故乡。&quot;)); &#125; @Test public void FindDistinctEsBlogByTitleContainingOrSummaryContainingOrContentContaining()&#123; Pageable pageable = new PageRequest(0,20); String title = &quot;思&quot;; String summary = &quot;相思&quot;; String content = &quot;相思&quot;; Page&lt;EsBlog&gt; page = esBlogRepository.findDistinctEsBlogByTitleContainingOrSummaryContainingOrContentContaining(title,summary,content,pageable); System.out.println(&quot;------------------------------------------------------&quot;); for (EsBlog blog : page.getContent())&#123; System.out.println(blog.toString()); &#125; System.out.println(&quot;end................................................................&quot;); &#125;&#125; 运行结果:1234------------------------------------------------------EsBlog[id=&apos;AWiOBGQ6G1YcO1hyfAG2&apos;,title=&apos;静夜思&apos;,summary=&apos;李白的静夜思&apos;,content=&apos;床前明月光，疑似地上霜，举头望明月，低头思故乡。&apos;]EsBlog[id=&apos;AWiOBGPcG1YcO1hyfAG1&apos;,title=&apos;相思&apos;,summary=&apos;王维的相思&apos;,content=&apos;红豆生南国，春来发几枝。愿君多采撷，此物最相思。&apos;]end................................................................ 浏览器查看Elastic插入后可以通过http://localhost:9200/blog/blog/_search?pretty=true 在浏览器中查看数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&#123; &quot;took&quot; : 1, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 5, &quot;successful&quot; : 5, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : 3, &quot;max_score&quot; : 1.0, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;blog&quot;, &quot;_type&quot; : &quot;blog&quot;, &quot;_id&quot; : &quot;AWiOBGQ6G1YcO1hyfAG2&quot;, &quot;_score&quot; : 1.0, &quot;_source&quot; : &#123; &quot;id&quot; : null, &quot;title&quot; : &quot;静夜思&quot;, &quot;summary&quot; : &quot;李白的静夜思&quot;, &quot;content&quot; : &quot;床前明月光，疑似地上霜，举头望明月，低头思故乡&quot; &#125; &#125;, &#123; &quot;_index&quot; : &quot;blog&quot;, &quot;_type&quot; : &quot;blog&quot;, &quot;_id&quot; : &quot;AWiOBGL_G1YcO1hyfAG0&quot;, &quot;_score&quot; : 1.0, &quot;_source&quot; : &#123; &quot;id&quot; : null, &quot;title&quot; : &quot;登鹳雀楼&quot;, &quot;summary&quot; : &quot;王之涣的登鹳雀楼&quot;, &quot;content&quot; : &quot;白日依山尽，黄河入海流。欲穷千里目，更上一层楼。&quot; &#125; &#125;, &#123; &quot;_index&quot; : &quot;blog&quot;, &quot;_type&quot; : &quot;blog&quot;, &quot;_id&quot; : &quot;AWiOBGPcG1YcO1hyfAG1&quot;, &quot;_score&quot; : 1.0, &quot;_source&quot; : &#123; &quot;id&quot; : null, &quot;title&quot; : &quot;相思&quot;, &quot;summary&quot; : &quot;王维的相思&quot;, &quot;content&quot; : &quot;红豆生南国，春来发几枝。愿君多采撷，此物最相思。&quot; &#125; &#125; ] &#125;&#125; 完成Controller1234567891011121314151617@RestController@RequestMapping(&quot;/blogs&quot;)public class BlogController &#123; @Autowired private EsBlogRepository esBlogRepository; @GetMapping public List&lt;EsBlog&gt; list(@RequestParam(value=&quot;title&quot;) String title, @RequestParam(value=&quot;summary&quot;) String summary, @RequestParam(value=&quot;content&quot;) String content, @RequestParam(value=&quot;pageIndex&quot;,defaultValue = &quot;0&quot;) int pageIndex, @RequestParam(value=&quot;pageSize&quot;,defaultValue = &quot;10&quot;) int pageSize )&#123; Pageable pageable = new PageRequest(pageIndex,pageSize); Page&lt;EsBlog&gt; page = esBlogRepository.findDistinctEsBlogByTitleContainingOrSummaryContainingOrContentContaining(title,summary,content,pageable); return page.getContent(); &#125;&#125; 浏览器访问1http://localhost:8080/blogs?title=思summary=相思&amp;content=相思","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"},{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"http://yoursite.com/tags/ElasticSearch/"}]},{"title":"PHP_字符串","slug":"PHP-字符串","date":"2019-01-26T07:06:06.000Z","updated":"2019-01-26T07:08:26.262Z","comments":true,"path":"2019/01/26/PHP-字符串/","link":"","permalink":"http://yoursite.com/2019/01/26/PHP-字符串/","excerpt":"","text":"双引号和单引号的区别:123456789101112/** * * 双引号可以解析变量 * 单引号不解析变量 * 双引号解析所有的转义符号 * 单引号只解析两个转义符 : \\\\ \\&apos; */$username = &apos;linjiayan&apos;;echo &quot;$username&quot;;echo &quot;&lt;br&gt;&quot;;echo &apos;$username&apos;;echo &quot;&lt;br&gt;&quot;; 花括号的作用作用一12345678$username = &apos;king&apos;;echo $username.&apos;&lt;br&gt;&apos;;echo &apos;&lt;br&gt;&apos;;echo &quot;我的名字为$username&quot;;echo &quot;&lt;br&gt;&quot;;echo &quot;我的名字为$username&quot;.&quot;s&quot;;echo &quot;&lt;br&gt;&quot;;echo &quot;我的名字为&#123;$username&#125;s&quot;; 输出123我的名字为king我的名字为kings我的名字为kings 作用二123456789101112131415161718192021222324252627282930//通过&#123;&#125;可以对字符串中的字符做增删改查操作$str=&apos;abcdef&apos;;//获取echo $str&#123;0&#125;;echo &quot;&lt;br&gt;&quot;;//替换,只能用一个字符替换一个字符$str&#123;1&#125; = &apos;m&apos;;echo $str;echo &quot;&lt;br&gt;&quot;;//即使是一个字符串,也只取一个$str&#123;4&#125; = &apos;hello&apos;;echo $str;echo &quot;&lt;br&gt;&quot;;//用空字符替换$str = &apos;imooc&apos;;$str&#123;1&#125; = &apos;&apos;;echo $str;echo &quot;&lt;br&gt;&quot;;//长度还是原来的,只是用空字符串代替var_dump($str);echo &quot;&lt;br&gt;&quot;;$str = &apos;abc&apos;;$str&#123;30&#125;=&apos;d&apos;;echo $str;//获取字符串中随机的一个字符$string = &apos;qwertyuipasdfghj&apos;;echo $string&#123;mt_rand(0,strlen($string)-1)&#125;; heredoc和nowdoc123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//heredoc 相当于双引号的作用$str = &apos;king&apos;;$table = &quot;&lt;table border = &apos;1&apos; width = \\&quot;80%\\&quot;&gt;&lt;tr&gt; &lt;td&gt;编号&lt;/td&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt;描述&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;king&lt;/td&gt; &lt;td&gt;He Said \\&quot; I&apos;m Fine \\&quot; Thank You&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt;&quot;;echo $table;$table =&lt;&lt;&lt;EOF &lt;table border = &apos;1&apos; width = &quot;80%&quot;&gt; &lt;tr&gt; &lt;td&gt;编号&lt;/td&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt;描述&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;king&lt;/td&gt; &lt;td&gt;He Said &quot;I&apos;m Fine &quot; Thank You&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;EOF;echo $table;echo &quot;&lt;br&gt;&quot;;$username = &quot;linjiayan&quot;;//nowdoc语法结构,相当于单引号的作用$str =&lt;&lt;&lt;&apos;EOD&apos; hello kong &lt;br/&gt; &#123;$username&#125; &lt;br/&gt; a/nb/rcdefEOD;echo $str; 字符串转换的规律1234567891011121314151617181920212223242526272829303132/** * Created by PhpStorm. * User: LinJiayan * Date: 2019/1/26 * Time: 14:01 *///字符串转换成其他类型//取合法数字,如果不是合法数字开始则转换成0echo 1+&apos;3king&apos;;echo &quot;&lt;br&gt;&quot;;echo 1.2+&apos;4abc&apos;;echo &quot;&lt;br&gt;&quot;;echo 3+&apos;2e2&apos;;echo &quot;&lt;br&gt;&quot;;echo 2+&apos;true&apos;;echo &quot;&lt;br&gt;&quot;;//字符串转换为布尔型的规律,空字符串或者是字符串&apos;0&apos;,&quot;0&quot;----&gt;false$res = &apos;&apos;;$res = &quot; &quot;;//有内容则是true$res = &apos;0&apos;;$res = &apos;0.0&apos;;$res = &apos;false&apos;;$res = 0 ;$res = 0.0;$res = null;$res = array();if($res)&#123; echo &quot;我是真的&lt;br&gt;&quot;;&#125;else&#123; echo &quot;我是假的&quot;;&#125;","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/tags/PHP/"},{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/tags/字符串/"}]},{"title":"ElasticSearch笔记","slug":"ElasticSearch笔记","date":"2019-01-25T07:14:02.000Z","updated":"2019-01-25T09:11:18.222Z","comments":true,"path":"2019/01/25/ElasticSearch笔记/","link":"","permalink":"http://yoursite.com/2019/01/25/ElasticSearch笔记/","excerpt":"","text":"全文搜索属于最常见的需求，开源的 Elasticsearch是目前全文搜索引擎的首选。Elastic 的底层是开源库Lucene。但是，无法直接用Lucene，必须写代码去调用它的接口。Elastic 是 Lucene 的封装，提供了 REST API 的操作接口，开箱即用。 安装Elastic 需要 Java 8 环境。1234$ wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.5.1.zip$ unzip elasticsearch-5.5.1.zip$ mv elasticsearch-5.5.1 destination(目标文件夹)$ cd elasticsearch-5.5.1/ 不要把es目录放在 ~目录下,这是root用户的用户目录,后面要切换到自定义用户 下载后在 elasticsearch 根目录下启动。1elasticsearch-2.2.0]# ./bin/elasticsearch 启动时报java内存不足的解决方法 解决办法：1、进入/home/elasticsearch-5.3.1/config2、修改jvm.options 的配置 vim jvm.options3、修改为-Xms512M-Xmx512M 解决之后,继续报错123456Exception in thread &quot;main&quot; java.lang.RuntimeException: don&apos;t run elasticsearch as root. at org.elasticsearch.bootstrap.Bootstrap.initializeNatives(Bootstrap.java:93) at org.elasticsearch.bootstrap.Bootstrap.setup(Bootstrap.java:144) at org.elasticsearch.bootstrap.Bootstrap.init(Bootstrap.java:285) at org.elasticsearch.bootstrap.Elasticsearch.main(Elasticsearch.java:35)Refer to the log for complete error details. 这是版本的问题，最新的版本安全级别提高了，不允许采用root帐号启动，所以我们要添加一个用户。12345678910111213#添加一个用户：elasticsearch$useradd elasticsearch#给用户elasticsearch设置密码，连续输入2次$passwd elasticsearch#创建一个用户组 esgroupadd es#分配 elasticsearch 到 es 组usermod -G elasticsearch es#这里注意下，如果提示用户“es”不存在，那么是因为服务器版本问题，你可以换成 usermod -G es elasticsearch ,也就是用户和用户组对调一下使用。#在elasticsearch 根目录下，给定用户权限。-R表示逐级（N层目录） ， * 表示 任何文件chown -R elasticsearch.es *#切换到elasticsearch用户su elasticsearch 基本概念Node 与 ClusterElastic 本质上是一个分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个 Elastic 实例。单个 Elastic 实例称为一个节点（node）。一组节点构成一个集群（cluster）。 IndexElastic 会索引所有字段，经过处理后写入一个反向索引（Inverted Index）。查找数据的时候，直接查找该索引。所以，Elastic 数据管理的顶层单位就叫做 Index（索引）。它是单个数据库的同义词。每个 Index （即数据库）的名字必须是小写。下面的命令可以查看当前节点的所有 Index。1$ curl -X GET &apos;http://localhost:9200/_cat/indices?v&apos; DocumentIndex 里面单条的记录称为 Document（文档）。许多条 Document 构成了一个 Index。Document 使用 JSON 格式表示，下面是一个例子。12345&#123; &quot;user&quot;: &quot;张三&quot;, &quot;title&quot;: &quot;工程师&quot;, &quot;desc&quot;: &quot;数据库管理&quot;&#125; 同一个 Index 里面的 Document，不要求有相同的结构（scheme），但是最好保持相同，这样有利于提高搜索效率。 TypeDocument 可以分组，比如weather这个Index里面，可以按城市分组（北京和上海），也可以按气候分组（晴天和雨天）。这种分组就叫做Type，它是虚拟的逻辑分组，用来过滤 Document。不同的 Type 应该有相似的结构（schema），举例来说，id字段不能在这个组是字符串，在另一个组是数值。这是与关系型数据库的表的一个区别。性质完全不同的数据（比如products和logs）应该存成两个 Index，而不是一个 Index 里面的两个 Type（虽然可以做到）。下面的命令可以列出每个 Index 所包含的 Type。1$ curl &apos;localhost:9200/_mapping?pretty=true&apos; pretty=true 表示让返回结果的显示格式更美观 新建和删除 Index新建 Index1$ curl -X PUT &apos;localhost:9200/weather&apos; 服务器返回一个 JSON 对象，里面的acknowledged字段表示操作成功。1234&#123; &quot;acknowledged&quot;:true, &quot;shards_acknowledged&quot;:true&#125; 然后，我们发出 DELETE 请求，删除这个 Index。1$ curl -X DELETE &apos;localhost:9200/weather&apos; 中文分词设置安装中文分词插件。使用 ik1./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v5.5.1/elasticsearch-analysis-ik-5.5.1.zip 重新启动 Elastic，会自动加载这个新安装的插件 新建一个 Index，指定需要分词的字段。这一步根据数据结构而异，基本上，凡是需要搜索的中文字段，都要单独设置一下。123456789101112131415161718192021222324$ curl -X PUT &apos;localhost:9200/accounts&apos; -d &apos;&#123; &quot;mappings&quot;: &#123; &quot;person&quot;: &#123; &quot;properties&quot;: &#123; &quot;user&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;search_analyzer&quot;: &quot;ik_max_word&quot; &#125;, &quot;title&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;search_analyzer&quot;: &quot;ik_max_word&quot; &#125;, &quot;desc&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;search_analyzer&quot;: &quot;ik_max_word&quot; &#125; &#125; &#125; &#125;&#125;&apos; 以上是新建一个名称为accounts的 Index，里面有一个名称为person的 Type。person有三个字段123usertitledesc 而且类型都是文本（text），所以需要指定中文分词器，不能使用默认的英文分词器。lastic 的分词器称为 analyzer。对每个字段指定分词器。12345&quot;user&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;search_analyzer&quot;: &quot;ik_max_word&quot;&#125; 上面代码中，analyzer是字段文本的分词器，search_analyzer是搜索词的分词器。ik_max_word分词器是插件ik提供的，可以对文本进行最大数量的分词。 数据操作新增记录向指定的 /Index/Type 发送 PUT 请求，就可以在 Index 里面新增一条记录。比如，向/accounts/person发送请求，就可以新增一条人员记录。123456$ curl -X PUT &apos;localhost:9200/accounts/person/1&apos; -d &apos;&#123; &quot;user&quot;: &quot;张三&quot;, &quot;title&quot;: &quot;工程师&quot;, &quot;desc&quot;: &quot;数据库管理&quot;&#125;&apos; 服务器返回的 JSON 对象，会给出 Index、Type、Id、Version 等信息。123456789&#123; &quot;_index&quot;:&quot;accounts&quot;, &quot;_type&quot;:&quot;person&quot;, &quot;_id&quot;:&quot;1&quot;, &quot;_version&quot;:1, &quot;result&quot;:&quot;created&quot;, &quot;_shards&quot;:&#123;&quot;total&quot;:2,&quot;successful&quot;:1,&quot;failed&quot;:0&#125;, &quot;created&quot;:true&#125; 请求路径是/accounts/person/1，最后的1是该条记录的Id。它不一定是数字，任意字符串（比如abc）都可以。新增记录的时候，也可以不指定 Id，这时要改成 POST 请求。123456$ curl -X POST &apos;localhost:9200/accounts/person&apos; -d &apos;&#123; &quot;user&quot;: &quot;李四&quot;, &quot;title&quot;: &quot;工程师&quot;, &quot;desc&quot;: &quot;系统管理&quot;&#125;&apos; 向/accounts/person发出一个 POST 请求，添加一个记录。这时，服务器返回的 JSON 对象里面，_id字段就是一个随机字符串。123456789&#123; &quot;_index&quot;:&quot;accounts&quot;, &quot;_type&quot;:&quot;person&quot;, &quot;_id&quot;:&quot;AV3qGfrC6jMbsbXb6k1p&quot;, &quot;_version&quot;:1, &quot;result&quot;:&quot;created&quot;, &quot;_shards&quot;:&#123;&quot;total&quot;:2,&quot;successful&quot;:1,&quot;failed&quot;:0&#125;, &quot;created&quot;:true&#125; 注意，如果没有先创建 Index（这个例子是accounts），直接执行上面的命令，Elastic 也不会报错，而是直接生成指定的 Index。 查看记录向/Index/Type/Id发出 GET 请求，就可以查看这条记录。1$ curl &apos;localhost:9200/accounts/person/1?pretty=true&apos; 上面代码请求查看/accounts/person/1这条记录，URL 的参数pretty=true表示以易读的格式返回。返回的数据中，found字段表示查询成功，_source字段返回原始记录。123456789101112&#123; &quot;_index&quot; : &quot;accounts&quot;, &quot;_type&quot; : &quot;person&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_version&quot; : 1, &quot;found&quot; : true, &quot;_source&quot; : &#123; &quot;user&quot; : &quot;张三&quot;, &quot;title&quot; : &quot;工程师&quot;, &quot;desc&quot; : &quot;数据库管理&quot; &#125;&#125; 如果 Id 不正确，就查不到数据，found字段就是false。12345678$ curl &apos;localhost:9200/weather/beijing/abc?pretty=true&apos;&#123; &quot;_index&quot; : &quot;accounts&quot;, &quot;_type&quot; : &quot;person&quot;, &quot;_id&quot; : &quot;abc&quot;, &quot;found&quot; : false&#125; 删除记录1$ curl -X DELETE &apos;localhost:9200/accounts/person/1&apos; 更新记录更新记录就是使用 PUT 请求，重新发送一次数据。12345678910111213141516$ curl -X PUT &apos;localhost:9200/accounts/person/1&apos; -d &apos;&#123; &quot;user&quot; : &quot;张三&quot;, &quot;title&quot; : &quot;工程师&quot;, &quot;desc&quot; : &quot;数据库管理，软件开发&quot;&#125;&apos; &#123; &quot;_index&quot;:&quot;accounts&quot;, &quot;_type&quot;:&quot;person&quot;, &quot;_id&quot;:&quot;1&quot;, &quot;_version&quot;:2, &quot;result&quot;:&quot;updated&quot;, &quot;_shards&quot;:&#123;&quot;total&quot;:2,&quot;successful&quot;:1,&quot;failed&quot;:0&#125;, &quot;created&quot;:false&#125; 上面代码中，我们将原始数据从”数据库管理”改成”数据库管理，软件开发”。 返回结果里面，几个字段发生了变化。123&quot;_version&quot; : 2,&quot;result&quot; : &quot;updated&quot;,&quot;created&quot; : false 记录的 Id 没变，但是版本（version）从1变成2，操作类型（result）从created变成updated，created字段变成false，因为这次不是新建记录。 数据查询返回所有记录使用 GET 方法，直接请求/Index/Type/_search，就会返回所有记录。1234567891011121314151617181920212223242526272829303132333435$ curl &apos;localhost:9200/accounts/person/_search&apos;&#123; &quot;took&quot;:2, &quot;timed_out&quot;:false, &quot;_shards&quot;:&#123;&quot;total&quot;:5,&quot;successful&quot;:5,&quot;failed&quot;:0&#125;, &quot;hits&quot;:&#123; &quot;total&quot;:2, &quot;max_score&quot;:1.0, &quot;hits&quot;:[ &#123; &quot;_index&quot;:&quot;accounts&quot;, &quot;_type&quot;:&quot;person&quot;, &quot;_id&quot;:&quot;AV3qGfrC6jMbsbXb6k1p&quot;, &quot;_score&quot;:1.0, &quot;_source&quot;: &#123; &quot;user&quot;: &quot;李四&quot;, &quot;title&quot;: &quot;工程师&quot;, &quot;desc&quot;: &quot;系统管理&quot; &#125; &#125;, &#123; &quot;_index&quot;:&quot;accounts&quot;, &quot;_type&quot;:&quot;person&quot;, &quot;_id&quot;:&quot;1&quot;, &quot;_score&quot;:1.0, &quot;_source&quot;: &#123; &quot;user&quot; : &quot;张三&quot;, &quot;title&quot; : &quot;工程师&quot;, &quot;desc&quot; : &quot;数据库管理，软件开发&quot; &#125; &#125; ] &#125;&#125; took字段表示该操作的耗时（单位为毫秒），timed_out字段表示是否超时，hits字段表示命中的记录，里面子字段的含义如下。 total：返回记录数，本例是2条。max_score：最高的匹配程度，本例是1.0。hits：返回的记录组成的数组。返回的记录中，每条记录都有一个_score字段，表示匹配的程序，默认是按照这个字段降序排列。 全文搜索 使用GET 请求并带有数据体。1234$ curl &apos;localhost:9200/accounts/person/_search&apos; -d &apos;&#123; &quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;desc&quot; : &quot;软件&quot; &#125;&#125;&#125;&apos; 上面代码使用 Match查询，指定的匹配条件是desc字段里面包含”软件“这个词。返回结果如下。12345678910111213141516171819202122&#123; &quot;took&quot;:3, &quot;timed_out&quot;:false, &quot;_shards&quot;:&#123;&quot;total&quot;:5,&quot;successful&quot;:5,&quot;failed&quot;:0&#125;, &quot;hits&quot;:&#123; &quot;total&quot;:1, &quot;max_score&quot;:0.28582606, &quot;hits&quot;:[ &#123; &quot;_index&quot;:&quot;accounts&quot;, &quot;_type&quot;:&quot;person&quot;, &quot;_id&quot;:&quot;1&quot;, &quot;_score&quot;:0.28582606, &quot;_source&quot;: &#123; &quot;user&quot; : &quot;张三&quot;, &quot;title&quot; : &quot;工程师&quot;, &quot;desc&quot; : &quot;数据库管理，软件开发&quot; &#125; &#125; ] &#125;&#125; 可以通过size字段改变这个返回的条数,默认10条。12345$ curl &apos;localhost:9200/accounts/person/_search&apos; -d &apos;&#123; &quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;desc&quot; : &quot;管理&quot; &#125;&#125;, &quot;size&quot;: 1&#125;&apos; 可以通过from字段指定位移123456$ curl &apos;localhost:9200/accounts/person/_search&apos; -d &apos;&#123; &quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;desc&quot; : &quot;管理&quot; &#125;&#125;, &quot;from&quot;: 1, &quot;size&quot;: 1&#125;&apos; 从位置1开始（默认是从位置0开始），只返回一条结果。 逻辑运算如果有多个搜索关键字， Elastic 认为它们是or关系。1234$ curl &apos;localhost:9200/accounts/person/_search&apos; -d &apos;&#123; &quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;desc&quot; : &quot;软件 系统&quot; &#125;&#125;&#125;&apos; 上面代码搜索的是软件 or 系统。如果要执行多个关键词的and搜索，必须使用布尔查询。1234567891011$ curl &apos;localhost:9200/accounts/person/_search&apos; -d &apos;&#123; &quot;query&quot;: &#123; &quot;bool&quot;: &#123; &quot;must&quot;: [ &#123; &quot;match&quot;: &#123; &quot;desc&quot;: &quot;软件&quot; &#125; &#125;, &#123; &quot;match&quot;: &#123; &quot;desc&quot;: &quot;系统&quot; &#125; &#125; ] &#125; &#125;&#125;&apos;","categories":[],"tags":[{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"http://yoursite.com/tags/ElasticSearch/"}]},{"title":"java实现动态代理","slug":"java实现动态代理","date":"2019-01-19T11:04:56.000Z","updated":"2019-01-25T07:29:11.324Z","comments":true,"path":"2019/01/19/java实现动态代理/","link":"","permalink":"http://yoursite.com/2019/01/19/java实现动态代理/","excerpt":"java的动态代理机制中，有两个重要的类或接口，一个是 InvocationHandler(Interface)、另一个是 Proxy(Class)","text":"java的动态代理机制中，有两个重要的类或接口，一个是 InvocationHandler(Interface)、另一个是 Proxy(Class) InvocationHandler: InvocationHandler is the interface implemented by the invocation handler of a proxy instance.InvocationHandler是代理实例的调用处理程序实现的接口Each proxy instance has an associated invocation handler. When a method is invoked on a proxy instance, the method invocation is encoded and dispatched to the invoke method of its invocation handler.每个代理实例都有一个关联的调用处理程序。在代理实例上调用方法时，方法调用将被编码并发送到其调用处理程序的invoke方法。 invoke方法12345Object invoke(Object proxy, Method method, Object[] args) throws Throwableproxy: 指代我们所代理的那个真实对象method: 指代的是我们所要调用真实对象的某个方法的Method对象args: 指代的是调用真实对象某个方法时接受的参数 newProxyInstanceProxy这个类的作用就是用来动态创建一个代理对象的类，它提供了许多的方法，用的最多的就是 newProxyInstance 这个方法1234567public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentExceptionloader: 一个ClassLoader对象，定义了由哪个ClassLoader对象来对生成的代理对象进行加载interfaces: 一个Interface对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了h: 一个InvocationHandler对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上 实现1.定义一个Subject类型的接口12345public interface Subject &#123;//定义了两个方法 public void rent(); public void hello(String str);&#125; 2.定义一个类来实现这个接口，这个类就是真实对象，RealSubject类：1234567891011public class RealSubject implements Subject&#123; @Override public void rent() &#123; System.out.println(&quot;I want to rent&quot;); &#125; @Override public void hello(String str) &#123; System.out.println(&quot;hello: &quot; + str); &#125;&#125; 3.定义一个动态代理类，每一个动态代理类都必须要实现 InvocationHandler123456789101112131415161718192021222324import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class DynamicProxy implements InvocationHandler &#123; // 这个就是我们要代理的真实对象 private Object subject; // 构造方法，给我们要代理的真实对象赋初值 public DynamicProxy(Object subject) &#123; this.subject = subject; &#125; @Override public Object invoke(Object object, Method method, Object[] args) throws Throwable &#123; //在代理真实对象前我们可以添加一些自己的操作 System.out.println(&quot;before rent house&quot;); System.out.println(&quot;Method: &quot;+method); //此时是调用真实对象的方法 method.invoke(subject,args); //代理后同样可以添加一些操作 //doSomething(); return null; &#125;&#125; Client类1234567891011121314151617181920212223242526272829import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;public class Client &#123; public static void main(String[] args)&#123; // 要代理的真实对象 RealSubject realSubject = new RealSubject(); // 要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法的 InvocationHandler handler = new DynamicProxy(realSubject); Subject subject =(Subject) Proxy.newProxyInstance( realSubject.getClass().getClassLoader(),//真实类的类加载器 realSubject.getClass().getInterfaces(),//被代理类的接口 handler//代理对象 ); System.out.println(subject.getClass().getName()); subject.rent(); subject.hello(&quot;The world will become better&quot;); &#125;&#125;输出:com.sun.proxy.$Proxy0before rent houseMethod: public abstract void 动态代理.Subject.rent()I want to rentbefore rent houseMethod: public abstract void 动态代理.Subject.hello(java.lang.String)hello: The world will become better 通过 Proxy.newProxyInstance 创建的代理对象subject是在jvm运行时动态生成的一个对象，它并不是InvocationHandler类型，也不是我们定义的那组接口的类型，而是在运行时动态生成的一个对象，并且命名方式都是这样的形式，以$开头，proxy为中，最后一个数字表示对象的标号。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"动态代理","slug":"动态代理","permalink":"http://yoursite.com/tags/动态代理/"}]},{"title":"Spring相关","slug":"Spring相关","date":"2019-01-19T09:45:30.000Z","updated":"2019-01-28T16:20:08.520Z","comments":true,"path":"2019/01/19/Spring相关/","link":"","permalink":"http://yoursite.com/2019/01/19/Spring相关/","excerpt":"IOC/DI","text":"IOC/DI 1. 概念及原理 IOC: Inversion of Control(控制反转)是一种设计思想,利用了工厂模式。对象及其依赖对象的创建及维护都不需要在应用程序中实现，将其交给IOC容器去管理。传统的开发中，我们自己在对象内部创建依赖对象并注入当前对象，完成依赖关系的维护；对于IOC而言，强调将主动变为被动，由IOC容器来负责依赖对象的创建和查找，由IOC容器来进行注入组合对象，只需要在相关的配置文件中维护对象之间的依赖关系即可。 DI: Dependency Injection，即“依赖注入”。其实IOC和DI本就是同一个概念的两种不同的表述，应用程序依赖容器提供的外部对象，容器将其依赖的外部资源在运行期注入到应用程序中；某个对象被调用时，其所依赖的对象由容器注入。 2.AOP AOP利用一种称为“横切”的技术，剖解开封装的对象内部，将那些影响多个类的公共行为封装到一个可重用模块，并将其名为切面(Aspect)。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑封装起来的部分。以便于减少系统的重复代码，降低模块间的耦合度，并有利于系统维护。 使用“横切”技术，AOP把软件系统分为两个部分：核心关注点（业务逻辑）和横切关注点（通用逻辑，即方面）。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的特点是，其经常发生在核心关注点的多处，而各处都基本相似。比如权限认证、日志、事务处理，debug管理，性能检测等。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"第十章 内部类","slug":"第十章-内部类","date":"2019-01-17T02:52:05.000Z","updated":"2019-01-25T07:29:50.401Z","comments":true,"path":"2019/01/17/第十章-内部类/","link":"","permalink":"http://yoursite.com/2019/01/17/第十章-内部类/","excerpt":"了解外围类,并且能与之通信","text":"了解外围类,并且能与之通信 内部类能访问其外围对象的所有成员而不需要任何特殊条件，当某个外围类对象创建了一个内部类对象时，此内部类对象必定会秘密地捕获一个指向那个外部类对象的引用，然后在你访问此外围类的成员时,就是用那个引用来选择外围的成员。使用.this 和.new需要需要生成对外部类对象的引用,可以使用外部类的名字后紧跟原点和this.1234567891011121314151617public class DotThis&#123; void f()&#123;System.out.println(&quot;DotThis.f()&quot;);&#125; public class Inner&#123; public class DotThis outer()&#123; return DotThis.this; &#125; &#125; public Inner inner()&#123;return new TInner();&#125; public static void main(String[] args)&#123; DotThis dt = new DotThis(); DotThis.Inner dti = dt.inner(); dti.outer().f(); &#125;&#125;/*Output:DotThis.f()*/ 直接创建内部类的对象:在ner表达式中提供对其外部类对象的引用12DotNew dn = new DotNew();DotNew.Inner dni = dn.new Inner(); 匿名内部类如果定义一个匿名内部类,并且希望它日用外部定义的对象,那么编译器会要求其参数引用为final123456789101112public interface Destination&#123; String readLabel();&#125;public class Parcel9&#123; public Destination destination(final String dest)&#123; return new Destination()&#123; private String label = dest; public String readLabel()&#123;return label&#125; &#125;; &#125;&#125; 这里引用了外部类的String对象dest,所以要求参数引用必须为final 嵌套类(static)如果不需要内部类与外围类对象之间有练习,可以将内部类声明为static普通内部类与static的嵌套类的区别: 1.创建嵌套类的对象,并不需要其外围类的对象.2.不能从嵌套类的对象中访问非静态的外围类对象.3.普通的内部类不能有static数据和static字段,也不能包含嵌套类,即(内部类中还有内部类),而嵌套类(static)可以做到. 接口内部的类正常情况下,不能在接口内置任何代码,但嵌套类可以作为接口的一部分,放置到接口中的任何类都自动是public 和 static的.因为类是static的,只是将嵌套类置于接口的命名空间,并不违反接口的规则. 甚至可以在内部类中实现其外围接口 从多层嵌套类访问外部成员内部类—可以透明地访问所有它的外围成员(不论是不是private)嵌套内部类—可以透明地访问它所嵌入的外围类的所有成员12345678910111213141516171819class MNA&#123; private void f()&#123;&#125; class A&#123; private void g()&#123;&#125; public class B&#123; void h()&#123; g(); f(); &#125; &#125; &#125;&#125;public class MultiNestingAccess&#123; public static void main(String[] args)&#123; MNA mna = new MNA(); MNA.A mnaa = mna.new A(); MNA.A.B mnaab = mnaa.new B(); &#125;&#125; 可以看到在MNA,A,A中, 调用方法g()和f()并不需要任何条件(即使被声明为private)","categories":[],"tags":[{"name":"java编程思想","slug":"java编程思想","permalink":"http://yoursite.com/tags/java编程思想/"},{"name":"内部类","slug":"内部类","permalink":"http://yoursite.com/tags/内部类/"}]},{"title":"git常用命令","slug":"git常用命令","date":"2019-01-16T12:08:04.000Z","updated":"2019-01-25T07:28:52.763Z","comments":true,"path":"2019/01/16/git常用命令/","link":"","permalink":"http://yoursite.com/2019/01/16/git常用命令/","excerpt":"git clone url 克隆项目到本地","text":"git clone url 克隆项目到本地 git push 提交git branch 显示所有分支git status 查看修改的内容git add . 确认所有修改git commit -m “这里是注释”git diff 显示差别git log 查看提交的日志git rebase -i [startpoint] [endpoint] 其中-i的意思是–interactive，即弹出交互式的界面让用户编辑完成合并操作，[startpoint] [endpoint]则指定了一个编辑区间，如果不指定[endpoint]，则该区间的终点默认是当前分支HEAD所指向的commit fetch更新本地仓库两种方式1234567891011121314//方法一$ git fetch origin master //从远程的origin仓库的master分支下载代码到本地的origin master$ git log -p master.. origin/master//比较本地的仓库和远程参考的区别$ git merge origin/master//把远程下载下来的代码合并到本地仓库，远程的和本地的合并//方法二$ git fetch origin master:temp //从远程的origin仓库的master分支下载到本地并新建一个分支temp$ git diff temp//比较master分支和temp分支的不同$ git merge temp//合并temp分支到master分支$ git branch -d temp//删除temp","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"Java基础笔记","slug":"Java基础零散笔记","date":"2019-01-15T07:55:12.000Z","updated":"2019-01-25T07:31:18.636Z","comments":true,"path":"2019/01/15/Java基础零散笔记/","link":"","permalink":"http://yoursite.com/2019/01/15/Java基础零散笔记/","excerpt":"1.URL u =new URL(“http://www.123.com&quot;);。如果www.123.com不存在，则返回______。","text":"1.URL u =new URL(“http://www.123.com&quot;);。如果www.123.com不存在，则返回______。result:返回’http://www.123.com&#39;,我们在执行URL u =new URL(“http://www.123.com&quot;);这句话的时候确实要抛出异常，但是这个异常属于IOException，不管网址是否存在，最后都会返回该网址的一个连接，打印出来就是该网址。 2.新建的线程调用start()方法就能立即进行运行状态result:错误,调用start()后让thread进去可运行状态（runnable），只是等待获取CPU的使用权。 3. CountDownLatch：允许一个或多个线程等待其他线程完成操作； CyclicBarrier：同步屏障，让一组线程到达一个屏障时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会执行。 4. String str1 = &quot;hello&quot;; String str2 = &quot;he&quot;+new String(&quot;llo&quot;); System.out.println(str1==str2); //false, 5.java中的true,false,null不是关键字,只是一些显式常量值 6.异常相关 运行时异常： 都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。 运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。非运行时异常 （编译异常）： 是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。 7.类的加载 父类静态域(static修饰)=&gt;子类静态域(static修饰)=&gt;父类成员和构造块=&gt;父类的构造方法&gt;=子类的成员和构造代码块&gt;=子类的构造方法 普通成员变量和普通代码块是同级的 执行按照先后顺序进行 8.abstract和final abstract和final不能用来修饰同一个类abstract类中可以没有抽象方法，接口中也可以有abstract方法。 9.servlet周期包括__. init() –&gt; 初始化service() –&gt; 处理请求destory () –&gt; 销毁 10.下面哪个语句是创建数组的正确语句？( )A.float f[][] = new float[6][6];B.float []f[] = new float[6][6];C.float f[][] = new float[][6];D.float [][]f = new float[6][6];E.float [][]f = new float[6][]; result:ABDE ABDE都可以。也就是说数组命名时名称与[]可以随意排列，但声明的二维数组中第一个中括号中必须要有值，它代表的是在该二维数组中有多少个一维数组。阿里规范里，数组严禁使用int a[][] 等形式，应当使用int[][] a 的可读性较强的形式","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"第三章 操作符","slug":"第三章-操作符","date":"2019-01-15T02:51:54.000Z","updated":"2019-01-25T07:29:42.474Z","comments":true,"path":"2019/01/15/第三章-操作符/","link":"","permalink":"http://yoursite.com/2019/01/15/第三章-操作符/","excerpt":"逻辑操作符:","text":"逻辑操作符: 逻辑操作符使用双位字符(&amp;&amp;或者||) 按位操作符:按位与 : &amp; 按位或 : | ~符号 : 每一位都取反 ^异或操作符 : 只要输入为的某一个是1,但不全是都是1,那么按位异或操作生成一个输出位1.(如果两个都为1,则异或的结果位0) 相反数 : 除了第一个符号位不变外,所有位都取反最后加1 Integer相关Integer.MAX_VALUE =0111,1111,1111,1111,1111,1111,1111,1111. 一共31个1,值为2`31-1; Integer.MIN_VALUE= 1000,0000,0000,0000,0000,0000,0000,0000 一共32位,值为-2`31;1System.out.println(Integer.MAX_VALUE+1==Integer.MIN_VALUE); 输出结果为TRUE1System.out.println(1&lt;&lt;31==Integer.MIN_VALUE); 输出结果为TRUE 截尾和舍入将float和double转化为整形值时 总是对该数字进行截尾 如29.7 转化为29 0.7转化为0 提升基本类型的运算: 只要类型比int小 运算之前会把值自动转换为int，这样一来，最终生成的结果就是int类型。 表达式中出现的最大的数据类型决定了表达式最终结果的数据类型","categories":[],"tags":[{"name":"java编程思想","slug":"java编程思想","permalink":"http://yoursite.com/tags/java编程思想/"},{"name":"操作符","slug":"操作符","permalink":"http://yoursite.com/tags/操作符/"}]},{"title":"记一次防止渗透的措施","slug":"记一次防止渗透的措施","date":"2019-01-14T14:47:28.000Z","updated":"2019-01-25T07:29:58.798Z","comments":true,"path":"2019/01/14/记一次防止渗透的措施/","link":"","permalink":"http://yoursite.com/2019/01/14/记一次防止渗透的措施/","excerpt":"在后端做文件上传的格式校验时,不能只对Content-Type做校验","text":"在后端做文件上传的格式校验时,不能只对Content-Type做校验12345678910111213if(!$image = CUploadedFile::getInstanceByName(&apos;upload_file&apos;)) &#123; $response[&apos;code&apos;] = -2; $response[&apos;msg&apos;] = &apos;param error&apos;; &#125; else if($image-&gt;getSize() == 0 || $image-&gt;getSize() &gt; 1*1024*1024) &#123; $response[&apos;code&apos;] = -3; $response[&apos;msg&apos;] = &apos;size error&apos;; &#125; else if(!in_array($image-&gt;type, array(&apos;image/jpeg&apos;, &apos;image/png&apos;, &apos;image/gif&apos;)))&#123; $response[&apos;code&apos;] = -4; $response[&apos;msg&apos;] = &apos;type error&apos;; &#125; else if(!$image-&gt;saveAs($local_file.&apos;.&apos;.$image-&gt;extensionName)) &#123; $response[&apos;code&apos;] = -5; $response[&apos;msg&apos;] = &apos;file save error&apos;; &#125; 项目原先的代码文件类型处只对Content-Type做了校验,无法防止渗透,测试人员可以通过修改文件后缀名配合BuirSuit等抓包工具在绕过前端验证后删除后缀名达到成功上传其他格式文件的限制 改善措施:1234else if(!in_array($image-&gt;extensionName,array(&apos;jpg&apos;,&apos;jpeg&apos;, &apos;png&apos;, &apos;gif&apos;)))&#123; $response[&apos;code&apos;] = -4; $response[&apos;msg&apos;] = &apos;type error&apos;; &#125; 添加对文件后缀名的验证","categories":[],"tags":[{"name":"记","slug":"记","permalink":"http://yoursite.com/tags/记/"}]},{"title":"PHP笔记","slug":"PHP笔记","date":"2019-01-14T12:45:53.000Z","updated":"2019-01-28T16:19:30.306Z","comments":true,"path":"2019/01/14/PHP笔记/","link":"","permalink":"http://yoursite.com/2019/01/14/PHP笔记/","excerpt":"1. 变量","text":"1. 变量 变量以\\$符号开始，后面跟着变量的名称变量名必须以字母或者下划线字符开始变量名只能包含字母数字字符以及下划线（A-z、0-9 和 _ ）变量名不能包含空格变量名是区分大小写的（$y 和 $Y 是两个不同的变量） 作用域： local global(global 关键字用于函数内访问全局变量) static(希望某个局部变量在方法执行完后不删除,则使用static) parameter(参数是在参数列表中声明的，作为函数声明的一部分：) 2. echo 和 printecho 和 print 区别: echo - 可以输出一个或多个字符串(echo “这是一个”, “字符串，”, “使用了”, “多个”, “参数。”;)print - 只允许输出一个字符串，返回值总为 1echo 输出的速度比 print 快， echo 没有返回值，print有返回值1。 3. EOF PHP EOF(heredoc)是一种在命令行shell（如sh、csh、ksh、bash、PowerShell和zsh）和程序语言（像Perl、PHP、Python和Ruby）里定义一个字串的方法。 必须后接分号，否则编译通不过。 EOF 可以用任意其它字符代替，只需保证结束标识与开始标识一致。 结束标识必须顶格独自占一行(即必须从行首开始，前后不能衔接任何空白和字符)。 开始标识可以不带引号或带单双引号，不带引号与带双引号效果一致，解释内嵌的变量和转义符号，带单引号则不解释内嵌的变量和转义符号。 当内容需要内嵌引号（单引号或双引号）时，不需要加转义符，本身对单双引号转义，此处相当与q和qq的用法。 1234567&lt;?phpecho &lt;&lt;&lt;EOF &lt;h1&gt;我的第一个标题&lt;/h1&gt; &lt;p&gt;我的第一个段落。&lt;/p&gt;EOF;// 结束需要独立一行且前后不能空格?&gt; EOF 的作用就是按照原样，包括换行格式什么的，输出在其内部的东西；在 PHP 定界符 EOF 中的任何特殊字符都不需要转义； 4.数据类型String（字符串）, Integer（整型）, Float（浮点型）, Boolean（布尔型）, Array（数组）, Object（对象）, NULL（空值）。var_dump() 函数返回变量的数据类型和值： PHP 对象:对象数据类型也可以用于存储数据。 在 PHP 中，对象必须声明。首先，必须使用class关键字声明类对象。类是可以包含属性和方法的结构。然后在类中定义数据类型，然后在实例化的类中使用数据类型：123456789101112&lt;?phpclass Car&#123; var $color; function __construct($color=&quot;green&quot;) &#123; $this-&gt;color = $color; &#125; function what_color() &#123; return $this-&gt;color; &#125;&#125;?&gt; this 就是指向当前对象的指针 5.常量设置常量: define(name,value,case_insensitive); name：必选参数，常量名称，即标志符。value：必选参数，常量的值。case_insensitive ：可选参数，如果设置为TRUE，该常量则大小写不敏感。默认是大小写敏感的。 常量是全局的,常量在定义后，默认是全局变量，可以在整个运行的脚本的任何地方使用。 5.字符串PHP 并置运算符: 在 PHP 中，只有一个字符串运算符,并置运算符 (.) 用于把两个字符串值连接起来。 strlen() 函数: 获取长度 strpos() 函数: strpos() 函数用于在字符串内查找一个字符或一段指定的文本。如果在字符串中找到匹配，该函数会返回第一个匹配的字符位置。如果未找到匹配，则返回 FALSE。 6.运算符 优先级： &amp;&amp; &gt; = &gt; and 优先级： || &gt; = &gt; or 12345678&lt;?php$a = 3;$b = false;$c = $a or $b;var_dump($c); // 这里的 $c 为 int 值3，而不是 boolean 值 true$d = $a || $b;var_dump($d); //这里的 $d 就是 boolean 值 true ?&gt; 7.PHP 数组PHP一维数组:1234&lt;?php$cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);echo &quot;I like &quot; . $cars[0] . &quot;, &quot; . $cars[1] . &quot; and &quot; . $cars[2] . &quot;.&quot;;?&gt; 关联数组:相当于键值对形式1234&lt;?php$age=array(&quot;Peter&quot;=&gt;&quot;35&quot;,&quot;Ben&quot;=&gt;&quot;37&quot;,&quot;Joe&quot;=&gt;&quot;43&quot;);echo &quot;Peter is &quot; . $age[&apos;Peter&apos;] . &quot; years old.&quot;;?&gt; 多维数组:12345678910111213141516171819202122232425262728293031&lt;?php$cars = array(//二维数组array(&quot;Volvo&quot;,100,96),array(&quot;BMW&quot;,60,59),array(&quot;Toyota&quot;,110,100));?&gt;//多维数组$sites = array( &quot;runoob&quot;=&gt;array ( &quot;菜鸟教程&quot;, &quot;http://www.runoob.com&quot; ), &quot;google&quot;=&gt;array ( &quot;Google 搜索&quot;, &quot;http://www.google.com&quot; ), &quot;taobao&quot;=&gt;array ( &quot;淘宝&quot;, &quot;http://www.taobao.com&quot; ));print(&quot;&lt;pre&gt;&quot;); // 格式化输出数组print_r($sites);print(&quot;&lt;/pre&gt;&quot;); 8.PHP超级全局变量 \\$GLOBALS \\$_SERVER \\$_REQUEST \\$_POST \\$_GET \\$_FILES \\$_ENV \\$_COOKIE \\$_SESSION 9.魔术常量123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?phpecho &apos;这是第 &quot; &apos; . __LINE__ . &apos; &quot; 行&apos;;?&gt;&lt;?phpecho &apos;该文件位于 &quot; &apos; . __FILE__ . &apos; &quot; &apos;;?&gt;&lt;?phpecho &apos;该文件位于 &quot; &apos; . __DIR__ . &apos; &quot; &apos;;?&gt;&lt;?phpfunction test() &#123;echo &apos;函数名为：&apos; . __FUNCTION__ ;&#125;test();?&gt;&lt;?phpclass test &#123;function _print() &#123;echo &apos;类名为：&apos; . __CLASS__ . &quot;&lt;br&gt;&quot;;echo &apos;函数名为：&apos; . __FUNCTION__ ;&#125;&#125;$t = new test();$t-&gt;_print();?&gt;//trait&lt;?phpclass Base &#123;public function sayHello() &#123;echo &apos;Hello &apos;;&#125;&#125;trait SayWorld &#123;public function sayHello() &#123;parent::sayHello();echo &apos;World!&apos;;&#125;&#125;class MyHelloWorld extends Base &#123;use SayWorld;&#125;$o = new MyHelloWorld();$o-&gt;sayHello();?&gt;//method&lt;?phpfunction test() &#123;echo &apos;函数名为：&apos; . __METHOD__ ;&#125;test();?&gt;//namespace&lt;?phpnamespace MyProject;echo &apos;命名空间为：&quot;&apos;, __NAMESPACE__, &apos;&quot;&apos;; // 输出 &quot;MyProject&quot;?&gt; 10.命名空间 非限定名称，或不包含前缀的类名称，例如 $a=new foo(); 或 foo::staticmethod();。如果当前命名空间是 currentnamespace，foo 将被解析为 currentnamespace\\foo。如果使用 foo 的代码是全局的，不包含在任何命名空间中的代码，则 foo 会被解析为foo。 警告：如果命名空间中的函数或常量未定义，则该非限定的函数名称或常量名称会被解析为全局函数名称或常量名称。 限定名称**,或包含前缀的名称，例如 $a = new subnamespace\\foo(); 或 subnamespace\\foo::staticmethod();。如果当前的命名空间是 currentnamespace，则 foo 会被解析为 currentnamespace\\subnamespace\\foo。如果使用 foo 的代码是全局的，不包含在任何命名空间中的代码，foo 会被解析为subnamespace\\foo。 完全限定名称，或包含了全局前缀操作符的名称，例如， $a = new \\currentnamespace\\foo(); 或 \\currentnamespace\\foo::staticmethod();。在这种情况下，foo 总是被解析为代码中的文字名(literal name)currentnamespace\\foo。 持续更新…","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/tags/PHP/"}]}]}